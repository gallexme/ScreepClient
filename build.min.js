var $__app_95_app__ = function() {
    var app = angular.module("app", [
        "ngRoute",
        "ngAnimate",
        "ngMessages",
        "ngMaterial",
        "route-segment",
        "view-segment",
        "app.nw-manifest",
        "app.socket",
        "ui.ace",
        "ui.modal",
        "ui.bootstrap",
        "app.local-storage",
        "app.top",
        "app.game",
        "app.game.creep",
        "app.game.spawn",
        "app.game.source",
        "app.game.energy",
        "app.game.construction-site",
        "app.game.constructed-wall",
        "app.game.exit",
        "app.game.extension",
        "app.game.flag",
        "app.game.room.walls",
        "app.game.room.roads",
        "app.game.room.display-options-block",
        "app.game.room.rendered-svg-path",
        "app.game.room.view-popup",
        "ui.bootstrap.tabs",
        "app.game.memory",
        "app.game.console",
        "app.game.script",
        "luegg.directives",
        "app.connection",
        "app.game.room",
        "app.game.room.dlg-creep",
        "app.dialogs",
        "app.constants",
        "app.game.tutorial",
        "app.static-maps",
        "app.memory-storage",
        "app.game.editor-panel",
        "app.game.replay-list",
        "app.api",
        "app.config",
        "app.login",
        "app.register",
        "app.auth",
        "app.loader",
        "app.game.lobby",
        "ngAria",
        "app.game.room.dlg-flag",
        "app.game.room.spawn-properties",
        "app.game.room.creep-properties",
        "ui.drop",
        "app.profile",
        "app.profile.account",
        "app.key-filter",
        "app.game.keeper-lair",
        "app.game.portal",
        "app.game.lobby.survival",
        "app.game.lobby.arena",
        "app.game.room.dlg-arena-activation",
        "ui.json-editor",
        "app.profile.account.badge",
        "app.badge",
        "app.badge.paths",
        "app.game.world-map",
        "app.game.controller",
        "app.game.dlg-world-activation",
        "app.game.dlg-world-respawn",
        "app.profile.early-preview-request",
        "app.game.overview",
        "app.game.overview.room",
        "app.punchcard",
        "app.game.lobby.world",
        "app.ea",
        "app.game.room.controller-properties",
        "app.game.link",
        "app.game.room.flag-properties",
        "app.timeline-stats",
        "app.profile.messages.respondent",
        "app.profile.messages.index",
        "app.game.storage",
        "app.game.script.dlg-clone-branch",
        "app.order",
        "app.profile.cpu",
        "app.order.dlg-coupon",
        "app.order.twitter-promo",
        "app.game.tower",
        "app.game.observer",
        "app.game.disabled-object",
        "app.game.power-bank",
        "app.game.power-spawn",
        "app.game.lobby.power",
        "app.profile-stats",
        "app.recaptcha",
        "app.profile.account.subscription",
        "app.game.tutorial.index",
        "app.game.mineral",
        "app.game.extractor",
        "app.game.lab",
        "app.game.terminal",
        "app.game.container",
        "app.game.tutorial.section1",
        "app.game.tutorial.section2",
        "app.game.tutorial.section3",
        "app.game.tutorial.section4",
        "app.game.tutorial.section5",
        "angularSpectrumColorpicker",
        "app.game.market",
        "app.game.nuke",
        "app.game.nuker",
        "app.dlg-version-updated",
        "app.nw-menu",
        "app.code-branches",
        "app.nw-local-file-sync",
        "app.game.rampart",
        "app.game.room.rampart-properties",
        "app.game.market.all-orders",
        "app.game.market.my-orders",
        "app.game.market.history",
        "app.dlg-server-message"
    ]);
    return app.config([
        "$locationProvider",
        "$routeProvider",
        "$routeSegmentProvider",
        "$mdThemingProvider",
        "$compileProvider",
        function($locationProvider, $routeProvider, dataAndEvents, model, $$sanitizeUriProvider) {
            $locationProvider.hashPrefix("!");
            $routeProvider.otherwise({redirectTo: "/g"});
            model.theme("default").dark().primaryColor("indigo", {"hue-3": "A400"}).accentColor("teal", {"default": "500"}).warnColor("orange");
            model.setDefaultTheme("default");
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(/^\s*((https?|ftp|file|blob|chrome-extension|steam):|data:image\/)/);
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|file|chrome-extension|steam):/);
        }
    ]),
    app.constant("uiAceConfig", {
        ace: {
            advanced: {
                enableTern: {
                    defs: [
                        "ecma5", "ecma6", "screeps"
                    ],
                    plugins: {
                        doc_comment: {
                            fullDocs: true
                        }
                    },
                    useWorker: true,
                    /**
                         * @param {?} dataAndEvents
                         * @param {?} name
                         * @return {undefined}
                         */
                    switchToDoc: function(dataAndEvents, name) {},
                    /**
                         * @return {undefined}
                         */
                    startedCb: function() {}
                },
                enableSnippets: true,
                enableBasicAutocompletion: true
            }
        }
    }),
    app.constant("AppInstanceId", (new Date).getTime()),
    app.constant("ResourceTypeNames", {
        token: "subscription token",
        energy: "energy",
        power: "power",
        H: "hydrogen",
        O: "oxygen",
        U: "utrium",
        L: "lemergium",
        K: "keanium",
        Z: "zynthium",
        X: "catalyst",
        OH: "hydroxide",
        ZK: "zynthium keanite",
        UL: "utrium lemergite",
        G: "ghodium",
        UH: "utrium hydride",
        UO: "utrium oxide",
        KH: "keanium hydride",
        KO: "keanium oxide",
        LH: "lemergium hydride",
        LO: "lemergium oxide",
        ZH: "zynthium hydride",
        ZO: "zynthium oxide",
        GH: "ghodium hydride",
        GO: "ghodium oxide",
        UH2O: "utrium acid",
        UHO2: "utrium alkalide",
        KH2O: "keanium acid",
        KHO2: "keanium alkalide",
        LH2O: "lemergium acid",
        LHO2: "lemergium alkalide",
        ZH2O: "zynthium acid",
        ZHO2: "zynthium alkalide",
        GH2O: "ghodium acid",
        GHO2: "ghodium alkalide",
        XUH2O: "catalyzed utrium acid",
        XUHO2: "catalyzed utrium alkalide",
        XKH2O: "catalyzed keanium acid",
        XKHO2: "catalyzed keanium alkalide",
        XLH2O: "catalyzed lemergium acid",
        XLHO2: "catalyzed lemergium alkalide",
        XZH2O: "catalyzed zynthium acid",
        XZHO2: "catalyzed zynthium alkalide",
        XGH2O: "catalyzed ghodium acid",
        XGHO2: "catalyzed ghodium alkalide"
    }),
    app.run([
        "$routeSegment",
        "$rootScope",
        "Socket",
        "$http",
        "MemoryStorage",
        "LocalStorage",
        "Console",
        "Connection",
        "Auth",
        "Loader",
        "$mdAria",
        "$interval",
        "$document",
        "$injector",
        function(theTitle, self, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, $templateCache, keepData, opt_attributes, dataAndEvents, user, matcherFunction, $timeout, $window, $injector) {
            if (self.$routeSegment = theTitle, self._ = _, self.isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1, self.Me = function() {
                return dataAndEvents.Me;
            },
            self.Loader = user,
            self.Math = Math,
            self.isOffServer = function() {
                return $injector.get("Api").options.official;
            },
            $templateCache.get("firstVisit", false) === false) {
                /** @type {number} */
                var udataCur = (new Date).getTime();
                $templateCache.put("firstVisit", udataCur);
            }
            if ($timeout.bindToScope = function(scope, callback, opt_attributes) {
                var promise = $timeout(callback, opt_attributes);
                scope.$on("$destroy", function() {
                    return $timeout.cancel(promise);
                });
            },
            $window.bindToScope = function(scope, callback, opt_attributes) {
                /**
                         * @return {?}
                         */
                var resizeHandler = function() {
                    return scope.$apply(opt_attributes);
                };
                $window.bind(callback, resizeHandler);
                scope.$on("$destroy", function() {
                    return $window.unbind(callback, resizeHandler);
                });
            },
            window.nw) {
                /** @type {boolean} */
                self.nw = true;

            }
        }
    ]),
    app.directive("appShowWhenSteamOverlay", [
        "$animate",
        "$timeout",
        function($animate, $timeout) {
            return {
                /**
                     * @param {?} scope
                     * @param {Array} element
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function(scope, element, tabCtrl) {
                    /**
                         * @return {undefined}
                         */
                    function gameLoop() {
                        if (waitMsg) {
                            setTimeout(function() {
                                element[0].getContext("2d").clearRect(0, 0, 1, 1);
                                window.requestAnimationFrame(gameLoop);
                            }, 1E3 / 30);
                        }
                    }
                    /**
                         * @param {boolean} a
                         * @return {undefined}
                         */
                    function spin(a) {
                        $animate[a
                                ? "removeClass"
                                : "addClass"](element, "ng-hide");
                        /** @type {boolean} */
                        waitMsg = a;
                        if (waitMsg) {
                            gameLoop();
                            if (promise) {
                                $timeout.cancel(promise);
                                /** @type {null} */
                                promise = null;
                            }
                        }
                    }
                    var promise;
                    /** @type {boolean} */
                    var waitMsg = false;
                    scope.$on("$destroy", function() {
                        return waitMsg = false;
                    });
                }
            };
        }
    ]),
    app.directive("appCustomValidator", function() {
        return {
            require: "ngModel",
            /**
                 * @param {?} scope
                 * @param {?} tabCtrl
                 * @param {?} attrs
                 * @param {?} controller
                 * @return {undefined}
                 */
            link: function(scope, tabCtrl, attrs, controller) {
                var iterable = scope.$eval(attrs.appCustomValidator);
                var key;
                for (key in iterable) {
                    if (iterable[key]().$$state) {
                        controller.$asyncValidators[key] = iterable[key];
                    }
                }
                for (key in iterable) {
                    if (!iterable[key]().$$state) {
                        controller.$validators[key] = iterable[key];
                    }
                }
            }
        };
    }),
    app.directive("appController", function() {
        return {controller: "@", priority: -1E4};
    }),
    app.directive("appAutofocus", function() {
        return {
            /**
                 * @param {?} scope
                 * @param {Element} ctrl
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(scope, ctrl, attrs) {
                if (!attrs.appAutofocus || scope.$eval(attrs.appAutofocus)) {
                    setTimeout(function() {
                        ctrl.focus();
                    }, 100);
                }
            }
        };
    }),
    app.directive("appSubmit", [
        "$parse",
        function($parse) {
            return {
                /**
                     * @return {undefined}
                     */
                controller: function() {
                    /** @type {boolean} */
                    this.loadingCnt = false;
                },
                /**
                     * @param {?} scope
                     * @param {Object} $scope
                     * @param {?} attrs
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function(scope, $scope, attrs, tabCtrl) {
                    $scope.submit(function(evt) {
                        evt.preventDefault();
                        scope.$apply(function() {
                            var promise = $parse(attrs.appSubmit)(scope, {$event: evt});
                            if (promise) {
                                if (promise.then) {
                                    /** @type {boolean} */
                                    tabCtrl.loadingCnt = true;
                                    promise["catch"](function() {
                                        scope.$broadcast("form fail");
                                    })["finally"](function() {
                                        /** @type {boolean} */
                                        tabCtrl.loadingCnt = false;
                                    });
                                }
                            }
                        });
                    });
                }
            };
        }
    ]),
    app.directive("appFormFailAnim", [
        "$animate",
        function(exports) {
            return {
                /**
                     * @param {?} scope
                     * @param {?} el
                     * @param {?} settings
                     * @return {undefined}
                     */
                link: function(scope, el, settings) {
                    scope.$on("form fail", function() {
                        exports.addClass(el, settings.appFormFailAnim).then(function() {
                            return exports.removeClass(el, settings.appFormFailAnim);
                        });
                    });
                }
            };
        }
    ]),
    app.directive("appSubmitAnimated", function() {
        return {
            require: "^appSubmit",
            /**
                 * @param {?} scope
                 * @param {HTMLElement} context
                 * @param {?} attrs
                 * @param {?} tabCtrl
                 * @return {undefined}
                 */
            link: function(scope, context, attrs, tabCtrl) {
                scope.$watch(function() {
                    return tabCtrl.loadingCnt;
                }, function(disabled) {
                    context.toggleClass("striped", disabled);
                    if (disabled) {
                        context.attr("disabled", "disabled");
                    } else {
                        context.removeAttr("disabled");
                    }
                });
            }
        };
    }),
    app.directive("appFocusOnEvent", function() {
        return {
            /**
                 * @param {?} $scope
                 * @param {Object} scope
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function($scope, scope, attrs) {
                $scope.$on(attrs.appFocusOnEvent, function() {
                    setTimeout(function() {
                        scope.focus();
                        scope.find("input, textarea").focus();
                    }, 100);
                });
            }
        };
    }),
    app.directive("appCursorToEndOnEvent", function() {
        return {
            /**
                 * @param {?} scope
                 * @param {Node} controller
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(scope, controller, attrs) {
                scope.$on(attrs.appCursorToEndOnEvent, function() {
                    if (controller.get(0).setSelectionRange) {
                        controller.get(0).setSelectionRange(controller.val().length, controller.val().length);
                    }
                });
            }
        };
    }),
    app.directive("appStopClickPropagation", function() {
        return function(scope, submit, attrs) {
            submit.click(function(ev) {
                if ("~" == attrs.appStopClickPropagation.charAt(0)) {
                    var attr = attrs.appStopClickPropagation.match(/^~(.*)$/);
                    if (!attr[1] || scope.$eval(attr[1])) {
                        ev.stopImmediatePropagation();
                    }
                } else {
                    if ("" == attrs.appStopClickPropagation || scope.$eval(attrs.appStopClickPropagation)) {
                        ev.stopPropagation();
                    }
                }
            });
        };
    }),
    app.directive("appStopPropagation", function() {
        return function(dataAndEvents, element, handler) {
            element.bind(handler.appStopPropagation, function(event) {
                event.stopPropagation();
            });
        };
    }),
    app.directive("appClickAnimated", [
        "$parse",
        function($parse) {
            return {
                scope: true,
                /**
                     * @param {?} scope
                     * @param {Object} elm
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(scope, elm, attrs) {
                    elm.bind("click", function(event) {
                        elm.addClass("striped");
                        elm.attr("disabled", "disabled");
                        scope.$apply(function() {
                            var promise = $parse(attrs.appClickAnimated)(scope, {$event: event});
                            promise["finally"](function() {
                                if (elm.removeClass("striped"), attrs.ngDisabled) {
                                    var a = scope.$eval(attrs.ngDisabled);
                                    if (a) {
                                        elm.attr("disabled", "disabled");
                                    } else {
                                        elm.removeAttr("disabled");
                                    }
                                } else {
                                    elm.removeAttr("disabled");
                                }
                            });
                        });
                    });
                }
            };
        }
    ]),
    app.directive("appOnCtrlEnter", function() {
        return {
            /**
                 * @param {?} scope
                 * @param {Object} elm
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(scope, elm, attrs) {
                elm.find("textarea").keydown(function(e) {
                    if ((e.ctrlKey || e.shiftKey) && 13 == e.keyCode || e.ctrlKey && 83 == e.keyCode) {
                        e.preventDefault();
                        scope.$apply(function() {
                            return scope.$eval(attrs.appOnCtrlEnter);
                        });
                    }
                });
            }
        };
    }),
    app.directive("appFacebookParse", [
        "$timeout",
        function($resource) {
            return {
                /**
                     * @param {?} tabCtrl
                     * @param {?} scope
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(tabCtrl, scope, attrs) {
                    $resource(function() {
                        FB.XFBML.parse();
                    }, 10);
                }
            };
        }
    ]),
    app.directive("appAutoScrollWatch", function() {
        return {
            priority: 1E5,
            /**
                 * @param {?} scope
                 * @param {Array} c
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(scope, c, attrs) {
                /** @type {number} */
                var viewportHeight = 0;
                scope.$watch(attrs.appAutoScrollWatch, function() {
                    if (null !== viewportHeight) {
                        setTimeout(function() {
                            /** @type {number} */
                            c[0].scrollTop = c[0].scrollHeight - c.height() - viewportHeight;
                            if (viewportHeight) {
                                /** @type {number} */
                                viewportHeight = 0;
                            }
                        }, 0);
                    }
                });
                c.scroll(function() {
                    if (0 === viewportHeight || null === viewportHeight) {
                        /** @type {(null|number)} */
                        viewportHeight = c[0].scrollTop == c[0].scrollHeight - c.height()
                            ? 0
                            : null;
                    }
                });
                scope.$on("save scroll", function() {
                    /** @type {number} */
                    viewportHeight = c[0].scrollHeight - c.height() - c[0].scrollTop;
                });
            }
        };
    }),
    app.directive("appEnterSubmit", function() {
        return {
            /**
                 * @param {?} tabCtrl
                 * @param {Object} scope
                 * @return {undefined}
                 */
            link: function(tabCtrl, scope) {
                scope.keydown(function(event) {
                    if (13 == event.keyCode) {
                        if (event.ctrlKey) {
                            $(scope.get(0).form).submit();
                            event.preventDefault();
                        }
                    }
                });
            }
        };
    }),
    app.directive("appClickSelectAll", function() {
        return {
            /**
                 * @param {?} tabCtrl
                 * @param {HTMLElement} scope
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(tabCtrl, scope, attrs) {
                scope.click(function() {
                    return scope[0].select();
                });
            }
        };
    }),
    app.directive("appButtonCopyInput", function() {
        return {
            /**
                 * @param {?} tabCtrl
                 * @param {Object} elm
                 * @param {?} scope
                 * @return {undefined}
                 */
            link: function(tabCtrl, elm, scope) {
                elm.find("button").click(function() {
                    elm.find("input")[0].select();
                    document.execCommand("copy");
                });
            }
        };
    }),
    app.directive("appNwExternalLink", function() {
        return {
            /**
                 * @param {?} tabCtrl
                 * @param {HTMLElement} el
                 * @param {?} href
                 * @return {undefined}
                 */
            link: function(tabCtrl, el, href) {
                if (window.nw) {
                    el.click(function(types) {
                        nw.Shell.openExternal(href.appNwExternalLink || el.attr("href"));
                        types.preventDefault();
                    });
                }
            }
        };
    }),
    app.filter("empty", function() {
        return function(obj) {
            if (_.isObject(obj)) {
                if (_.isArray(obj)) {
                    return 0 == obj.length;
                }
                var key;
                for (key in obj) {
                    if (!_.isFunction(obj[key]) && (null !== obj[key] && void 0 !== obj[key])) {
                        return false;
                    }
                }
                return true;
            }
            return null === obj || void 0 === obj;
        };
    }),
    app.filter("keys", function() {
        return function(shallow) {
            return _.keys(shallow);
        };
    }),
    app.filter("sort", function() {
        return function(results) {
            return results.sort();
        };
    }),
    app.filter("trust", [
        "$sce",
        function($sce) {
            return function(newVal) {
                return $sce.trustAsHtml(newVal);
            };
        }
    ]),
    app.filter("bust", function() {
        return function(dataAndEvents) {
            return dataAndEvents + "?bust=1479290327467";
        };
    }),
    app.filter("readableDate", [
        "$locale",
        function(dataAndEvents) {
            return function(dateString) {
                /** @type {Date} */
                var tempDate = new Date;
                /** @type {Date} */
                var date = new Date(dateString);
                /** @type {Date} */
                var defaultCenturyStart = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate(), 0, 0, 0);
                if (date.getTime() > tempDate.getTime() - 6E4) {
                    return "Just now";
                }
                if (date.getTime() > tempDate.getTime() - 36E5) {
                    /** @type {number} */
                    var e = Math.round((tempDate.getTime() - date.getTime()) / 1E3 / 60);
                    return e + (1 != e
                        ? " minutes ago"
                        : " minute ago");
                }
                if (date.getTime() >= defaultCenturyStart.getTime()) {
                    return "Today at " + date.toLocaleTimeString();
                }
                if (date.getTime() > (new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() - 1, 0, 0, 0)).getTime()) {
                    return "Yesterday at " + date.toLocaleTimeString();
                }
                if (date.getTime() > (new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() - 4, 0, 0, 0)).getTime()) {
                    /** @type {number} */
                    var f = Math.round((defaultCenturyStart.getTime() - new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0)) / 24 / 3600 / 1E3);
                    return f + " days ago";
                }
                return date.toLocaleDateString();
            };
        }
    ]),
    app.factory("$mdAria", function() {
        return {expect: angular.noop, expectWithText: angular.noop};
    }),
    app.filter("pad", function() {
        return function(index) {
            return 10 > index
                ? "0" + index
                : index;
        };
    }),
    app.filter("round", function() {
        return function(val) {
            /** @type {number} */
            val = Math.round(0 | val);
            /** @type {number} */
            var h = Math.floor(Math.log10
                ? Math.log10(val)
                : Math.log(val) / Math.LN10 + 1E-8);
            /** @type {number} */
            var i = Math.floor(h / 3);
            /** @type {number} */
            var slidesTotal = 100;
            return h > 3 && (h - 3 * i > 0 && (slidesTotal = 10), h - 3 * i > 1 && (slidesTotal = 1), val = Math.floor(val / Math.pow(10, 3 * i) * slidesTotal) / slidesTotal, val = "" + val, val.length < 3 && (!/\./.test(val) && (val += ".0")), val += {
                0: "",
                1: "K",
                2: "M",
                3: "B"
            }[i]),
            "" + val;
        };
    }),
    app.filter("marked", [
        "$sce",
        function($sce) {
            var sprite = new marked.Renderer;
            /**
                 * @param {string} tabCtrl
                 * @param {?} attrs
                 * @param {string} scope
                 * @return {?}
                 */
            sprite.link = function(tabCtrl, attrs, scope) {
                return '<a href="' + tabCtrl + '" target="_blank" onclick="if(window.nw) {nw.Shell.openExternal(this.href); return false;}">' + scope + "</a>";
            };
            var str = _.extend({}, marked.defaults, {
                breaks: true,
                sanitize: true,
                code: true,
                renderer: sprite
            });
            var parser = new marked.Lexer(str);
            var data = new marked.Parser(str);
            return function(text) {
                return text = data.parse(parser.lex(text)),
                $sce.trustAsHtml(text);
            };
        }
    ]),
    app.filter("truncate", function() {
        return function(input, limit) {
            return input.length <= limit
                ? input
                : input.substring(0, limit) + "...";
        };
    }),
    app.filter("elapsedDays", function() {
        /**
             * @param {number} dataAndEvents
             * @return {?}
             */
        function clone(dataAndEvents) {
            return 10 > dataAndEvents
                ? "0" + dataAndEvents
                : dataAndEvents;
        }
        /**
             * @param {string} allBindingsAccessor
             * @return {?}
             */
        var update = function(allBindingsAccessor) {
            /** @type {number} */
            var sectionLength = allBindingsAccessor - Date.now();
            return 0 > sectionLength
                ? null
                : sectionLength > 1728E5
                    ? Math.floor(sectionLength / 24 / 3600 / 1E3) + " days"
                    : clone(Math.floor(sectionLength / 60 / 60 / 1E3)) + ":" + clone(Math.floor(sectionLength / 60 / 1E3) % 60) + ":" + clone(Math.floor(sectionLength / 1E3) % 60);
        };
        return update.$stateful = true,
        update;
    }),
    app.filter("capitalize", function() {
        return function(match) {
            return match.charAt(0).toUpperCase() + match.slice(1);
        };
    }),
    app.directive("appSpectrum", function() {
        return {
            /**
                 * @param {?} scope
                 * @param {?} elm
                 * @param {?} tabCtrl
                 * @return {undefined}
                 */
            link: function(scope, elm, tabCtrl) {
                $(elm).spectrum({preferredFormat: "hex", showInput: true});
                $(elm).on("change.spectrum", function() {
                    return scope.$apply();
                });
            }
        };
    }),
    app.directive("appVisible", [
        "$animate",
        function($animate) {
            return {
                restrict: "A",
                /**
                     * @param {?} scope
                     * @param {?} element
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(scope, element, attrs) {
                    scope.$watch(attrs.appVisible, function(b) {
                        $animate[b
                                ? "removeClass"
                                : "addClass"](element, "invisible");
                    });
                }
            };
        }
    ]),
    app.directive("appAttr", function() {
        return {
            /**
                 * @param {?} $scope
                 * @param {Array} options
                 * @param {?} scope
                 * @return {undefined}
                 */
            link: function($scope, options, scope) {
                var attrs = scope.appAttr.split("#");
                $scope.$watch(attrs[1], function(prevValue) {
                    return options[0].setAttribute(attrs[0], prevValue);
                });
            }
        };
    }),
    angular.module("ngAria", []), {};
}();
var $__app_95_components_47_common_47_badge_47_badge_45_paths__ = function() {
    var amount = angular.module("app.badge.paths", []);
    return amount.value("BadgePaths", {
        1: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 0;
                /** @type {number} */
                var c = 0;
                if (obj1 > 0) {
                    /** @type {number} */
                    b = 30 * obj1 / 100;
                }
                if (0 > obj1) {
                    /** @type {number} */
                    c = 30 * -obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 50 " + (100 - b) + " L " + c + " 50 H " + (100 - c) + " Z";
                /** @type {string} */
                this.path2 = "M " + c + " 50 H " + (100 - c) + " L 50 " + b + " Z";
            }
        },
        2: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 0;
                /** @type {number} */
                var c = 0;
                if (obj1 > 0) {
                    /** @type {number} */
                    b = 30 * obj1 / 100;
                }
                if (0 > obj1) {
                    /** @type {number} */
                    c = 30 * -obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M " + b + " " + c + " L 50 50 L " + (100 - b) + " " + c + " V -1 H -1 Z";
                /** @type {string} */
                this.path2 = "M " + b + " " + (100 - c) + " L 50 50 L " + (100 - b) + " " + (100 - c) + " V 101 H -1 Z";
            }
        },
        3: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var visibleRegionSize = Math.PI / 4 + Math.PI / 4 * (obj1 + 100) / 200;
                /** @type {number} */
                var tth = -Math.PI / 2;
                /** @type {number} */
                var start = Math.PI / 2 + Math.PI / 3;
                /** @type {number} */
                var t = Math.PI / 2 - Math.PI / 3;
                /** @type {string} */
                this.path1 = "M 50 50 L " + (50 + 100 * Math.cos(tth - visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(tth - visibleRegionSize / 2)) + " L " + (50 + 100 * Math.cos(tth + visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(tth + visibleRegionSize / 2)) + " Z";
                /** @type {string} */
                this.path2 = "M 50 50 L " + (50 + 100 * Math.cos(start - visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(start - visibleRegionSize / 2)) + " L " + (50 + 100 * Math.cos(start + visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(start + visibleRegionSize / 2)) + " Z\n                          M 50 50 L " + (50 + 100 * Math.cos(t - visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(t - visibleRegionSize / 2)) + " L " + (50 + 100 * Math.cos(t + visibleRegionSize / 2)) + " " + (50 + 100 * Math.sin(t + visibleRegionSize / 2));
            },
            flip: "rotate180"
        },
        4: {
            /**
             * @param {number} t
             * @return {undefined}
             */
            calc: function(t) {
                t += 100;
                /** @type {number} */
                var b = 50 - 30 * t / 200;
                /** @type {number} */
                var c = 50 + 30 * t / 200;
                /** @type {string} */
                this.path1 = "M 0 " + c + " H 100 V 100 H 0 Z";
                /** @type {string} */
                this.path2 = t > 0
                    ? "M 0 " + b + " H 100 V " + c + " H 0 Z"
                    : "";
            },
            flip: "rotate90"
        },
        5: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                obj1 += 100;
                /** @type {number} */
                var b = 50 - 10 * obj1 / 200 - 10;
                /** @type {number} */
                var c = 50 + 10 * obj1 / 200 + 10;
                /** @type {string} */
                this.path1 = "M " + b + " 0 H " + c + " V 100 H " + b + " Z";
                /** @type {string} */
                this.path2 = "M 0 " + b + " H 100 V " + c + " H 0 Z";
            },
            flip: "rotate45"
        },
        6: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 5 + 8 * (obj1 + 100) / 200;
                /** @type {number} */
                var a = 50;
                /** @type {number} */
                var r = 20;
                /** @type {number} */
                var h = 80;
                /** @type {string} */
                this.path1 = "M " + (a - b) + " 0 H " + (a + b) + " V 100 H " + (a - b);
                /** @type {string} */
                this.path2 = "M " + (r - b) + " 0 H " + (r + b) + " V 100 H " + (r - b) + " Z\n                          M " + (h - b) + " 0 H " + (h + b) + " V 100 H " + (h - b) + " Z";
            },
            flip: "rotate90"
        },
        7: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 20 + 10 * obj1 / 100;
                /** @type {string} */
                this.path1 = "M 0 50 Q 25 30 50 50 T 100 50 V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M 0 " + (50 - b) + " Q 25 " + (30 - b) + " 50 " + (50 - b) + " T 100 " + (50 - b) + "\n                            V " + (50 + b) + " Q 75 " + (70 + b) + " 50 " + (50 + b) + " T 0 " + (50 + b) + " Z";
            },
            flip: "rotate90"
        },
        8: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 20 * obj1 / 100;
                /** @type {string} */
                this.path1 = "M 0 50 H 100 V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M 0 50 Q 50 " + b + " 100 50 Q 50 " + (100 - b) + " 0 50 Z";
            },
            flip: "rotate90"
        },
        9: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var a = 0;
                /** @type {number} */
                var nbsp = 50;
                /** @type {number} */
                var b = 70;
                if (obj1 > 0) {
                    a += obj1 / 100 * 20;
                }
                if (0 > obj1) {
                    nbsp += obj1 / 100 * 30;
                }
                /** @type {string} */
                this.path1 = "M 50 " + a + " L 100 " + (a + b) + " V 101 H 0 V " + (a + b) + " Z";
                /** @type {string} */
                this.path2 = "M 50 " + (a + nbsp) + " L 100 " + (a + nbsp + b) + " V 101 H 0 V " + (a + nbsp + b) + " Z";
            },
            flip: "rotate180"
        },
        10: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 30;
                /** @type {number} */
                var g = 7;
                if (obj1 > 0) {
                    b += 50 * obj1 / 100;
                }
                if (0 > obj1) {
                    g -= 20 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M " + (50 + g + b) + " " + (50 - b) + " A " + b + " " + b + " 0 0 0 " + (50 + g + b) + " " + (50 + b) + " H 101 V " + (50 - b) + " Z";
                /** @type {string} */
                this.path2 = "M " + (50 - g - b) + " " + (50 - b) + " A " + b + " " + b + " 0 0 1 " + (50 - g - b) + " " + (50 + b) + " H -1 V " + (50 - b) + " Z";
            },
            flip: "rotate90"
        },
        11: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 30;
                /** @type {number} */
                var c = 30;
                /** @type {number} */
                var d = 50 - 50 * Math.cos(Math.PI / 4);
                /** @type {number} */
                var e = 50 - 50 * Math.sin(Math.PI / 4);
                if (obj1 > 0) {
                    b += 25 * obj1 / 100;
                    c += 25 * obj1 / 100;
                }
                if (0 > obj1) {
                    c -= 50 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M " + d + " " + e + " Q " + b + " 50 " + d + " " + (100 - e) + " H 0 V " + e + " Z\n                          M " + (100 - d) + " " + e + " Q " + (100 - b) + " 50 " + (100 - d) + " " + (100 - e) + " H 100 V " + e + " Z";
                /** @type {string} */
                this.path2 = "M " + d + " " + e + " Q 50 " + c + " " + (100 - d) + " " + e + " V 0 H " + d + " Z\n                          M " + d + " " + (100 - e) + " Q 50 " + (100 - c) + " " + (100 - d) + " " + (100 - e) + " V 100 H " + d + " Z";
            },
            flip: "rotate90"
        },
        12: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 30;
                /** @type {number} */
                var c = 35;
                if (obj1 > 0) {
                    b += 30 * obj1 / 100;
                }
                if (0 > obj1) {
                    c += 15 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 0 " + b + " H 100 V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M 0 " + b + " H " + c + " V 100 H 0 Z\n                          M 100 " + b + " H " + (100 - c) + " V 100 H 100 Z";
            },
            flip: "rotate180"
        },
        13: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var right = 30;
                /** @type {number} */
                var left = 0;
                if (obj1 > 0) {
                    right += 50 * obj1 / 100;
                }
                if (0 > obj1) {
                    left -= 20 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 0 0 H 50 V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M " + (50 - right) + " " + (50 - left - right) + " A " + right + " " + right + " 0 0 0 " + (50 + right) + " " + (50 - right - left) + " V 0 H " + (50 - right) + " Z";
            },
            flip: "rotate180"
        },
        14: {
            /**
             * @param {number} value
             * @return {undefined}
             */
            calc: function(value) {
                /** @type {number} */
                var theta2 = Math.PI / 4;
                /** @type {number} */
                var c = 0;
                theta2 += value * Math.PI / 4 / 100;
                /** @type {string} */
                this.path1 = "M 50 0 Q 50 " + (50 + c) + " " + (50 + 50 * Math.cos(theta2)) + " " + (50 + 50 * Math.sin(theta2)) + " H 100 V 0 H 50 Z";
                /** @type {string} */
                this.path2 = "M 50 0 Q 50 " + (50 + c) + " " + (50 - 50 * Math.cos(theta2)) + " " + (50 + 50 * Math.sin(theta2)) + " H 0 V 0 H 50 Z";
            },
            flip: "rotate180"
        },
        15: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 13 + 6 * obj1 / 100;
                /** @type {number} */
                var a = 80;
                /** @type {number} */
                var g = 45;
                /** @type {number} */
                var e = 10;
                /** @type {string} */
                this.path1 = "M " + (50 - a - b) + " " + (100 + e) + " A " + (a + b) + " " + (a + b) + " 0 0 1 " + (50 + a + b) + " " + (100 + e) + "\n                                   H " + (50 + a - b) + " A " + (a - b) + " " + (a - b) + " 0 1 0 " + (50 - a + b) + " " + (100 + e);
                /** @type {string} */
                this.path2 = "M " + (50 - g - b) + " " + (100 + e) + " A " + (g + b) + " " + (g + b) + " 0 0 1 " + (50 + g + b) + " " + (100 + e) + "\n                                   H " + (50 + g - b) + " A " + (g - b) + " " + (g - b) + " 0 1 0 " + (50 - g + b) + " " + (100 + e);
            },
            flip: "rotate180"
        },
        16: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 30 * Math.PI / 180;
                /** @type {number} */
                var donut = 25;
                if (obj1 > 0) {
                    b += 30 * Math.PI / 180 * obj1 / 100;
                }
                if (0 > obj1) {
                    donut += 25 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "";
                /** @type {number} */
                var angleDegrees = 0;
                for (; 3 > angleDegrees; angleDegrees++) {
                    /** @type {number} */
                    var theta2 = angleDegrees * Math.PI * 2 / 3 + b / 2 - Math.PI / 2;
                    /** @type {number} */
                    var halfTotalAngle = angleDegrees * Math.PI * 2 / 3 - b / 2 - Math.PI / 2;
                    this.path1 += "M " + (50 + 100 * Math.cos(theta2)) + " " + (50 + 100 * Math.sin(theta2)) + "\n                               L " + (50 + 100 * Math.cos(halfTotalAngle)) + " " + (50 + 100 * Math.sin(halfTotalAngle)) + "\n                               L " + (50 + donut * Math.cos(halfTotalAngle)) + " " + (50 + donut * Math.sin(halfTotalAngle)) + "\n                               A " + donut + " " + donut + " 0 0 1 " + (50 + donut * Math.cos(theta2)) + " " + (50 + donut * Math.sin(theta2)) + " Z";
                }
                /** @type {string} */
                this.path2 = "";
                /** @type {number} */
                angleDegrees = 0;
                for (; 3 > angleDegrees; angleDegrees++) {
                    /** @type {number} */
                    theta2 = angleDegrees * Math.PI * 2 / 3 + b / 2 + Math.PI / 2;
                    /** @type {number} */
                    halfTotalAngle = angleDegrees * Math.PI * 2 / 3 - b / 2 + Math.PI / 2;
                    this.path2 += "M " + (50 + 100 * Math.cos(theta2)) + " " + (50 + 100 * Math.sin(theta2)) + "\n                               L " + (50 + 100 * Math.cos(halfTotalAngle)) + " " + (50 + 100 * Math.sin(halfTotalAngle)) + "\n                               L " + (50 + donut * Math.cos(halfTotalAngle)) + " " + (50 + donut * Math.sin(halfTotalAngle)) + "\n                               A " + donut + " " + donut + " 0 0 1 " + (50 + donut * Math.cos(theta2)) + " " + (50 + donut * Math.sin(theta2)) + " Z";
                }
            }
        },
        17: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 35;
                /** @type {number} */
                var c = 45;
                if (obj1 > 0) {
                    b += 20 * obj1 / 100;
                }
                if (0 > obj1) {
                    c -= 30 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 50 45 L " + (50 - b) + " " + (c + 45) + " H " + (50 + b) + " Z";
                /** @type {string} */
                this.path2 = "M 50 0 L " + (50 - b) + " " + c + " H " + (50 + b) + " Z";
            }
        },
        18: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var swidth = 90 * Math.PI / 180;
                /** @type {number} */
                var c = 10;
                if (obj1 > 0) {
                    swidth -= 60 / 180 * Math.PI * obj1 / 100;
                }
                if (0 > obj1) {
                    c -= 15 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "";
                /** @type {string} */
                this.path2 = "";
                /** @type {number} */
                var width = 0;
                for (; 3 > width; width++) {
                    /** @type {number} */
                    var theta2 = 2 * Math.PI / 3 * width + swidth / 2 - Math.PI / 2;
                    /** @type {number} */
                    var halfTotalAngle = 2 * Math.PI / 3 * width - swidth / 2 - Math.PI / 2;
                    /** @type {string} */
                    var path1 = "M " + (50 + 100 * Math.cos(theta2)) + " " + (50 + 100 * Math.sin(theta2)) + "\n                            L " + (50 + 100 * Math.cos(halfTotalAngle)) + " " + (50 + 100 * Math.sin(halfTotalAngle)) + "\n                            L " + (50 + c * Math.cos((theta2 + halfTotalAngle) / 2)) + " " + (50 + c * Math.sin((theta2 + halfTotalAngle) / 2)) + " Z";
                    if (width) {
                        this.path2 += path1;
                    } else {
                        this.path1 += path1;
                    }
                }
            },
            flip: "rotate180"
        },
        19: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 20;
                /** @type {number} */
                var c = 60;
                c += 20 * obj1 / 100;
                b += 20 * obj1 / 100;
                /** @type {string} */
                this.path1 = "M 50 -10 L " + (50 - c) + " 100 H " + (50 + c) + " Z";
                /** @type {string} */
                this.path2 = "";
                if (b > 0) {
                    /** @type {string} */
                    this.path2 = "M 50 0 L " + (50 - b) + " 100 H " + (50 + b) + " Z";
                }
            },
            flip: "rotate180"
        },
        20: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 10;
                /** @type {number} */
                var c = 20;
                if (obj1 > 0) {
                    b += 20 * obj1 / 100;
                }
                if (0 > obj1) {
                    c += 40 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 0 " + (50 - c) + " H " + (50 - b) + " V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M " + (50 + b) + " 0 V " + (50 + c) + " H 100 V 0 Z";
            },
            flip: "rotate90"
        },
        21: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 40;
                /** @type {number} */
                var c = 50;
                if (obj1 > 0) {
                    b -= 20 * obj1 / 100;
                }
                if (0 > obj1) {
                    c += 20 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 50 " + c + " Q " + (50 + b) + " 0 50 0 T 50 " + c + " Z\n                          M 50 " + (100 - c) + " Q " + (50 + b) + " 100 50 100 T 50 " + (100 - c) + " Z";
                /** @type {string} */
                this.path2 = "M " + c + " 50 Q 0 " + (50 + b) + " 0 50 T " + c + " 50 Z\n                          M " + (100 - c) + " 50 Q 100 " + (50 + b) + " 100 50 T " + (100 - c) + " 50 Z";
            },
            flip: "rotate45"
        },
        22: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var k = 20;
                k += 10 * obj1 / 100;
                /** @type {string} */
                this.path1 = "M " + (50 - k) + " " + (50 - k) + " H " + (50 + k) + " V " + (50 + k) + " H " + (50 - k) + " Z";
                /** @type {string} */
                this.path2 = "";
                /** @type {number} */
                var t = -4;
                for (; 4 > t; t++) {
                    /** @type {number} */
                    var a = -4;
                    for (; 4 > a; a++) {
                        /** @type {number} */
                        var b = (t + a) % 2;
                        this.path2 += "M " + (50 - k - 2 * k * t) + " " + (50 - k - 2 * k * (a + b)) + " h " + 2 * -k + " v " + 2 * k + " h " + 2 * k + " Z";
                    }
                }
            },
            flip: "rotate45"
        },
        23: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var a1 = 17;
                /** @type {number} */
                var c = 25;
                if (obj1 > 0) {
                    a1 += 35 * obj1 / 100;
                }
                if (0 > obj1) {
                    c -= 23 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "";
                /** @type {number} */
                var b4 = -4;
                for (; 4 >= b4; b4++) {
                    this.path1 += "M " + (50 - a1 * b4 * 2) + " " + (50 - c) + " l " + -a1 + " " + -c + " l " + -a1 + " " + c + " l " + a1 + " " + c + " Z";
                }
                /** @type {string} */
                this.path2 = "";
                /** @type {number} */
                b4 = -4;
                for (; 4 >= b4; b4++) {
                    this.path2 += "M " + (50 - a1 * b4 * 2) + " " + (50 + c) + " l " + -a1 + " " + -c + " l " + -a1 + " " + c + " l " + a1 + " " + c + " Z";
                }
            },
            flip: "rotate90"
        },
        24: {
            /**
             * @param {number} obj1
             * @return {undefined}
             */
            calc: function(obj1) {
                /** @type {number} */
                var b = 50;
                /** @type {number} */
                var c = 45;
                if (obj1 > 0) {
                    b += 60 * obj1 / 100;
                }
                if (0 > obj1) {
                    c += 30 * obj1 / 100;
                }
                /** @type {string} */
                this.path1 = "M 0 " + c + " L 50 70 L 100 " + c + " V 100 H 0 Z";
                /** @type {string} */
                this.path2 = "M 50 0 L " + (50 + b) + " 100 H 100 V " + c + " L 50 70 L 0 " + c + " V 100 H " + (50 - b) + " Z";
            },
            flip: "rotate180"
        }
    }), {};
}();
var $__app_95_components_47_common_47_badge_47_badge__ = function() {
    /**
     * @param {string} val
     * @param {string} type
     * @param {Function} text
     * @return {undefined}
     */
    function output(val, type, text) {
        if ("string" != typeof val) {
            throw new Error("Invalid argument: dataURI must be a string");
        }
        /** @type {Array.<string>} */
        val = val.split(",");
        type = type || val[0].split(":")[1].split(";")[0];
        var binary = atob(val[1]);
        var l = binary.length;
        /** @type {ArrayBuffer} */
        var res = new ArrayBuffer(l);
        /** @type {Uint8Array} */
        var data = new Uint8Array(res);
        /** @type {number} */
        var i = 0;
        for (; l > i; i++) {
            data[i] = binary.charCodeAt(i);
        }
        /** @type {Blob} */
        var passes = new Blob([data], {type: type});
        text(passes);
    }
    /**
     * @param {number} g
     * @param {number} outstandingDataSize
     * @param {number} opt_attributes
     * @return {?}
     */
    function toHex(g, outstandingDataSize, opt_attributes) {
        /**
         * @param {?} x
         * @return {?}
         */
        function hex(x) {
            /** @type {string} */
            var closeTag = Number(x).toString(16);
            return closeTag.length < 2 && (closeTag = "0" + closeTag),
            closeTag;
        }
        var f;
        var max;
        var min;
        /** @type {number} */
        var i = (1 - window.Math.abs(2 * opt_attributes - 1)) * outstandingDataSize;
        /** @type {number} */
        var normG = g / 60;
        /** @type {number} */
        var d = i * (1 - window.Math.abs(normG % 2 - 1));
        if (void 0 === g || (isNaN(g) || null === g)) {
            /** @type {number} */
            f = max = min = 0;
        } else {
            if (normG >= 0 && 1 > normG) {
                /** @type {number} */
                f = i;
                /** @type {number} */
                max = d;
                /** @type {number} */
                min = 0;
            } else {
                if (normG >= 1 && 2 > normG) {
                    /** @type {number} */
                    f = d;
                    /** @type {number} */
                    max = i;
                    /** @type {number} */
                    min = 0;
                } else {
                    if (normG >= 2 && 3 > normG) {
                        /** @type {number} */
                        f = 0;
                        /** @type {number} */
                        max = i;
                        /** @type {number} */
                        min = d;
                    } else {
                        if (normG >= 3 && 4 > normG) {
                            /** @type {number} */
                            f = 0;
                            /** @type {number} */
                            max = d;
                            /** @type {number} */
                            min = i;
                        } else {
                            if (normG >= 4 && 5 > normG) {
                                /** @type {number} */
                                f = d;
                                /** @type {number} */
                                max = 0;
                                /** @type {number} */
                                min = i;
                            } else {
                                if (normG >= 5) {
                                    if (6 > normG) {
                                        /** @type {number} */
                                        f = i;
                                        /** @type {number} */
                                        max = 0;
                                        /** @type {number} */
                                        min = d;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        var a;
        var b;
        var blue;
        /** @type {number} */
        var px = opt_attributes - i / 2;
        return a = 255 * (f + px),
        b = 255 * (max + px),
        blue = 255 * (min + px),
        a = Math.round(a),
        b = Math.round(b),
        blue = Math.round(blue),
        hex(a) + hex(b) + hex(blue);
    }
    /**
     * @param {string} attr
     * @return {?}
     */
    function compile(attr) {
        return ngInject([
            "BadgeGenerator",
            function(d) {
                return {
                    /**
                     * @param {?} scope
                     * @param {HTMLElement} elem
                     * @param {Object} attrs
                     * @return {undefined}
                     */
                    link: function(scope, elem, attrs) {
                        /** @type {number} */
                        var computed = 0;
                        /**
                         * @return {?}
                         */
                        var update = function() {
                            if (!elem.attr(attr)) {
                                elem.attr(attr, d.emptyDataUrl);
                            }
                            /** @type {number} */
                            var current = (new Date).getTime();
                            var x = scope.$eval(attrs[attrs.$normalize("app:badge-" + attr)]);
                            var c = elem.width();
                            var data = elem.height();
                            if (elem[0].getBoundingClientRect) {
                                var bb = elem[0].getBoundingClientRect();
                                /** @type {number} */
                                c = Math.round(bb.width);
                                /** @type {number} */
                                data = Math.round(bb.height);
                                if (20 > c) {
                                    /** @type {number} */
                                    c = 20;
                                    /** @type {number} */
                                    data = 20;
                                }
                            }
                            return d.getImageData(x, c, data).then(function(name) {
                                if (current > computed) {
                                    elem.attr(attr, name);
                                    /** @type {number} */
                                    computed = current;
                                }
                            });
                        };
                        var src = scope.$eval(attrs[attrs.$normalize("app:badge-" + attr)]);
                        if ("noAutoWatch" in attrs || !(src && src._watching || "src" == attr)) {
                            update();
                        } else {
                            scope.$watch(_.throttle(update, "src" == attr
                                ? 100
                                : 1E3));
                        }
                        if ("watchChange" in attrs) {
                            scope.$watch(function() {
                                return scope.$eval(attrs[attrs.$normalize("app:badge-" + attr)]);
                            }, function(dataAndEvents) {
                                elem.attr(attr, d.emptyDataUrl);
                                update();
                            });
                        }
                        scope.$on("resize", update);
                    }
                };
            }
        ]);
    }
    var module = angular.module("app.badge", []);
    return HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
        /**
             * @param {string} name
             * @param {?} expectedNumberOfNonCommentArgs
             * @param {?} newValue
             * @return {undefined}
             */
        value: function(name, expectedNumberOfNonCommentArgs, newValue) {
            output(this.toDataURL(expectedNumberOfNonCommentArgs, newValue), expectedNumberOfNonCommentArgs, name);
        }
    }),
    module.factory("BadgeGenerator", [
        "$cacheFactory",
        "$rootScope",
        "BadgePaths",
        "$q",
        function(getQuery, dataAndEvents, entities, promise) {
            /**
                 * @param {Object} props
                 * @param {number} len
                 * @param {number} attr
                 * @return {?}
                 */
            function get(props, len, attr) {
                return "key_" + props.type + "_" + (props.flip
                    ? "1"
                    : "0") + "_" + props.color1 + "_" + props.color2 + "_" + props.color3 + "_" + (props.param || 0) + "_" + len + "_" + attr;
            }
            /**
                 * @param {Object} props
                 * @param {number} w
                 * @param {number} h
                 * @return {?}
                 */
            function load(props, w, h) {
                return promise(function(callback, dataAndEvents) {
                    if (!props) {
                        return void callback(options.emptyDataUrl);
                    }
                    /** @type {Element} */
                    var buffer = document.createElement("canvas");
                    var i = _.isString(props.color1)
                        ? props.color1
                        : errors[props.color1].rgb;
                    var j = _.isString(props.color2)
                        ? props.color2
                        : errors[props.color2].rgb;
                    var l = _.isString(props.color3)
                        ? props.color3
                        : errors[props.color3].rgb;
                    /** @type {number} */
                    w = Math.round(w);
                    /** @type {number} */
                    h = Math.round(h);
                    if (props.param > 100) {
                        /** @type {number} */
                        props.param = 100;
                    }
                    if (props.param < -100) {
                        /** @type {number} */
                        props.param = -100;
                    }
                    /** @type {number} */
                    buffer.width = w;
                    /** @type {number} */
                    buffer.height = h;
                    if (_.isNumber(props.type)) {
                        entities[props.type].calc(props.param);
                    }
                    /** @type {number} */
                    var n = 0;
                    if (props.flip) {
                        if (_.isNumber(props.type)) {
                            if ("rotate180" == entities[props.type].flip) {
                                /** @type {number} */
                                n = 180;
                            }
                            if ("rotate90" == entities[props.type].flip) {
                                /** @type {number} */
                                n = 90;
                            }
                            if ("rotate45" == entities[props.type].flip) {
                                /** @type {number} */
                                n = 45;
                            }
                        }
                    }
                    var path1;
                    var $q;
                    /** @type {string} */
                    var text = '<svg xmlns="http://www.w3.org/2000/svg" width="' + w + '" height="' + h + '" viewBox="0 0 100 100" shape-rendering="geometricPrecision">\n                            <defs>\n                                <clipPath id="clip">\n                                    <circle cx="50" cy="50" r="52" />\n                                    \x3c!--<rect x="0" y="0" width="100" height="100"/>--\x3e\n                                </clipPath>\n                            </defs>\n                            <g transform="rotate(' + n + ' 50 50)">\n                            <rect x="0" y="0" width="100" height="100" fill="' + i + '" clip-path="url(#clip)"/>';
                    if (_.isNumber(props.type)) {
                        path1 = entities[props.type].path1;
                        $q = entities[props.type].path2;
                    } else {
                        path1 = props.type.path1;
                        $q = props.type.path2;
                    }
                    text += '<path d="' + path1 + '" fill="' + j + '" clip-path="url(#clip)"/>';
                    if ($q) {
                        text += '<path d="' + $q + '" fill="' + l + '" clip-path="url(#clip)"/>';
                    }
                    text += "</g></svg>";
                    var ctx = buffer.getContext("2d");
                    /** @type {Image} */
                    var img = new Image;
                    /** @type {Blob} */
                    var uuidBlob = new Blob([text], {type: "image/svg+xml"});
                    /** @type {string} */
                    var url = URL.createObjectURL(uuidBlob);
                    /**
                         * @return {undefined}
                         */
                    img.onload = function() {
                        dataAndEvents.apply(function() {
                            img.width = w;
                            img.height = h;
                            ctx.clearRect(0, 0, w, h);
                            ctx.drawImage(img, 0, 0);
                            URL.revokeObjectURL(url);
                            buffer.toBlob(function(blob) {
                                /** @type {null} */
                                buffer = null;
                                /** @type {null} */
                                img = null;
                                /** @type {null} */
                                uuidBlob = null;
                                /** @type {null} */
                                ctx = null;
                                callback(URL.createObjectURL(blob));
                            });
                        });
                    };
                    /** @type {string} */
                    img.src = url;
                });
            }
            var q = getQuery("badges", {capacity: 1E3});
            var revokeObjectURL = {};
            /** @type {DOMURL} */
            var URL = window.URL || (window.webkitURL || window);
            /** @type {function (?): undefined} */
            var l = q.remove;
            /**
                 * @param {?} keepData
                 * @return {undefined}
                 */
            q.remove = function(keepData) {
                URL.revokeObjectURL(revokeObjectURL[keepData]);
                l.call(this, keepData);
            };
            /** @type {Array} */
            var errors = [];
            /** @type {number} */
            var portionIndex = 0;
            errors.push({
                index: portionIndex++,
                rgb: "#" + toHex(0, 0, 0.8)
            });
            /** @type {number} */
            var o = 0;
            for (; 19 > o; o++) {
                errors.push({
                    index: portionIndex++,
                    rgb: "#" + toHex(360 * o / 19, 0.6, 0.8)
                });
            }
            errors.push({
                index: portionIndex++,
                rgb: "#" + toHex(0, 0, 0.5)
            });
            /** @type {number} */
            o = 0;
            for (; 19 > o; o++) {
                errors.push({
                    index: portionIndex++,
                    rgb: "#" + toHex(360 * o / 19, 0.7, 0.5)
                });
            }
            errors.push({
                index: portionIndex++,
                rgb: "#" + toHex(0, 0, 0.3)
            });
            /** @type {number} */
            o = 0;
            for (; 19 > o; o++) {
                errors.push({
                    index: portionIndex++,
                    rgb: "#" + toHex(360 * o / 19, 0.4, 0.3)
                });
            }
            errors.push({
                index: portionIndex++,
                rgb: "#" + toHex(0, 0, 0.1)
            });
            /** @type {number} */
            o = 0;
            for (; 19 > o; o++) {
                errors.push({
                    index: portionIndex++,
                    rgb: "#" + toHex(360 * o / 19, 0.5, 0.1)
                });
            }
            var options = {
                /**
                     * @param {Object} key
                     * @param {number} width
                     * @param {number} y
                     * @return {?}
                     */
                getImageData: function(key, width, y) {
                    if (!key) {
                        return promise.when(options.emptyDataUrl);
                    }
                    var camelKey = get(key, width, y);
                    var value = q.get(camelKey);
                    return value || (value = load(key, width, y), q.put(camelKey, value)),
                    value;
                },
                /**
                     * @param {Object} key
                     * @param {number} width
                     * @param {number} protoProps
                     * @return {?}
                     */
                getImageDataFromCache: function(key, width, protoProps) {
                    var camelKey = get(key, width, protoProps);
                    return q.get(camelKey);
                },
                colors: errors
            };
            return output("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2NkAAIAAAoAAggA9GkAAAAASUVORK5CYII=", "image/png", function(value) {
                /** @type {string} */
                options.emptyDataUrl = URL.createObjectURL(value);
            }),
            options;
        }
    ]),
    module.directive("appBadgeSrc", compile("src")),
    module.directive("appBadgeXlinkHref", compile("xlink:href")), {};
}();
var $__app_95_components_47_common_47_dialogs_47_dialogs__ = function() {
    var $provide = angular.module("app.dialogs", ["ui.modal"]);
    return $provide.factory("Dialogs", [
        "$modal",
        "$injector",
        "$q",
        function($modal, r, $q) {
            var self = {};
            return self.ask = function(opt_attributes, message, callback) {
                if (_.isObject(opt_attributes)) {
                    var options = opt_attributes;
                    opt_attributes = options.title;
                    message = options.message;
                    callback = options.callback;
                    var buttonLabel = options.buttonLabel;
                    var data = options.buttonClass;
                    var label = options.buttonCancelLabel;
                    var error = options.buttonOptionalLabel;
                }
                return $modal.open({
                    templateUrl: "components/common/dialogs/dlg-ask.html?bust=1479290327467",
                    controller: [
                        "$scope",
                        "$modalInstance",
                        function($scope, $modalInstance) {
                            $scope.title = opt_attributes;
                            $scope.message = message;
                            $scope.buttonLabel = buttonLabel || "OK";
                            $scope.buttonClass = data || "md-primary";
                            $scope.buttonCancelLabel = label || "Cancel";
                            $scope.buttonOptionalLabel = error;
                            /**
                                 * @param {string} reason
                                 * @return {undefined}
                                 */
                            $scope.cancel = function(reason) {
                                $modalInstance.dismiss(reason);
                            };
                            /**
                                 * @param {?} result
                                 * @return {?}
                                 */
                            $scope.ok = function(result) {
                                return callback
                                    ? callback().then(function() {
                                        $modalInstance.close(result);
                                    })
                                    : ($modalInstance.close(result), $q.when());
                            };
                        }
                    ]
                });
            },
            self.alert = function(val, opt_attributes) {
                return $modal.open({
                    templateUrl: "components/common/dialogs/dlg-alert.html?bust=1479290327467",
                    controller: [
                        "$scope",
                        "$modalInstance",
                        function($scope, $modalInstance) {
                            /** @type {string} */
                            $scope.title = val;
                            /** @type {string} */
                            $scope.message = opt_attributes;
                            /**
                                 * @param {string} reason
                                 * @return {undefined}
                                 */
                            $scope.cancel = function(reason) {
                                $modalInstance.dismiss(reason);
                            };
                        }
                    ]
                }).result;
            },
            self.askForName = function(name, node) {
                return r.get("Connection").genUniqueNameForType(name, node).then(function(errorName) {
                    return $modal.open({
                        templateUrl: "components/common/dialogs/dlg-name.html?bust=1479290327467",
                        controller: [
                            "$scope",
                            "$modalInstance",
                            "data",
                            function(dataAndEvents, db, _arg) {
                                var info = this;
                                this.name = _arg.name;
                                /**
                                     * @return {undefined}
                                     */
                                this.submit = function() {
                                    db.close(info.name);
                                };
                                this.nameValidators = {
                                    /**
                                         * @param {string} isSorted
                                         * @return {?}
                                         */
                                    unique: function(isSorted) {
                                        return r.get("Connection").checkUniqueNameForType(isSorted, name, node);
                                    }
                                };
                            }
                        ],
                        controllerAs: "DlgName",
                        resolve: {
                            /**
                                 * @return {?}
                                 */
                            data: function() {
                                return new Object({name: errorName});
                            }
                        }
                    }).result;
                });
            },
            self.askForSelect = function(args) {
                return $modal.open({
                    templateUrl: "components/common/dialogs/dlg-select.html?bust=1479290327467",
                    controller: [
                        "$scope",
                        "$modalInstance",
                        function(dataAndEvents, db) {
                            var self = this;
                            this.title = args.title || "Select";
                            this.label = args.label;
                            this.value = args.value;
                            this.options = args.options;
                            this.note = args.note;
                            /**
                                 * @return {?}
                                 */
                            this.submit = function() {
                                return args.callback
                                    ? args.callback(self.value).then(function() {
                                        db.close(self.value);
                                    })
                                    : (db.close(self.value), $q.when());
                            };
                        }
                    ],
                    controllerAs: "DlgSelect",
                    windowClass: "dlg-select-window"
                }).result;
            },
            self.Ctrl = ngInject([
                "$scope",
                "$modalInstance",
                function(item, $modalInstance) {
                    /**
                         * @return {undefined}
                         */
                    item.cancel = function() {
                        $modalInstance.dismiss();
                    };
                    /**
                         * @param {?} result
                         * @return {undefined}
                         */
                    item.ok = function(result) {
                        $modalInstance.close(result);
                    };
                }
            ]),
            self;
        }
    ]), {};
}();
var $__app_95_components_47_common_47_dlg_45_server_45_message_47_dlg_45_server_45_message__ = function() {
    var $routeProvider = angular.module("app.dlg-server-message", []);
    return $routeProvider.component("appDlgServerMessage", {
        templateUrl: "components/common/dlg-server-message/dlg-server-message.html?bust=1479290327467",
        controller: ngInject([
            "$scope",
            "Socket",
            function(next_scope, next_callback) {
                var that = this;
                /** @type {null} */
                this.message = null;
                /**
                 * @return {undefined}
                 */
                this.onClose = function() {
                    /** @type {null} */
                    that.message = null;
                };
                next_callback.bindEventToScope(next_scope, "server-message", function(msg) {
                    /** @type {string} */
                    that.message = msg;
                });
            }
        ])
    }), {};
}();
var $__app_95_components_47_common_47_dlg_45_version_45_updated_47_dlg_45_version_45_updated__ = function() {
    var $routeProvider = angular.module("app.dlg-version-updated", []);
    return $routeProvider.component("appDlgVersionUpdated", {
        templateUrl: "components/common/dlg-version-updated/dlg-version-updated.html?bust=1479290327467",
        controller: ngInject([
            "Socket",
            "NwManifest",
            function(b, a) {
                var callback = this;
                /** @type {boolean} */
                this.closed = false;
                /**
                 * @return {?}
                 */
                this.isNw = function() {
                    return !!window.nw;
                };
                /**
                 * @return {?}
                 */
                this.isVisible = function() {
                    return !callback.closed && ((!window.nw || b.newPackageDownloaded) && a.packageVersion < b.packageVersion);
                };
                /**
                 * @return {undefined}
                 */
                this.onReload = function() {
                    window.location.reload(true);
                };
                /**
                 * @return {undefined}
                 */
                this.onClose = function() {
                    /** @type {boolean} */
                    callback.closed = true;
                };
            }
        ])
    }), {};
}();
var $__app_95_components_47_common_47_loader_47_loader__ = function() {
    var hmTouchEvents = angular.module("app.loader", []).factory("Loader", [
        "$q",
        "$interval",
        function(Promise, makeIterator) {
            var descriptor = {};
            /** @type {Array} */
            var nodeArgs = [];
            return descriptor.loadingCnt = 0,
            descriptor.factory = function(module) {
                var method;
                var $scope = {};
                var slide = {};
                return $scope.load = function() {
                    /** @type {string} */
                    $scope.status = "loading";
                    descriptor.loadingCnt++;
                    /** @type {Arguments} */
                    var args = arguments;
                    return method = Promise.all(nodeArgs).then(function() {
                        var ret = module.apply($scope, args);
                        return ret.then
                            ? ret
                            : Promise.all(ret);
                    }).then(function(newValue) {
                        if (!angular.isObject(newValue) || angular.isArray(newValue)) {
                            throw new Error("loadCallback resolves into non-object");
                        }
                        return angular.extend(slide, newValue),
                        slide;
                    }),
                    method["finally"](function() {
                        descriptor.loadingCnt--;
                        /** @type {string} */
                        $scope.status = "ready";
                    }),
                    method;
                },
                $scope.getPromise = function() {
                    return method
                        ? method
                        : $scope.load();
                },
                $scope.reset = function() {
                    /** @type {null} */
                    method = null;
                },
                $scope.status = "await",
                $scope;
            },
            descriptor.registerPre = function(spaceName) {
                nodeArgs.push(spaceName);
            },
            descriptor.slowDownArray = function(j, v, threshold, thisObj, chunkSize) {
                return function(item) {
                    var data = item[j];
                    return chunkSize = chunkSize || 1,
                    data.length && (item[j] = data.splice(0, v), data.length && setTimeout(function() {
                        makeIterator(function() {
                            var codeSegments = data.splice(0, chunkSize);
                            /** @type {number} */
                            var i = 0;
                            for (; i < codeSegments.length; i++) {
                                item[j].push(codeSegments[i]);
                            }
                        }, thisObj, Math.ceil(data.length / chunkSize));
                    }, threshold)),
                    item;
                };
            },
            descriptor.loading = function(context) {
                return descriptor.loadingCnt++,
                context["finally"](function() {
                    descriptor.loadingCnt--;
                });
            },
            descriptor;
        }
    ]);
    return hmTouchEvents.directive("appLoading", [
        "Loader",
        "$window",
        function(Loader, $window) {
            return {
                controller: [
                    "$scope",
                    function(require) {
                        require.Loader = Loader;
                    }
                ],
                /**
                 * @param {?} tabCtrl
                 * @param {HTMLElement} $el
                 * @return {undefined}
                 */
                link: function(tabCtrl, $el) {
                    $window.addEventListener("scroll", function(dataAndEvents) {
                        $el.toggleClass("fixed", $($window).scrollTop() > $("#head").offset().top);
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_common_47_profile_45_stats_47_profile_45_stats__ = function() {
    var ngModule = angular.module("app.profile-stats", []);
    return ngModule.directive("appProfileStats", function() {
        return {
            templateUrl: "components/common/profile-stats/profile-stats.html?bust=1479290327467",
            controller: "ProfileStats as ProfileStats",
            scope: true,
            bindToController: {
                stats: "=",
                normalize: "="
            }
        };
    }),
    ngModule.controller("ProfileStats", ["$scope", function(dataAndEvents) {}]), {};
}();
var $__app_95_components_47_common_47_punchcard_47_punchcard__ = function() {
    var extendCustomValidations = angular.module("app.punchcard", []);
    return extendCustomValidations.directive("appPunchCard", function() {
        return {
            templateUrl: "components/common/punchcard/punchcard.html?bust=1479290327467",
            controllerAs: "PunchCard",
            bindToController: true,
            scope: {
                data: "=",
                label: "=",
                max: "=",
                interval: "="
            },
            controller: [
                "$scope",
                function(dataAndEvents) {
                    var options = this;
                    /**
                     * @param {?} max
                     * @return {?}
                     */
                    this.getRadius = function(max) {
                        return Math.sqrt(Math.min(max, options.max) / options.max * 7853 / Math.PI);
                    };
                    /**
                     * @param {number} isNumber
                     * @return {?}
                     */
                    this.getDate = function(isNumber) {
                        return new Date(60 * isNumber * 1E3 * options.interval);
                    };
                }
            ]
        };
    }), {};
}();
var $__app_95_components_47_common_47_recaptcha_47_recaptcha__ = function() {
    var app = angular.module("app.recaptcha", []);
    return app.factory("Recaptcha", function() {
        var response = {
            loaded: false
        };
        return response;
    }),
    app.directive("appRecaptcha", [
        "Recaptcha",
        "$parse",
        function(element, $timeout) {
            return {
                /**
                     * @param {?} scope
                     * @param {Array} element
                     * @param {?} $scope
                     * @return {undefined}
                     */
                link: function(scope, element, $scope) {
                    scope.$watch(function() {
                        return element.loaded;
                    }, function(dataAndEvents) {
                        if (dataAndEvents) {
                            grecaptcha.render(element[0], {
                                sitekey: "6LcjCBMTAAAAAEu0ytR0uydHQtTmLJ9bNQYcPFuj",
                                theme: "dark",
                                /**
                                     * @param {?} user
                                     * @return {undefined}
                                     */
                                callback: function(user) {
                                    scope.$apply(function() {
                                        $timeout($scope.appRecaptcha).assign(scope, user);
                                    });
                                }
                            });
                        }
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_common_47_ui_47_bootstrap_47_tabs_47_tabs__ = function() {
    return angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [
        "$scope",
        function(data) {
            var ctrl = this;
            /** @type {Array} */
            var tabs = ctrl.tabs = data.tabs = [];
            /**
             * @param {Object} tab
             * @return {undefined}
             */
            ctrl.select = function(tab) {
                angular.forEach(tabs, function(settings) {
                    if (settings.active) {
                        if (settings !== tab) {
                            /** @type {boolean} */
                            settings.active = false;
                            settings.onDeselect();
                        }
                    }
                });
                /** @type {boolean} */
                tab.active = true;
                tab.onSelect();
                data.selectedName = tab.name;
            };
            /**
             * @param {?} deepDataAndEvents
             * @return {undefined}
             */
            ctrl.selectByName = function(deepDataAndEvents) {
                angular.forEach(tabs, function(tab) {
                    if (!(tab.name != deepDataAndEvents)) {
                        if (!tab.active) {
                            ctrl.select(tab);
                        }
                    }
                });
            };
            /**
             * @param {Object} tab
             * @return {undefined}
             */
            ctrl.addTab = function(tab) {
                tabs.push(tab);
                if (1 === tabs.length) {
                    if (!data.selectedName) {
                        /** @type {boolean} */
                        tab.active = true;
                    }
                } else {
                    if (tab.active) {
                        ctrl.select(tab);
                    }
                }
            };
            /**
             * @param {Object} tab
             * @return {undefined}
             */
            ctrl.removeTab = function(tab) {
                /** @type {number} */
                var index = tabs.indexOf(tab);
                if (tab.active && tabs.length > 1) {
                    /** @type {number} */
                    var newActiveIndex = index == tabs.length - 1
                        ? index - 1
                        : index + 1;
                    ctrl.select(tabs[newActiveIndex]);
                }
                tabs.splice(index, 1);
            };
        }
    ]).directive("tabset", [
        "$timeout",
        function($transition) {
            return {
                restrict: "EA",
                transclude: true,
                replace: true,
                scope: {
                    type: "@",
                    selectedName: "="
                },
                controller: "TabsetController",
                templateUrl: "components/common/ui/bootstrap/tabs/tabset.html?bust=1479290327467",
                /**
                 * @param {Object} scope
                 * @param {?} tabCtrl
                 * @param {Object} attrs
                 * @param {?} $attrs
                 * @return {undefined}
                 */
                link: function(scope, tabCtrl, attrs, $attrs) {
                    scope.vertical = angular.isDefined(attrs.vertical)
                        ? scope.$parent.$eval(attrs.vertical)
                        : false;
                    scope.justified = angular.isDefined(attrs.justified)
                        ? scope.$parent.$eval(attrs.justified)
                        : false;
                    scope.$watch("selectedName", function(deepDataAndEvents, dataAndEvents) {
                        if (deepDataAndEvents) {
                            $transition(function() {
                                return $attrs.selectByName(deepDataAndEvents);
                            }, 0);
                        }
                    });
                }
            };
        }
    ]).directive("tab", [
        "$parse",
        "$document",
        function($parse, update) {
            return {
                require: "^tabset",
                restrict: "EA",
                replace: true,
                templateUrl: "components/common/ui/bootstrap/tabs/tab.html?bust=1479290327467",
                transclude: true,
                scope: {
                    active: "=?",
                    heading: "@",
                    name: "@",
                    onSelect: "&select",
                    onDeselect: "&deselect"
                },
                /**
                 * @return {undefined}
                 */
                controller: function() {},
                /**
                 * @param {?} tElement
                 * @param {?} o
                 * @param {?} transclude
                 * @return {?}
                 */
                compile: function(tElement, o, transclude) {
                    return function(scope, dataAndEvents, attrs, tabsetCtrl) {
                        scope.$watch("active", function(dataAndEvents) {
                            if (dataAndEvents) {
                                tabsetCtrl.select(scope);
                            }
                        });
                        /** @type {boolean} */
                        scope.disabled = false;
                        if (attrs.disabled) {
                            scope.$parent.$watch($parse(attrs.disabled), function(dataAndEvents) {
                                /** @type {boolean} */
                                scope.disabled = !!dataAndEvents;
                            });
                        }
                        /**
                         * @return {undefined}
                         */
                        scope.select = function() {
                            if (!scope.disabled) {
                                /** @type {boolean} */
                                scope.active = true;
                            }
                        };
                        tabsetCtrl.addTab(scope);
                        scope.$on("$destroy", function() {
                            tabsetCtrl.removeTab(scope);
                        });
                        scope.$transcludeFn = transclude;
                        if (attrs.hotkey) {
                            $(update).keydown(function(e) {
                                if (e.keyCode == parseInt(attrs.hotkey)) {
                                    if (e.altKey) {
                                        scope.$apply(function() {
                                            return scope.select();
                                        });
                                    }
                                }
                            });
                        }
                    };
                }
            };
        }
    ]).directive("tabHeadingTransclude", [function() {
            return {
                restrict: "A", require: "^tab",
                /**
             * @param {?} scope
             * @param {Object} elm
             * @param {?} tabCtrl
             * @param {?} attrs
             * @return {undefined}
             */
                link: function(scope, elm, tabCtrl, attrs) {
                    scope.$watch("headingElement", function(heading) {
                        if (heading) {
                            elm.html("");
                            elm.append(heading);
                        }
                    });
                }
            };
        }
    ]).directive("tabContentTransclude", function() {
        /**
         * @param {HTMLElement} node
         * @return {?}
         */
        function isTabHeading(node) {
            return node.tagName && (node.hasAttribute("tab-heading") || (node.hasAttribute("data-tab-heading") || ("tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase())));
        }
        return {
            restrict: "A", require: "^tabset",
            /**
             * @param {?} scope
             * @param {Object} elm
             * @param {?} attrs
             * @return {undefined}
             */
            link: function(scope, elm, attrs) {
                var tab = scope.$eval(attrs.tabContentTransclude);
                tab.$transcludeFn(tab.$parent, function(attrs) {
                    angular.forEach(attrs, function(node) {
                        if (isTabHeading(node)) {
                            tab.headingElement = node;
                        } else {
                            elm.append(node);
                        }
                    });
                });
            }
        };
    }), {};
}();
var $__app_95_components_47_common_47_ui_47_drop_47_drop_45_select__ = function() {
    var module = angular.module("ui.drop.select", []);
    return module.directive("uiDropSelect", [
        "$sce",
        "$timeout",
        function(elem, dataAndEvents) {
            return {
                restrict: "EA",
                templateUrl: "components/common/ui/drop/select.html?bust=1479290327467",
                scope: {
                    styleType: "@styleType",
                    labelPattern: "@labelPattern",
                    optionsExp: "&options",
                    placeholder: "@placeholder",
                    disabled: "=",
                    dropClass: "@",
                    btnClass: "@"
                },
                require: "ngModel",
                /**
                     * @param {Object} self
                     * @param {?} tabCtrl
                     * @param {?} scope
                     * @param {?} ngModel
                     * @return {undefined}
                     */
                link: function(self, tabCtrl, scope, ngModel) {
                    self._ = _;
                    self.$watch(self.optionsExp, function(options) {
                        /** @type {Function} */
                        self.options = options;
                    }, true);
                    /**
                         * @param {?} text
                         * @return {undefined}
                         */
                    self.onSelect = function(text) {
                        if (!(self.model == text)) {
                            if (!self.disabled) {
                                self.model = text;
                                ngModel.$setViewValue(self.model);
                            }
                        }
                    };
                    /**
                         * @return {?}
                         */
                    self.getLabel = function() {
                        if (void 0 === self.model || null == self.model) {
                            return elem.trustAsHtml(self.placeholder);
                        }
                        var value = _.find(_.pluck(self.options, self.model));
                        return self.labelPattern
                            ? elem.trustAsHtml(self.labelPattern.replace("{}", value))
                            : elem.trustAsHtml(value);
                    };
                    /**
                         * @return {undefined}
                         */
                    ngModel.$render = function() {
                        self.model = ngModel.$viewValue;
                    };
                }
            };
        }
    ]),
    module.filter("uiDropSelectOptionsFilter", function() {
        return function(attrs, a, b) {
            /** @type {Array} */
            var bProperties = [];
            return a && b
                ? _.isArray(attrs)
                    ? (attrs.forEach(function(props) {
                        var ctx;
                        return bProperties.push((ctx = {}, Object.defineProperty(ctx, props[a], {
                            value: props[b],
                            configurable: true,
                            enumerable: true,
                            writable: true
                        }), ctx));
                    }), bProperties)
                    : null
                : a && !b
                    ? _.isObject(attrs)
                        ? (angular.forEach(attrs, function(info, chain) {
                            var ctx;
                            if (_.isObject(info)) {
                                if (info[a]) {
                                    bProperties.push((ctx = {}, Object.defineProperty(ctx, chain, {
                                        value: info[a],
                                        configurable: true,
                                        enumerable: true,
                                        writable: true
                                    }), ctx));
                                }
                            }
                        }), bProperties)
                        : null
                    : a || b
                        ? null
                        : _.isObject(attrs)
                            ? (angular.forEach(attrs, function(x, chain) {
                                var ctx;
                                return bProperties.push((ctx = {}, Object.defineProperty(ctx, chain, {
                                    value: x,
                                    configurable: true,
                                    enumerable: true,
                                    writable: true
                                }), ctx));
                            }), bProperties.sort(function(a, b) {
                                var i = _.findKey(a);
                                var j = _.findKey(b);
                                return a[i] > b[j]
                                    ? 1
                                    : a[i] < b[j]
                                        ? -1
                                        : 0;
                            }), bProperties)
                            : null;
        };
    }), {};
}();
var $__app_95_components_47_common_47_ui_47_drop_47_drop__ = function() {
    return function() {
        /**
         * @param {string} state
         * @return {?}
         */
        function cb(state) {
            return ngInject([
                "$timeout",
                function($sanitize) {
                    return function(scope, element, iAttrs, ctrl) {
                        scope.ctrl = ctrl;
                        var className = element[0].className;
                        if ("E" == state) {
                            element = element.children();
                        }
                        element.addClass(className).attr("tabindex", "-1");
                        scope.$watch(function() {
                            return ctrl.isOpened && (!iAttrs.uiAutoclose || scope.$eval(iAttrs.uiAutoclose));
                        }, function(dataAndEvents) {
                            if (iAttrs.onOpen) {
                                scope.$eval(iAttrs.onOpen, {$val: dataAndEvents});
                            }
                            if (dataAndEvents) {
                                element.on("blur.dropdown", function(dataAndEvents) {
                                    $sanitize(function() {
                                        /** @type {boolean} */
                                        ctrl.isOpened = false;
                                    }, 150);
                                });
                                element.focus();
                            } else {
                                element.off("blur.dropdown");
                            }
                        });
                    };
                }
            ]);
        }
        var app = angular.module("ui.drop", ["ui.drop.select"]);
        app.controller("ui:drop", [
            "$scope",
            function(dataAndEvents) {
                /** @type {boolean} */
                this.isOpened = false;
            }
        ]);
        app.directive("uiDropGroup", [
            "$injector",
            function($injector) {
                return {
                    restrict: "E",
                    controller: "ui:drop",
                    templateUrl: "components/common/ui/drop/group.html?bust=1479290327467",
                    transclude: true,
                    scope: true,
                    link: $injector.invoke(cb("E"))
                };
            }
        ]);
        app.directive("uiDropGroup", [
            "$injector",
            function(assert) {
                return {
                    restrict: "A",
                    controller: "ui:drop",
                    scope: true,
                    link: assert.invoke(cb("A"))
                };
            }
        ]);
        var list = ngInject([
            "$animate",
            function(dojo) {
                return function(child, item, parent, dataAndEvents) {
                    child.btnClass = parent.btnClass;
                    item.click(function() {
                        child.$apply(function() {
                            /** @type {boolean} */
                            dataAndEvents.isOpened = !dataAndEvents.isOpened;
                        });
                    });
                    child.$watch(function() {
                        return dataAndEvents.isOpened;
                    }, function(inDisabled) {
                        dojo[inDisabled
                                ? "addClass"
                                : "removeClass"](item, "active");
                    });
                };
            }
        ]);
        app.directive("uiDropBtn", [
            "$injector",
            function(Q) {
                return {
                    restrict: "E", require: "^uiDropGroup",
                    /**
                     * @param {?} $element
                     * @param {?} tElement
                     * @return {?}
                     */
                    templateUrl: function($element, tElement) {
                        return "link" == tElement.styleType
                            ? "components/common/ui/drop/btn-link.html"
                            : "md-button" == tElement.styleType
                                ? "components/common/ui/drop/md-btn.html"
                                : "components/common/ui/drop/btn.html?bust=1479290327467";
                    },
                    replace: true,
                    transclude: true,
                    link: Q.invoke(list)
                };
            }
        ]);
        app.directive("uiDropBtn", [
            "$injector",
            function(Q) {
                return {restrict: "A", require: "^uiDropGroup", link: Q.invoke(list)};
            }
        ]);
        var value = ngInject([
            "$animate",
            function($animate) {
                return function(docsRootScope, element, deepDataAndEvents, dataAndEvents) {
                    docsRootScope.$watch(function() {
                        return dataAndEvents.isOpened;
                    }, function(b) {
                        $animate[b
                                ? "removeClass"
                                : "addClass"](element, "ng-hide");
                    });
                    docsRootScope.$on("uiDrop.hide", function() {
                        /** @type {boolean} */
                        dataAndEvents.isOpened = false;
                    });
                    element.find("a, button").mousedown(function(types) {
                        types.preventDefault();
                    });
                };
            }
        ]);
        app.directive("uiDrop", [
            "$injector",
            function($injector) {
                return {
                    restrict: "E",
                    require: "^uiDropGroup",
                    templateUrl: "components/common/ui/drop/drop.html?bust=1479290327467",
                    replace: true,
                    transclude: true,
                    link: $injector.invoke(value)
                };
            }
        ]);
        app.directive("uiDrop", [
            "$injector",
            function($injector) {
                return {restrict: "A", require: "^uiDropGroup", link: $injector.invoke(value)};
            }
        ]);
        app.directive("uiDropItem", function() {
            return {
                restrict: "EA",
                require: "^uiDropGroup",
                templateUrl: "components/common/ui/drop/item.html?bust=1479290327467",
                replace: true,
                transclude: true,
                /**
                 * @param {?} scope
                 * @param {HTMLElement} elm
                 * @param {?} attrs
                 * @param {?} tabCtrl
                 * @return {undefined}
                 */
                link: function(scope, elm, attrs, tabCtrl) {
                    elm.click(function() {
                        scope.$apply(function() {
                            /** @type {boolean} */
                            tabCtrl.isOpened = false;
                        });
                    });
                }
            };
        });
        app.directive("uiDropDivider", function() {
            return {restrict: "EA", require: "^uiDropGroup", templateUrl: "components/common/ui/drop/divider.html?bust=1479290327467", replace: true};
        });
        app.directive("uiDropClose", [
            "$timeout",
            function($transition) {
                return {
                    restrict: "EA", require: "^uiDropGroup",
                    /**
                     * @param {?} scope
                     * @param {HTMLElement} elm
                     * @param {?} attrs
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                    link: function(scope, elm, attrs, tabCtrl) {
                        elm.click(function() {
                            $transition(function() {
                                /** @type {boolean} */
                                tabCtrl.isOpened = false;
                                scope.$apply();
                            }, 0);
                        });
                    }
                };
            }
        ]);
        app.directive("uiDropHeader", function() {
            return {restrict: "EA", require: "^uiDropGroup", templateUrl: "components/common/ui/drop/header.html?bust=1479290327467", replace: true, transclude: true};
        });
    }(), {};
}();
var $__app_95_components_47_common_47_ui_47_json_45_editor__ = function() {
    var ngGridDirectives = angular.module("ui.json-editor", []);
    return ngGridDirectives.directive("appJsonEditor", [
        "$parse",
        function($parse) {
            return {
                /**
                 * @param {?} scope
                 * @param {Array} tabCtrl
                 * @param {?} attrs
                 * @return {undefined}
                 */
                link: function(scope, tabCtrl, attrs) {
                    var data_user = new JSONEditor(tabCtrl[0], scope.$eval(attrs.appJsonEditor), scope.$eval(attrs.editorJson));
                    $parse(attrs.editorInterface).assign(scope, {
                        /**
                         * @param {string} dest
                         * @return {undefined}
                         */
                        set: function(dest) {
                            data_user.set(dest);
                            data_user.collapseAll();
                        },
                        /**
                         * @return {?}
                         */
                        get: function() {
                            return data_user.get();
                        }
                    });
                    data_user.collapseAll();
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_common_47_ui_47_modal_47_modal__ = function() {
    return angular.module("ui.modal", []).factory("$$stackedMap", function() {
        return {
            /**
             * @return {?}
             */
            createNew: function() {
                /** @type {Array} */
                var codeSegments = [];
                return {
                    /**
                     * @param {string} attributes
                     * @param {string} file
                     * @return {undefined}
                     */
                    add: function(attributes, file) {
                        codeSegments.push({key: attributes, value: file});
                    },
                    /**
                     * @param {string} key
                     * @return {?}
                     */
                    get: function(key) {
                        /** @type {number} */
                        var i = 0;
                        for (; i < codeSegments.length; i++) {
                            if (key == codeSegments[i].key) {
                                return codeSegments[i];
                            }
                        }
                    },
                    /**
                     * @return {?}
                     */
                    keys: function() {
                        /** @type {Array} */
                        var keys = [];
                        /** @type {number} */
                        var i = 0;
                        for (; i < codeSegments.length; i++) {
                            keys.push(codeSegments[i].key);
                        }
                        return keys;
                    },
                    /**
                     * @return {?}
                     */
                    top: function() {
                        return codeSegments[codeSegments.length - 1];
                    },
                    /**
                     * @param {?} keepData
                     * @return {?}
                     */
                    remove: function(keepData) {
                        /** @type {number} */
                        var pos = -1;
                        /** @type {number} */
                        var i = 0;
                        for (; i < codeSegments.length; i++) {
                            if (keepData == codeSegments[i].key) {
                                /** @type {number} */
                                pos = i;
                                break;
                            }
                        }
                        return codeSegments.splice(pos, 1)[0];
                    },
                    /**
                     * @return {?}
                     */
                    removeTop: function() {
                        return codeSegments.splice(codeSegments.length - 1, 1)[0];
                    },
                    /**
                     * @return {?}
                     */
                    length: function() {
                        return codeSegments.length;
                    }
                };
            }
        };
    }).directive("modalBackdrop", [
        "$modalStack",
        "$timeout",
        function($modalStack, $resource) {
            return {
                restrict: "EA", replace: true, templateUrl: "components/common/ui/modal/backdrop.html?bust=1479290327467", transclude: true,
                /**
                 * @param {Object} scope
                 * @param {?} tabCtrl
                 * @param {?} attrs
                 * @return {undefined}
                 */
                link: function(scope, tabCtrl, attrs) {
                    $resource(function() {
                        /** @type {boolean} */
                        scope.animate = true;
                    });
                    /**
                     * @param {?} evt
                     * @return {undefined}
                     */
                    scope.close = function(evt) {
                        var modal = $modalStack.getTop();
                        if (modal) {
                            if (modal.value.backdrop) {
                                if ("static" != modal.value.backdrop) {
                                    evt.preventDefault();
                                    evt.stopPropagation();
                                    $modalStack.dismiss(modal.key, "backdrop click");
                                }
                            }
                        }
                    };
                }
            };
        }
    ]).directive("modalWindow", [
        "$timeout",
        "$modalStack",
        "$controller",
        function($resource, $modalStack, dataAndEvents) {
            return {
                restrict: "EA",
                scope: {
                    index: "@"
                },
                replace: true,
                transclude: true,
                templateUrl: "components/common/ui/modal/window.html?bust=1479290327467",
                /**
                 * @param {Object} scope
                 * @param {?} tabCtrl
                 * @param {?} attrs
                 * @return {undefined}
                 */
                link: function(scope, tabCtrl, attrs) {
                    scope.windowClass = attrs.windowClass || "";
                    $resource(function() {
                        /** @type {boolean} */
                        scope.animate = true;
                    });
                    /**
                     * @param {?} evt
                     * @return {undefined}
                     */
                    scope.close = function(evt) {
                        var modal = $modalStack.getTop();
                        if (modal) {
                            if (modal.value.backdrop) {
                                if ("static" != modal.value.backdrop) {
                                    evt.preventDefault();
                                    evt.stopPropagation();
                                    $modalStack.dismiss(modal.key, "backdrop click");
                                }
                            }
                        }
                    };
                }
            };
        }
    ]).directive("modalWindowContent", [
        "$controller",
        function($transition) {
            return {
                /**
                 * @param {?} tabCtrl
                 * @param {Object} parent
                 * @param {?} scope
                 * @param {?} attrs
                 * @param {?} fn
                 * @return {undefined}
                 */
                link: function(tabCtrl, parent, scope, attrs, fn) {
                    fn(function(child) {
                        var element = parent.inheritedData("modal-controller");
                        var camelKey = parent.inheritedData("modal-controller-locals");
                        var unlock = parent.inheritedData("modal-controller-as");
                        if (parent.empty(), parent.append(child), element) {
                            camelKey.$scope = child.scope();
                            var data = $transition(element, camelKey);
                            if (unlock) {
                                camelKey.$scope[unlock] = data;
                            }
                        }
                    });
                }
            };
        }
    ]).factory("$modalStack", [
        "$document",
        "$compile",
        "$rootScope",
        "$$stackedMap",
        "$controller",
        function($document, $compile, $rootScope, $$stackedMap, dataAndEvents) {
            /**
             * @return {?}
             */
            function backdropIndex() {
                /** @type {number} */
                var topBackdropIndex = -1;
                var codeSegments = openedWindows.keys();
                /** @type {number} */
                var i = 0;
                for (; i < codeSegments.length; i++) {
                    if (openedWindows.get(codeSegments[i]).value.backdrop) {
                        /** @type {number} */
                        topBackdropIndex = i;
                    }
                }
                return topBackdropIndex;
            }
            /**
             * @param {string} key
             * @return {undefined}
             */
            function removeModalWindow(key) {
                var modalWindow = openedWindows.get(key).value;
                openedWindows.remove(key);
                modalWindow.modalDomEl.remove();
                if (container) {
                    if (-1 == backdropIndex()) {
                        container.remove();
                        container = void 0;
                    }
                }
                modalWindow.modalScope.$destroy();
            }
            var _template;
            var container;
            var scope = $rootScope.$new(true);
            var extendLi = $document.find("body").eq(0);
            var openedWindows = $$stackedMap.createNew();
            var $modalStack = {};
            return $rootScope.$watch(backdropIndex, function(index) {
                scope.index = index;
            }),
            $document.bind("keydown", function(event) {
                var modal;
                if (27 === event.which) {
                    modal = openedWindows.top();
                    if (modal) {
                        if (modal.value.keyboard) {
                            $rootScope.$apply(function() {
                                $modalStack.dismiss(modal.key);
                            });
                        }
                    }
                }
            }),
            $modalStack.open = function(opt_attributes, modal) {
                openedWindows.add(opt_attributes, {
                    deferred: modal.deferred,
                    modalScope: modal.scope,
                    backdrop: modal.backdrop,
                    keyboard: modal.keyboard
                });
                $(extendLi).addClass("modal-open");
                var element = angular.element("<div modal-window></div>");
                element.attr("window-class", modal.windowClass);
                element.attr("index", openedWindows.length() - 1);
                element.data("modal-controller", modal.controller);
                element.data("modal-controller-locals", modal.ctrlLocals);
                element.data("modal-controller-as", modal.controllerAs);
                element.html(modal.content);
                element.show();
                var modalDomEl = $compile(element)(modal.scope);
                openedWindows.top().value.modalDomEl = modalDomEl;
                extendLi.append(modalDomEl);
                if (modal.autofocus) {
                    setTimeout(function() {
                        element.attr("tabindex", "-1");
                        element.focus();
                    }, 200);
                }
                if (backdropIndex() >= 0) {
                    if (!container) {
                        _template = angular.element("<div modal-backdrop></div>");
                        container = $compile(_template)(scope);
                        extendLi.append(container);
                    }
                }
            },
            $modalStack.close = function(modalInstance, result) {
                $(extendLi).removeClass("modal-open");
                var modal = openedWindows.get(modalInstance);
                if (modal) {
                    if (modal.value) {
                        modal.value.deferred.resolve(result);
                        removeModalWindow(modalInstance);
                    }
                }
            },
            $modalStack.dismiss = function(modalInstance, reason) {
                $(extendLi).removeClass("modal-open");
                var modal = openedWindows.get(modalInstance);
                if (modal) {
                    if (modal.value) {
                        modal.value.deferred.reject(reason);
                        removeModalWindow(modalInstance);
                    }
                }
            },
            $modalStack.getTop = function() {
                return openedWindows.top();
            },
            $modalStack;
        }
    ]).provider("$modal", function() {
        var $modalProvider = {
            options: {
                backdrop: true,
                keyboard: true,
                autofocus: true
            },
            $get: [
                "$injector",
                "$rootScope",
                "$q",
                "$http",
                "$templateCache",
                "$controller",
                "$modalStack",
                "$animate",
                "$timeout",
                function($injector, $rootScope, $q, $http, $templateCache, dataAndEvents, $modalStack, $animator, done) {
                    /**
                     * @param {Object} options
                     * @return {?}
                     */
                    function getTemplatePromise(options) {
                        return options.template
                            ? $q.when(options.template)
                            : $http.get(options.templateUrl, {
                                /** @type {Function} */
                                cache: $templateCache
                            }).then(function(messageEvent) {
                                return messageEvent.data;
                            });
                    }
                    /**
                     * @param {?} resolves
                     * @return {?}
                     */
                    function getResolvePromises(resolves) {
                        /** @type {Array} */
                        var eventPath = [];
                        return angular.forEach(resolves, function(value, dataAndEvents) {
                            if (angular.isFunction(value) || angular.isArray(value)) {
                                eventPath.push($q.when($injector.invoke(value)));
                            }
                        }),
                        eventPath;
                    }
                    var $modal = {};
                    return $modal.open = function(modalOptions) {
                        $animator.enabled(false);
                        var modalResultDeferred = $q.defer();
                        var modalOpenedDeferred = $q.defer();
                        var modalInstance = {
                            result: modalResultDeferred.promise,
                            opened: modalOpenedDeferred.promise,
                            /**
                                 * @param {?} result
                                 * @return {undefined}
                                 */
                            close: function(result) {
                                $modalStack.close(modalInstance, result);
                            },
                            /**
                                 * @param {string} reason
                                 * @return {undefined}
                                 */
                            dismiss: function(reason) {
                                $modalStack.dismiss(modalInstance, reason);
                            }
                        };
                        if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, !modalOptions.template && !modalOptions.templateUrl) {
                            throw new Error("One of template or templateUrl options is required.");
                        }
                        var promise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
                        return promise.then(function(tplAndVars) {
                            var modalScope = (modalOptions.scope || $rootScope).$new();
                            /** @type {function (?): undefined} */
                            modalScope.$close = modalInstance.close;
                            /** @type {function (string): undefined} */
                            modalScope.$dismiss = modalInstance.dismiss;
                            var ctrlLocals = {};
                            /** @type {number} */
                            var resolveIter = 1;
                            if (modalOptions.controller) {
                                ctrlLocals.$scope = modalScope;
                                ctrlLocals.$modalInstance = modalInstance;
                                angular.forEach(modalOptions.resolve, function(dataAndEvents, key) {
                                    ctrlLocals[key] = tplAndVars[resolveIter++];
                                });
                            }
                            $modalStack.open(modalInstance, {
                                scope: modalScope,
                                deferred: modalResultDeferred,
                                content: tplAndVars[0],
                                backdrop: modalOptions.backdrop,
                                keyboard: modalOptions.keyboard,
                                windowClass: modalOptions.windowClass,
                                autofocus: modalOptions.autofocus,
                                controller: modalOptions.controller,
                                controllerAs: modalOptions.controllerAs,
                                ctrlLocals: ctrlLocals
                            });
                            done(function() {
                                $animator.enabled(true);
                            }, 350);
                        }, function(reason) {
                            modalResultDeferred.reject(reason);
                        }),
                        promise.then(function() {
                            modalOpenedDeferred.resolve(true);
                        }, function() {
                            modalOpenedDeferred.reject(false);
                        }),
                        modalInstance;
                    },
                    $modal;
                }
            ]
        };
        return $modalProvider;
    }), {};
}();
var $__app_95_components_47_common_47_ui_47_scrollglue__ = function() {
    return angular.module("luegg.directives", []).directive("scrollGlue", [
        "$parse",
        "$timeout",
        function(normalize, done) {
            /**
             * @param {boolean} dataAndEvents
             * @return {?}
             */
            function link(dataAndEvents) {
                /** @type {boolean} */
                var value = dataAndEvents;
                return {
                    /**
                     * @return {?}
                     */
                    getValue: function() {
                        return value;
                    },
                    /**
                     * @param {?} newValue
                     * @return {undefined}
                     */
                    setValue: function(newValue) {
                        value = newValue;
                    }
                };
            }
            /**
             * @param {?} callback
             * @param {?} name
             * @return {?}
             */
            function data(callback, name) {
                return {
                    /**
                     * @return {?}
                     */
                    getValue: function() {
                        return callback(name);
                    },
                    /**
                     * @return {undefined}
                     */
                    setValue: function() {}
                };
            }
            /**
             * @param {?} callback
             * @param {?} d
             * @param {?} chunk
             * @return {?}
             */
            function transform(callback, d, chunk) {
                return {
                    /**
                     * @return {?}
                     */
                    getValue: function() {
                        return callback(chunk);
                    },
                    /**
                     * @param {string} newValue
                     * @return {undefined}
                     */
                    setValue: function(newValue) {
                        if (newValue !== callback(chunk)) {
                            chunk.$apply(function() {
                                d(chunk, newValue);
                            });
                        }
                    }
                };
            }
            /**
             * @param {Object} style
             * @param {?} res
             * @return {?}
             */
            function success(style, res) {
                if ("" !== style) {
                    var restoreScript = normalize(style);
                    return void 0 !== restoreScript.assign
                        ? transform(restoreScript, restoreScript.assign, res)
                        : data(restoreScript, res);
                }
                return link(true);
            }
            return {
                priority: 1, restrict: "A",
                /**
                 * @param {?} scope
                 * @param {(Image|string)} elm
                 * @param {?} attrs
                 * @return {undefined}
                 */
                link: function(scope, elm, attrs) {
                    /**
                     * @return {undefined}
                     */
                    function scrollToBottom() {
                        div.scrollTop = div.scrollHeight;
                    }
                    /**
                     * @param {?} attrs
                     * @return {undefined}
                     */
                    function validate(attrs) {
                        done(function() {
                            if (r.getValue()) {
                                scrollToBottom();
                            }
                        }, 10);
                    }
                    /**
                     * @return {?}
                     */
                    function fn() {
                        return div.scrollTop + div.clientHeight + 1 >= div.scrollHeight;
                    }
                    /**
                     * @return {undefined}
                     */
                    function handler() {
                        scope.$apply(function() {
                            r.setValue(fn());
                        });
                    }
                    var div = elm[0];
                    var r = success(attrs.scrollGlue, scope);
                    scope.$watchCollection(attrs.scrollIf, validate);
                    elm.bind("scroll", handler);
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_ea_47_ea__ = function() {
    var module = angular.module("app.ea", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/ea", "top.ea").within("top").segment("ea", {
                templateUrl: "components/ea/ea.html?bust=1479290327467",
                controller: "Top.Ea as Ea",
                resolve: {
                    data: ngInject([
                        "Api",
                        function($templateCache) {
                            return $templateCache.get("ea/list").then(function(cl) {
                                return cl.list;
                            });
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("Top.Ea", [
        "$scope",
        "Api",
        "data",
        function(dataAndEvents, $http, data) {
            var element = this;
            this.data = data;
            /** @type {boolean} */
            this.hideSent = false;
            /**
                 * @return {undefined}
                 */
            this.send = function() {
                var contents = _.pluck(_.filter(element.data, {checked: true}), "email");
                $http.post("ea/send", {emails: contents}).then(function(error) {
                    return alert(JSON.stringify(error));
                });
            };
            /**
                 * @param {string} name
                 * @return {?}
                 */
            this.filter = function(name) {
                return !name.sent || !element.hideSent;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_dlg_45_world_45_activation_47_dlg_45_world_45_activation__ = function() {
    var module = angular.module("app.game.dlg-world-activation", []);
    return module.controller("DlgWorldActivation", [
        "$scope",
        "MemoryStorage",
        "$modalInstance",
        "Api",
        "$routeSegment",
        "$location",
        "$timeout",
        "WorldActivator",
        function(ignoreMethodDoesntExist, textAlt, module, test, dataAndEvents, $location, $sanitize, deepDataAndEvents) {
            var e = this;
            /** @type {string} */
            this.code = "";
            /** @type {string} */
            this.error = "";
            /**
                 * @return {undefined}
                 */
            this.submit = function() {
                test.post("user/early-preview", {code: e.code}).then(function(dataAndEvents) {
                    mixpanel.track("Early Preview activated");
                    module.close();
                    deepDataAndEvents.showWelcomeDialog();
                })["catch"](function(dataAndEvents) {
                    if ("invalid code" == dataAndEvents) {
                        /** @type {string} */
                        e.error = "Activation code is invalid";
                    } else {
                        /** @type {string} */
                        e.error = "Unknown error";
                    }
                });
            };
            /**
                 * @return {undefined}
                 */
            this.requestForm = function() {
                module.dismiss();
                $sanitize(function() {
                    return $location.url(dataAndEvents.getSegmentUrl("top.early-preview-request"));
                }, 10);
            };
        }
    ]),
    module.factory("WorldActivator", [
        "Api",
        "$routeSegment",
        "$routeParams",
        "$modal",
        "Dialogs",
        "$rootScope",
        "Socket",
        "$q",
        function(selectElement, dataAndEvents, deepDataAndEvents, $modal, $controllerProvider, $scope, match, $q) {
            /** @type {number} */
            var offset = "1" == localStorage.getItem("debug")
                ? 1
                : 14393988E5;
            var self = {
                launchTime: offset,
                welcomeDialogDisplayed: false
            };
            return $scope.$watch(function() {
                return match.timeCorrection;
            }, function(dataAndEvents, deepDataAndEvents) {
                self.launchTime = offset + match.timeCorrection;
            }),
            self.run = function() {
                return selectElement.options.official
                    ? selectElement.get("user/world-status").then(function(jqXHR) {
                        if ("empty" == jqXHR.status) {
                            self.showWelcomeDialog();
                        }
                    })["catch"](function(dataAndEvents) {
                        return "not allowed" == dataAndEvents
                            ? $modal.open({templateUrl: "components/game/dlg-world-activation/dlg-world-activation.html?bust=1479290327467", controller: "DlgWorldActivation as DlgWorldActivation", windowClass: "dlg-world-activation-window"}).result.then(function() {
                                return self.run();
                            })
                            : void 0;
                    })
                    : (self.showWelcomeDialog(), $q.when());
            },
            self.showWelcomeDialog = function() {
                if (!self.welcomeDialogDisplayed) {
                    /** @type {boolean} */
                    self.welcomeDialogDisplayed = true;
                    if (selectElement.options.official) {
                        $modal.open({templateUrl: "components/game/dlg-world-activation/dlg-world-welcome.html?bust=1479290327467", controller: $controllerProvider.Ctrl});
                    } else {
                        if (selectElement.options.serverData.welcomeText) {
                            $modal.open({
                                template: '<section class=dlg-world-welcome><div class="modal-body">' + selectElement.options.serverData.welcomeText + '</div>\n                                <div class="modal-footer"><md-button class="md-raised md-primary" type="button" ng-click="$dismiss()">OK</div></div>\n                                </section>',
                                controller: $controllerProvider.Ctrl
                            });
                        }
                    }
                }
            },
            self;
        }
    ]), {};
}();
var $__app_95_components_47_game_47_dlg_45_world_45_respawn_47_dlg_45_world_45_respawn__ = function() {
    var ngModule = angular.module("app.game.dlg-world-respawn", []);
    return ngModule.factory("WorldRespawnChecker", [
        "Api",
        "$routeSegment",
        "$routeParams",
        "$modal",
        "Dialogs",
        "$interval",
        "Auth",
        "WorldActivator",
        "$location",
        "$q",
        "LocalStorage",
        "$rootScope",
        function(api, unused, deepDataAndEvents, ignoreMethodDoesntExist, editor, p, engineTools, dataAndEvents, $location, $q, $templateCache, $rootScope) {
            var self = {
                dialogDisplayed: false
            };
            /**
             * @return {?}
             */
            var resolve = function() {
                return !self.dialogDisplayed && engineTools.Me
                    ? api.get("user/world-status").then(function(jqXHR) {
                        if ("lost" == jqXHR.status) {
                            /** @type {boolean} */
                            self.dialogDisplayed = true;
                            editor.ask({title: "", message: '<h4>Oops!</h4>\n                        <p>It seems that you have lost all your spawns. But cheer up! Losing is fun in Screeps! Your scripts are always with you, your Global Control Level is well and alive, and you can start from scratch and quickly regain your former glory.</p>\n                        <p>Click on the Respawn button below, and all your buildings and creeps will be destroyed so that you can reset your spawn in any vacant room on the map. And don\'t forget to <a href="http://support.screeps.com/hc/en-us/articles/203339002-Defending-your-room" app-nw-external-link>build defenses</a> this time!</p>\n                        <p>Learn more about birth and death in <a href="http://support.screeps.com/hc/en-us/articles/203390711-Birth-and-death" app-nw-external-link>this article</a>.</p>', buttonLabel: "Respawn"}).result.then(function() {
                                return init();
                            });
                        } else {
                            var cDigit = $templateCache.get("lastGcl", 1);
                            if (engineTools.Me.getGcl() > parseInt(cDigit)) {
                                editor.alert("", {
                                    html: api.options.official
                                        ? "<p>Global Control Level has been increased!<br>\n                             Your CPU Limit is now <strong>" + engineTools.Me.getCpu() + " CPU</strong>, and you can control <strong>" + engineTools.Me.getGcl() + ' rooms</strong>.<br>\n                             <a target="_blank" href="http://support.screeps.com/hc/en-us/articles/203086021-Territory-control" app-nw-external-link>Learn more</a></p>'
                                        : "<p>Global Control Level has been increased!<br>\n                             You can control <strong>" + engineTools.Me.getGcl() + ' rooms</strong> now.<br>\n                             <a target="_blank" href="http://support.screeps.com/hc/en-us/articles/203086021-Territory-control" app-nw-external-link>Learn more</a></p>'
                                });
                                $templateCache.put("lastGcl", engineTools.Me.getGcl());
                            }
                        }
                    })
                    : void 0;
            };
            /**
             * @param {boolean} dataAndEvents
             * @return {?}
             */
            var init = function(dataAndEvents) {
                var p = $q.when();
                return dataAndEvents && (p = editor.ask({title: "", message: '<p>All your buildings and creeps will be destroyed so that you can reset your spawn in any vacant room on the map. <a href="http://support.screeps.com/hc/en-us/articles/203390711-Birth-and-death" app-nw-external-link>Learn more</a></p><p><b>Note:</b> you will NOT be able to spawn again in the same room within 3 days since the initial spawn placement!</p>', buttonLabel: "Respawn", buttonClass: "md-warn md-hue-2"}).result),
                p.then(function() {
                    return api.post("user/respawn");
                }).then(function() {
                    return engineTools.check();
                }).then(function() {
                    /** @type {boolean} */
                    dataAndEvents.welcomeDialogDisplayed = false;
                    /** @type {boolean} */
                    self.dialogDisplayed = false;
                    if ("top.game-world-map" != unused.name) {
                        $location.url(unused.getSegmentUrl("top.game-world-map"));
                    }
                    $rootScope.$broadcast("respawned");
                });
            };
            return self.bind = function(type) {
                var e = p(resolve, 6E4);
                type.$on("$destroy", function() {
                    return p.cancel(e);
                });
                resolve();
            },
            self.check = function() {
                return resolve();
            },
            self.respawn = function() {
                return init(true);
            },
            self;
        }
    ]), {};
}();
var $__app_95_components_47_game_47_editor_45_panel_47_console_47_console__ = function() {
    var module = angular.module("app.game.console", []);
    return module.controller("Top.Game.Console", [
        "$scope",
        "Console",
        "Tutorial",
        "Connection",
        "$timeout",
        "uiAceConfig",
        function(node, self, selectedElement, dataAndEvents, done, options) {
            var command;
            var obj = this;
            /** @type {null} */
            var queuelen = null;
            /** @type {Array} */
            var elem = [];
            /** @type {string} */
            this.command = "";
            /** @type {boolean} */
            var k = false;
            this.aceOptions = _.merge({
                mode: "javascript",
                theme: "tomorrow_night",
                useWrapMode: false,
                showGutter: false,
                advanced: {
                    highlightActiveLine: false
                },
                rendererOptions: {
                    maxLines: 1
                },
                /**
                     * @param {Object} editor
                     * @return {undefined}
                     */
                onLoad: function(editor) {
                    var HashHandler = ace.require("ace/keyboard/hash_handler").HashHandler;
                    var canon = new HashHandler;
                    canon.addCommand({
                        name: "nav_down.",
                        bindKey: {
                            win: "Down",
                            mac: "Down"
                        },
                        /**
                             * @param {?} jumpToNext
                             * @return {?}
                             */
                        exec: function(jumpToNext) {
                            return obj.keydown({keyCode: 40}),
                            false;
                        },
                        readOnly: true
                    });
                    canon.addCommand({
                        name: "nav_up.",
                        bindKey: {
                            win: "Up",
                            mac: "Up"
                        },
                        /**
                             * @param {?} jumpToNext
                             * @return {?}
                             */
                        exec: function(jumpToNext) {
                            return obj.keydown({keyCode: 38}),
                            false;
                        },
                        readOnly: true
                    });
                    canon.addCommand({
                        name: "nav_enter.",
                        bindKey: {
                            win: "Enter",
                            mac: "Enter"
                        },
                        /**
                             * @param {Object} editor
                             * @return {?}
                             */
                        exec: function(editor) {
                            return obj.keydown({keyCode: 13, editor: editor}),
                            false;
                        },
                        readOnly: true
                    });
                    editor.keyBinding.addKeyboardHandler(canon);
                },
                /**
                     * @param {Object} evt
                     * @return {undefined}
                     */
                onChange: function(evt) {
                    command = evt[1].getValue();
                    if (/.+\n.+/.test(command)) {
                        evt[1].setValue(command.replace(/\r?\n/g, " "));
                    }
                    if (k) {
                        evt[1].navigateLineEnd();
                        /** @type {boolean} */
                        k = false;
                    }
                }
            }, options.ace);
            /**
                 * @return {?}
                 */
            this.getMessages = function() {
                return self.messages[node.Game.player];
            };
            /**
                 * @return {undefined}
                 */
            this.sendCommand = function() {
                command = command.replace(/\n/, "");
                if (command) {
                    selectedElement.trigger("sendConsole", {command: command});
                    self.sendCommand(command, node.Game.player);
                    elem.push(command);
                    /** @type {string} */
                    obj.command = "";
                    /** @type {null} */
                    queuelen = null;
                }
            };
            /**
                 * @param {Object} e
                 * @return {?}
                 */
            this.keydown = function(e) {
                if (13 == e.keyCode && (obj.sendCommand(), e.editor.setValue("")), 38 == e.keyCode) {
                    var queue = _.cloneDeep(elem);
                    if (!queue.length) {
                        return;
                    }
                    if (queuelen < -queue.length) {
                        /** @type {number} */
                        queuelen = -queue.length;
                    }
                    if (null === queuelen) {
                        /** @type {number} */
                        queuelen = -1;
                    }
                    obj.command = queue.splice(queuelen, 1)[0];
                    /** @type {boolean} */
                    k = true;
                    queuelen--;
                }
                if (40 == e.keyCode) {
                    queue = _.cloneDeep(elem);
                    if (!queue.length) {
                        return;
                    }
                    if (null === queuelen) {
                        return;
                    }
                    if (queuelen++, queuelen >= 0) {
                        return queuelen = null,
                        void(obj.command = "");
                    }
                    obj.command = queue.splice(queuelen, 1)[0];
                    /** @type {boolean} */
                    k = true;
                }
                if (40 == e.keyCode || 38 == e.keyCode) {
                    done(function() {
                        return node.$broadcast("consoleHistorySwitched");
                    }, 10);
                }
            };
            /**
                 * @return {undefined}
                 */
            this.clear = function() {
                var key;
                for (key in self.messages) {
                    /** @type {Array} */
                    self.messages[key] = [];
                }
            };
            /**
                 * @return {?}
                 */
            this.isEnabled = function() {
                return self.enabled;
            };
            /**
                 * @return {?}
                 */
            this.toggleEnabled = function() {
                return self.enabled = !self.enabled;
            };
        }
    ]),
    module.factory("Console", [
        "$rootScope",
        "Connection",
        "AppInstanceId",
        "LocalStorage",
        "$routeParams",
        "Auth",
        function(scope, assert, endNode, context, child, req) {
            /**
                 * @param {Object} options
                 * @return {undefined}
                 */
            function init(options) {
                if (self.enabled) {
                    if (options.error) {
                        self.messages[options.userId].push({
                            date: new Date,
                            text: options.error.replace(/\n/g, "<br>"),
                            error: true
                        });
                    } else {
                        var caseSensitive = _.map(options.messages.log, function(messageFormat) {
                            return new Object({
                                date: new Date,
                                text: messageFormat.replace(/\n/g, "<br>")
                            });
                        });
                        var caseInsensitive = _.map(options.messages.results, function(messageFormat) {
                            return new Object({
                                date: new Date,
                                text: messageFormat.replace(/\n/g, "<br>"),
                                "in": true
                            });
                        });
                        self.messages[options.userId] = self.messages[options.userId].concat(caseSensitive, caseInsensitive);
                    }
                    if (self.messages[options.userId].length > width) {
                        self.messages[options.userId] = self.messages[options.userId].slice(-width);
                    }
                    /** @type {boolean} */
                    result[options.userId] = !!options.error;
                }
            }
            var self = {
                messages: {
                    0: [],
                    1: [],
                    2: [],
                    3: []
                },
                enabled: true
            };
            scope.$watch(function() {
                return req.Me && req.Me._id;
            }, function(timeoutKey) {
                if (timeoutKey) {
                    /** @type {Array} */
                    self.messages[timeoutKey] = [];
                }
            });
            /** @type {number} */
            var width = 100;
            /** @type {Array} */
            var result = [false, false, false];
            assert.onConsoleUpdate(function(cb) {
                init(cb);
                end(cb);
            });
            /**
                 * @param {?} params
                 * @param {number} method
                 * @return {undefined}
                 */
            self.sendCommand = function(params, method) {
                if (child.app_instance_id) {
                    if (self.checkAppInstanceId()) {
                        self.messages[method].push({text: params, out: true});
                        context.put("console.send", {
                            text: params,
                            userId: method
                        });
                    }
                } else {
                    self.messages[method].push({text: params, out: true});
                    assert.sendConsoleCommand(params, method);
                    end();
                }
            };
            /**
                 * @param {?} name
                 * @return {?}
                 */
            self.hasError = function(name) {
                return self.enabled && result[name];
            };
            /**
                 * @return {?}
                 */
            self.checkAppInstanceId = function() {
                var n = context.get("editor-popup", {}).appInstanceId;
                return n && (n == child.app_instance_id || n == endNode);
            };
            /**
                 * @param {?} cb
                 * @return {undefined}
                 */
            var end = function(cb) {
                if (self.checkAppInstanceId()) {
                    context.put("console.newData", cb);
                }
            };
            /**
                 * @param {Object} list
                 * @return {undefined}
                 */
            var height = function(list) {
                if (list) {
                    if (self.checkAppInstanceId()) {
                        init(list);
                    }
                }
            };
            return scope.$watch(function() {
                return child.app_instance_id;
            }, function(dataAndEvents) {
                if (dataAndEvents) {
                    height(context.get("console.newData"));
                }
            }),
            context.onChange(scope, "console.newData", height),
            context.onChange(scope, "console.error", function(subKey) {
                if (self.checkAppInstanceId()) {
                    /** @type {Array} */
                    result = subKey;
                }
            }),
            context.onChange(scope, "console.send", function(result) {
                if (result) {
                    if (self.checkAppInstanceId()) {
                        self.sendCommand(result.text, result.userId);
                        context.put("console.send", null);
                    }
                }
            }),
            self;
        }
    ]), {};
}();
var $__app_95_components_47_game_47_editor_45_panel_47_editor_45_panel__ = function() {
    var module = angular.module("app.game.editor-panel", []);
    return module.config([
        "$locationProvider",
        "SocketProvider",
        "$routeProvider",
        "$routeSegmentProvider",
        function(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, $q) {
            $q.when("/editor-popup/:app_instance_id", "editor-popup").segment("editor-popup", {
                templateUrl: "components/game/editor-panel/editor-panel.html?bust=1479290327467",
                resolve: {
                    auth: ngInject([
                        "Auth",
                        function(engineTools) {
                            return engineTools.check()["catch"](angular.noop);
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("EditorPanel", [
        "$rootScope",
        "$routeParams",
        "$scope",
        "Tutorial",
        "Console",
        "AppInstanceId",
        "LocalStorage",
        "Connection",
        function(deepDataAndEvents, self, scope, selectedElement, AuthenticationService, ignoreMethodDoesntExist, handler, dataAndEvents) {
            var $scope = this;
            if (self.app_instance_id) {
                scope.Game = {
                    popped: true,
                    simulationMode: ! !+ self.sim
                };
                /**
                     * @param {boolean} req
                     * @return {undefined}
                     */
                var show = function(req) {
                    /** @type {boolean} */
                    var data = req;
                    $scope.popupEnabled = data && data.appInstanceId == self.app_instance_id;
                    if ($scope.popupEnabled) {
                        scope.Game.player = data.player;
                    }
                };
                show(handler.get("editor-popup"));
                handler.onChange(scope, "editor-popup", show);
                dataAndEvents.setRunningLocal(true);
            }
            this.activeTab = void 0;
            /**
                 * @return {undefined}
                 */
            this.consoleClick = function() {
                selectedElement.trigger("consoleClick");
                scope.$broadcast("consoleTabSelect");
            };
            /**
                 * @return {undefined}
                 */
            this.memoryClick = function() {
                scope.$broadcast("memory update");
                scope.$broadcast("memoryTabSelect");
            };
            /**
                 * @return {undefined}
                 */
            this.scriptClick = function() {
                selectedElement.trigger("scriptClick");
                scope.$broadcast("scriptTabSelect");
            };
            /**
                 * @return {?}
                 */
            this.hasConsoleError = function() {
                return AuthenticationService.hasError(scope.Game.player);
            };
            /**
                 * @return {?}
                 */
            this.isPopupSynced = function() {
                return !AuthenticationService.checkAppInstanceId();
            };
            scope.$on("addMemoryWatch", function() {
                /** @type {string} */
                $scope.activeTab = "memory";
            });
        }
    ]),
    module.directive("appResizePanel", [
        "LocalStorage",
        "$timeout",
        "$document",
        function(node, $timeout, update) {
            return {
                controller: [
                    "$element",
                    "$scope",
                    function(sourceContainer, $rootScope) {
                        var grid = this;
                        /** @type {boolean} */
                        var value = false;
                        /**
                             * @param {number} value
                             * @param {boolean} dataAndEvents
                             * @return {undefined}
                             */
                        this.setHeight = function(value, dataAndEvents) {
                            if (80 > value) {
                                /** @type {number} */
                                value = 80;
                            }
                            $(sourceContainer).find(".editor-panel").height(value);
                            $(sourceContainer).find("section.room").css("bottom", value + "px");
                            if (!dataAndEvents) {
                                $rootScope.$broadcast("resize", {sameSize: true});
                            }
                            node.put("game.editor.height", value);
                        };
                        /**
                             * @return {?}
                             */
                        this.getHeight = function() {
                            return $(sourceContainer).find(".editor-panel").height();
                        };
                        /**
                             * @param {boolean} index
                             * @return {undefined}
                             */
                        this.toggle = function(index) {
                            value = _.isUndefined(index)
                                ? !value
                                : index;
                            node.put("game.editor.hidden", value);
                            if (value) {
                                $(sourceContainer).find(".editor-panel").height(31);
                                $(sourceContainer).find("section.room").css("bottom", "31px");
                                $rootScope.$broadcast("resize", {sameSize: true});
                            } else {
                                grid.setHeight(node.get("game.editor.height", 250));
                            }
                        };
                        /**
                             * @return {?}
                             */
                        this.isHidden = function() {
                            return value;
                        };
                        /**
                             * @return {?}
                             */
                        var hide = function() {
                            return $(sourceContainer).find(".editor-panel").length && $(sourceContainer).find("section.room").length
                                ? (value = node.get("game.editor.hidden", true), value
                                    ? grid.toggle(true)
                                    : grid.setHeight(node.get("game.editor.height", 250), true), void $rootScope.$broadcast("resize", {sameSize: true}))
                                : void $timeout(hide, 10);
                        };
                        hide();
                        $(update).keydown(function(e) {
                            if (13 == e.keyCode) {
                                if (e.altKey) {
                                    $rootScope.$apply(function() {
                                        grid.toggle();
                                    });
                                }
                            }
                        });
                    }
                ]
            };
        }
    ]),
    module.directive("appResizePanelHandle", [
        "$document",
        function(canvas) {
            return {
                require: "^?appResizePanel",
                /**
                     * @param {?} scope
                     * @param {?} elem
                     * @param {?} tabCtrl
                     * @param {Object} object
                     * @return {undefined}
                     */
                link: function(scope, elem, tabCtrl, object) {
                    var name;
                    /** @type {boolean} */
                    var prev_y = false;
                    $(elem).mousedown(function(e) {
                        return scope.$apply(function() {
                            prev_y = e.clientY;
                            name = object.getHeight();
                        }),
                        false;
                    });
                    $(canvas).on("mouseup mousemove", function(e) {
                        return prev_y === false
                            ? true
                            : e.clientY < 150
                                ? true
                                : (scope.$apply(function() {
                                    object.setHeight(prev_y - e.clientY + name);
                                    object.toggle(false);
                                }), false);
                    });
                    $(canvas).mouseup(function() {
                        scope.$apply(function() {
                            return prev_y = false;
                        });
                    });
                }
            };
        }
    ]),
    module.directive("appResizePanelToggle", function() {
        return {
            require: "^?appResizePanel",
            /**
                 * @param {?} scope
                 * @param {?} elem
                 * @param {Object} attrs
                 * @param {Object} object
                 * @return {undefined}
                 */
            link: function(scope, elem, attrs, object) {
                $(elem).click(function() {
                    scope.$apply(function() {
                        object.toggle();
                    });
                });
                scope.$watch(function() {
                    return object.isHidden();
                }, function(lcNames) {
                    attrs[lcNames
                            ? "$addClass"
                            : "$removeClass"]("minimized");
                });
            }
        };
    }),
    module.directive("appResizePanelOpen", function() {
        return {
            require: "^?appResizePanel",
            /**
                 * @param {?} scope
                 * @param {?} elem
                 * @param {?} tabCtrl
                 * @param {Object} object
                 * @return {undefined}
                 */
            link: function(scope, elem, tabCtrl, object) {
                $(elem).click(function() {
                    scope.$apply(function() {
                        if (object) {
                            if (object.isHidden()) {
                                object.toggle(false);
                            }
                        }
                    });
                });
            }
        };
    }),
    module.directive("appPopupPanel", [
        "AppInstanceId",
        "LocalStorage",
        "$window",
        function(dataAndEvents, $templateCache, $modal) {
            return {
                require: "^?appResizePanel",
                /**
                     * @param {Window} scope
                     * @param {HTMLElement} elm
                     * @param {?} tabCtrl
                     * @param {Object} attrs
                     * @return {undefined}
                     */
                link: function(scope, elm, tabCtrl, attrs) {
                    elm.click(function() {
                        scope.$apply(function() {
                            $templateCache.put("editor-popup", {
                                player: scope.Game.player,
                                appInstanceId: dataAndEvents
                            });
                            /** @type {string} */
                            var modalOptions = window.location.href.replace(window.location.hash, "") + "#!/editor-popup/" + dataAndEvents + "?sim=" + + !!scope.Game.simulationMode;
                            /** @type {number} */
                            var w = $(window).width() - 100;
                            /** @type {number} */
                            var dy = $(window).height() / 2;
                            /** @type {string} */
                            var controller = "screeps-editor-popup";
                            /** @type {number} */
                            var l = 0;
                            /** @type {number} */
                            var top = 0;
                            if (!controller) {
                                /** @type {string} */
                                controller = "MyWindow";
                            }
                            if (!w) {
                                /** @type {number} */
                                w = 600;
                            }
                            if (!dy) {
                                /** @type {number} */
                                dy = 600;
                            }
                            if ("undefined" != typeof window.screenLeft) {
                                l = window.screenLeft;
                                top = window.screenTop;
                            } else {
                                if ("undefined" != typeof window.screenX) {
                                    /** @type {number} */
                                    l = window.screenX;
                                    /** @type {number} */
                                    top = window.screenY;
                                }
                            }
                            var options = {
                                toolbar: "no",
                                location: "no",
                                directories: "no",
                                left: l + ($(window).width() - w) / 2,
                                top: top + ($(window).height() - dy),
                                status: "no",
                                menubar: "no",
                                scrollbars: "yes",
                                resizable: "no",
                                width: w,
                                height: dy
                            };
                            /** @type {Array} */
                            var tagNameArr = [];
                            var option;
                            for (option in options) {
                                tagNameArr.push(option + "=" + options[option]);
                            }
                            /** @type {string} */
                            var filetype = tagNameArr.join(",");
                            var modal = $modal.open(modalOptions, controller, filetype);
                            modal.focus();
                            attrs.toggle(true);
                        });
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_editor_45_panel_47_memory_47_memory__ = function() {
    var module = angular.module("app.game.memory", []);
    return module.controller("Top.Game.Memory", [
        "MemoryStorage",
        "LocalStorage",
        "$scope",
        "$routeParams",
        "AppInstanceId",
        "Connection",
        "Auth",
        function(dataAndEvents, handler, scope, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, opts) {
            var self = this;
            /** @type {string} */
            this.newWatchPath = "";
            this.watches = handler.get("memory.watches", [
                {
                    path: "creeps"
                }, {
                    path: "spawns"
                }, {
                    path: "rooms"
                }, {
                    path: "flags"
                }, {
                    path: "spawns.Spawn1"
                }
            ]);
            if (!this.watches.length || this.watches[0].path) {
                this.watches.unshift({path: ""});
            }
            /**
                 * @param {string} options
                 * @return {undefined}
                 */
            this.addWatch = function(options) {
                if (options) {
                    self.watches.push({path: options});
                    self.watches = _.uniq(self.watches, "path");
                    handler.put("memory.watches", self.watches);
                }
            };
            /**
                 * @param {string} id
                 * @return {undefined}
                 */
            this.removeWatch = function(id) {
                _.remove(self.watches, {path: id});
                handler.put("memory.watches", self.watches);
            };
            /**
                 * @return {undefined}
                 */
            this.submitNewWatch = function() {
                self.addWatch(self.newWatchPath);
                /** @type {string} */
                self.newWatchPath = "";
            };
            /**
                 * @param {Error} item1
                 * @return {?}
                 */
            this.orderBy = function(item1) {
                return item1.path == self.selectedObjectWatch
                    ? -1
                    : item1.path;
            };
            scope.$on("roomObjectSelected", function(dataAndEvents, e) {
                if (self.selectedObjectWatch) {
                    self.removeWatch(self.selectedObjectWatch);
                }
                /** @type {null} */
                self.selectedObjectWatch = null;
                if (e) {
                    if ("flag" == e.type || (opts.Me && e.user == opts.Me._id || 0 == e.user && (!opts.Me || opts.Me == scope.Game.player))) {
                        if ("spawn" == e.type) {
                            /** @type {string} */
                            self.selectedObjectWatch = "spawns." + e.name;
                        }
                        if ("creep" == e.type) {
                            /** @type {string} */
                            self.selectedObjectWatch = "creeps." + e.name;
                        }
                        if ("flag" == e.type) {
                            /** @type {string} */
                            self.selectedObjectWatch = "flags." + e.name;
                        }
                    }
                }
                if (self.selectedObjectWatch) {
                    self.addWatch(self.selectedObjectWatch);
                }
            });
            handler.onChange(scope, "memory.watches", function(theTitle) {
                /** @type {string} */
                self.watches = theTitle;
            });
        }
    ]),
    module.controller("Top.Game.Memory.MemoryWatch", [
        "$scope",
        "Connection",
        "$timeout",
        "$q",
        "LocalStorage",
        "$routeParams",
        "AppInstanceId",
        "Dialogs",
        function(self, path, $sanitize, request, that, k, height, dialog) {
            /**
                 * @return {?}
                 */
            function fn() {
                var key = that.get("editor-popup", {}).appInstanceId;
                return key == k.app_instance_id || key == height;
            }
            /**
                 * @param {string} key
                 * @param {string} obj
                 * @return {?}
                 */
            function del(key, obj) {
                return fn()
                    ? request(function(callback, success) {
                        that.put(key, {
                            send: true,
                            data: obj
                        });
                        var v = that.onChange(self, key, function(r) {
                            if (r.resolve) {
                                callback(r.result);
                            }
                            if (r.reject) {
                                success(r.result);
                            }
                            that.remove(key);
                            v();
                        });
                    })
                    : request.reject();
            }
            /**
                 * @param {string} value
                 * @param {Function} func
                 * @return {undefined}
                 */
            function wrap(value, func) {
                that.onChange(self, value, function(response) {
                    if (fn()) {
                        if (response) {
                            if (response.send) {
                                func(response.data).then(function(a) {
                                    that.put(value, {
                                        resolve: true,
                                        result: a
                                    });
                                })["catch"](function(a) {
                                    that.put(value, {
                                        reject: true,
                                        result: a
                                    });
                                });
                            }
                        }
                    }
                });
            }
            /**
                 * @return {?}
                 */
            function wrapper() {
                return k.app_instance_id
                    ? del("memory.getMemoryByPath:" + self.watch.path, {})
                    : path.getMemoryByPath(self.Game.player, self.watch.path);
            }
            /**
                 * @param {string} step
                 * @return {?}
                 */
            function render(step) {
                return k.app_instance_id
                    ? del("memory.setMemoryByPath:" + self.watch.path, step)
                    : path.setMemoryByPath(self.Game.player, self.watch.path, step);
            }
            var _this = this;
            /** @type {null} */
            this.editing = null;
            this.editor = {};
            /** @type {boolean} */
            this.loading = false;
            /**
                 * @return {?}
                 */
            this.getMemory = function() {
                return "Incorrect memory path" != _this.value
                    ? (_this.loading = true, wrapper().then(function(value) {
                        if (!value) {
                            /** @type {string} */
                            value = "" + value;
                            if (!value) {
                                /** @type {string} */
                                value = "undefined";
                            }
                        }
                        /** @type {number} */
                        _this.editingSize = JSON.stringify(value).length / 1024;
                        $sanitize(function() {
                            return _this.editing = value;
                        }, 10);
                    })["finally"](function() {
                        return _this.loading = false;
                    }))
                    : void 0;
            };
            /**
                 * @return {?}
                 */
            this.reload = function() {
                return wrapper().then(function(clone) {
                    _this.editor.set(clone);
                });
            };
            /**
                 * @return {?}
                 */
            this.save = function() {
                var d = _this.editor.get();
                var p = request.when();
                return self.watch.path || (p = dialog.ask({message: "You are going to rewrite the entire Memory tree. Doing so is not recommended and could result in replacing some of your variables that are already changed with an obsolete state. It is better to create a watch for a specific sub-tree and commit it instead.<br><br>Do you really want to proceed?"}).result),
                p.then(function() {
                    return render(d);
                }).then(function() {
                    /** @type {string} */
                    _this.value = "" + d;
                    /** @type {null} */
                    _this.editing = null;
                    /** @type {boolean} */
                    _this.removeFirstTry = false;
                });
            };
            /**
                 * @return {?}
                 */
            this.remove = function() {
                return _this.removeFirstTry
                    ? render(void 0).then(function() {
                        self.Memory.removeWatch(self.watch.path);
                    })
                    : (_this.removeFirstTry = true, request.when());
            };
            /**
                 * @return {undefined}
                 */
            this.cancel = function() {
                /** @type {null} */
                _this.editing = null;
                /** @type {boolean} */
                _this.removeFirstTry = false;
            };
            /**
                 * @return {?}
                 */
            this.getLastPathPart = function() {
                if (!self.watch.path) {
                    return "Memory";
                }
                var eventPath = self.watch.path.split(/\./);
                return eventPath.pop();
            };
            if (k.app_instance_id) {
                if (self.watch.path) {
                    that.onChange(self, "memory.sendWatch:" + self.watch.path, function(filter) {
                        if (filter) {
                            if (fn()) {
                                _this.value = filter;
                            }
                        }
                    });
                }
            } else {
                if (self.watch.path) {
                    path.onMemoryUpdate(self, self.Game.player, self.watch.path, function(value) {
                        /** @type {string} */
                        _this.value = value;
                        if (fn()) {
                            that.put("memory.sendWatch:" + self.watch.path, value);
                            $sanitize(function() {
                                return that.remove("memory.sendWatch:" + self.watch.path);
                            }, 100);
                        }
                    });
                }
                wrap("memory.getMemoryByPath:" + self.watch.path, wrapper);
                wrap("memory.setMemoryByPath:" + self.watch.path, render);
            }
            self.$on("addMemoryWatch", function(dataAndEvents, new_path) {
                if (self.watch.path == new_path) {
                    _this.getMemory();
                }
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_editor_45_panel_47_script_47_dlg_45_clone_45_branch_47_dlg_45_clone_45_branch__ = function() {
    var ngModule = angular.module("app.game.script.dlg-clone-branch", []);
    return ngModule.controller("DlgCloneBranch", [
        "$scope",
        "Api",
        "data",
        "$modalInstance",
        "CodeBranches",
        "NwLocalFileSync",
        function(dataAndEvents, deepDataAndEvents, tree, db, _, assert) {
            var self = this;
            /** @type {string} */
            this.newName = "";
            /** @type {string} */
            this.error = "";
            /** @type {Array} */
            this.branchesList = [];
            _.loadBranches().then(function(theTitle) {
                return self.branchesList = theTitle;
            });
            /**
             * @return {undefined}
             */
            this.onChange = function() {
                /** @type {string} */
                self.error = _.any(self.branchesList, {branch: self.newName})
                    ? "A branch with this name already exists and will be overwritten!"
                    : "";
            };
            /**
             * @return {undefined}
             */
            this.submit = function() {
                _.cloneBranch(tree.branch, self.newName).then(function(deepDataAndEvents) {
                    assert.cloneBranch(tree.branch, self.newName, deepDataAndEvents);
                    db.close(self.newName);
                })["catch"](function(dataAndEvents) {
                    /** @type {string} */
                    self.error = "Unknown error";
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_editor_45_panel_47_script_47_script__ = function() {
    var module = angular.module("app.game.script", []);
    return module.controller("Top.Game.Script", [
        "$scope",
        "MemoryStorage",
        "LocalStorage",
        "$q",
        "Tutorial",
        "Api",
        "Auth",
        "Socket",
        "Loader",
        "$routeParams",
        "Dialogs",
        "$modal",
        "CodeBranches",
        "NwLocalFileSync",
        function(scope, app, db, $q, selectedElement, deepDataAndEvents, opts, ignoreMethodDoesntExist, appLoading, dataAndEvents, self, $modal, result, exports) {
            var options = this;
            /** @type {string} */
            this.activeModule = "main";
            /** @type {boolean} */
            this.dirty = false;
            /** @type {null} */
            this.branch = null;
            /** @type {string} */
            this.activeName = scope.Game.simulationMode
                ? "activeSim"
                : "activeWorld";
            /**
                 * @return {undefined}
                 */
            this.reset = function() {
                var reversed = app.get("users.code." + options.activeName);
                var sails = _.find(reversed, function(player) {
                    return player._id == scope.Game.player;
                });
                if (sails) {
                    options.modules = _.cloneDeep(sails.modules);
                    /** @type {boolean} */
                    options.dirty = false;
                    if (!options.modules[options.activeModule]) {
                        /** @type {string} */
                        options.activeModule = "main";
                    }
                }
            };
            db.onChange(scope, "users.code." + this.activeName, function(value) {
                app.put("users.code." + options.activeName, value);
                options.reset();
            });
            db.onChange(scope, "users.code.submit", function(data) {
                if (data) {
                    appLoading.loading(result.submitCode(data.branch, data.modules).then(function(fn) {
                        return exports.writeBranch(data.branch, data.modules, fn);
                    }));
                    db.remove("users.code.submit");
                }
            });
            db.onChange(scope, "branches." + this.activeName, function(opt_scope) {
                result.setActiveBranch(options.activeName, opt_scope);
            });
            /**
                 * @return {undefined}
                 */
            this.submit = function() {
                var q = app.get("users.code." + options.activeName);
                var obj = _.cloneDeep(options.modules);
                var data = _.find(q, function(player) {
                    return player._id == scope.Game.player;
                });
                if (!data) {
                    data = {
                        _id: scope.Game.player
                    };
                    q.push(data);
                }
                data.modules = obj;
                /** @type {number} */
                data.timestamp = Date.now();
                app.put("users.code." + options.activeName, q);
                db.put("users.code." + options.activeName, q);
                selectedElement.trigger("submitScript", {modules: obj});
                //if (dataAndEvents.app_instance_id || opts.Me) {
                db.put("users.code.submit", {
                    branch: options.branch,
                    modules: obj
                });
                //  } else {
                appLoading.loading(result.submitCode(options.branch, obj).then(function(fn) {
                    return exports.writeBranch(options.branch, obj, fn);
                }));
                //  }
                /** @type {boolean} */
                options.dirty = false;
            };
            /**
                 * @param {string} index
                 * @return {?}
                 */
            this.filterNotMain = function(index) {
                return _.isString(options.modules[index]) && "main" != index;
            };
            /**
                 * @param {?} index
                 * @return {undefined}
                 */
            this.removeModule = function(index) {
                delete options.modules[index];
                /** @type {null} */
                options.modules[index] = null;
                if (options.activeModule == index) {
                    /** @type {string} */
                    options.activeModule = "main";
                }
                /** @type {boolean} */
                options.dirty = true;
            };
            /**
                 * @return {undefined}
                 */
            this.switchToBranches = function() {
                resolve().then(function() {
                    return options.branchesMode = true;
                });
            };
            /**
                 * @return {undefined}
                 */
            this.switchToModules = function() {
                /** @type {boolean} */
                options.branchesMode = false;
            };
            /**
                 * @param {?} opt_attributes
                 * @return {?}
                 */
            this.cloneBranch = function(opt_attributes) {
                return options.branchesList.length >= 30
                    ? void self.alert("", "You cannot create more than 30 branches. Please remove some existing branches to clone this branch.")
                    : $modal.open({
                        templateUrl: "components/game/editor-panel/script/dlg-clone-branch/dlg-clone-branch.html?bust=1479290327467",
                        controller: "DlgCloneBranch as DlgCloneBranch",
                        resolve: {
                            /**
                                 * @return {?}
                                 */
                            data: function() {
                                return new Object({branch: opt_attributes});
                            }
                        }
                    }).result.then(resolve);
            };
            /**
                 * @param {?} value
                 * @return {?}
                 */
            this.deleteBranch = function(value) {
                return self.ask({message: "This action cannot be undone! Are you sure?", buttonClass: "md-warn md-hue-2", buttonLabel: "Delete"}).result.then(function() {
                    return result.deleteBranch(value);
                }).then(function(ret) {
                    return exports.deleteBranch(value, ret),
                    resolve();
                });
            };
            /**
                 * @param {?} opt_scope
                 * @return {undefined}
                 */
            this.selectBranch = function(opt_scope) {
                var p = $q.when();
                if (options.dirty) {
                    p = self.ask("", "You have unsaved changes in your current branch! It will be lost if you switch to another branch. Proceed?").result;
                }
                p.then(function() {
                    return result.setActiveBranch(options.activeName, opt_scope);
                }).then(function() {
                    return options.switchToModules();
                });
            };
            /**
                 * @return {undefined}
                 */
            this.openLocalFolder = function() {
                self.alert("", {
                    html: "Navigate to this folder in order to edit scripts in your own IDE:<br><pre>" + (exports.dataPath + exports.sep + options.branch) + "</pre>"
                });
                nw.Shell.showItemInFolder(exports.dataPath + exports.sep + options.branch + exports.sep + options.activeModule + ".js");
            };
            /**
                 * @return {?}
                 */
            var resolve = function() {
                return appLoading.loading(result.loadBranches().then(function(uri) {
                    return options.branchesList = uri;
                }));
            };
            /**
                 * @param {boolean} deepDataAndEvents
                 * @return {?}
                 */
            var save = function(deepDataAndEvents) {
                return appLoading.loading(result.loadModulesByActiveName(options.activeName).then(function(data) {
                    if (0 == scope.Game.player || opts.Me && scope.Game.player == opts.Me._id) {
                        options.branch = data.branch;
                        update(data.modules, deepDataAndEvents);
                    }
                }));
            };
            /**
                 * @param {Object} newVal
                 * @param {boolean} deepDataAndEvents
                 * @return {undefined}
                 */
            var update = function(newVal, deepDataAndEvents) {
                var q = db.get("users.code." + options.activeName, []);
                var data = _.find(q, {_id: scope.Game.player});
                if (!data) {
                    data = {
                        _id: scope.Game.player
                    };
                    q.push(data);
                }
                /** @type {Object} */
                data.modules = newVal;
                if (deepDataAndEvents) {
                    /** @type {number} */
                    data.timestamp = Date.now();
                }
                db.put("users.code." + options.activeName, q);
                if (!("activeSim" != options.activeName)) {
                    if (!_.any(q, {_id: "1"})) {
                        q.push({
                            _id: "1",
                            modules: {
                                main: ""
                            }
                        });
                    }
                }
                app.put("users.code." + options.activeName, q);
                options.reset();
            };
            if (!opts.Me) {
                result.userId = scope.Game.player;
                result.init(this.activeName);
            }
            scope.$watch(function() {
                return scope.Game.player;
            }, function() {
                if (!opts.Me) {
                    result.userId = scope.Game.player;
                }
                options.reset();
            });
            save();
            result.registerActiveBranchCallback(scope, this.activeName, function() {
                return save(true);
            });
            result.registerCodeCallback(scope, function(data) {
                if (data.branch == options.branch) {
                    update(data.modules, true);
                }
            });
        }
    ]),
    module.controller("Top.Game.Script.AddModuleForm", [
        "$scope",
        function($scope) {
            var mod = this;
            /** @type {string} */
            this.newModuleName = "";
            this.moduleNameValidator = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                notMain: function(qualifier) {
                    return !/^main$/i.test(qualifier);
                },
                /**
                     * @param {?} key
                     * @return {?}
                     */
                unique: function(key) {
                    return _.isObject($scope.Script.modules) && (_.isUndefined($scope.Script.modules[key]) || null === $scope.Script.modules[key]);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                slash: function(qualifier) {
                    return !/[\\/]/.test(qualifier);
                }
            };
            /**
                 * @return {undefined}
                 */
            this.addNewModule = function() {
                if ($scope.addForm.$valid) {
                    /** @type {string} */
                    $scope.Script.modules[mod.newModuleName] = "/*\n * Module code goes here. Use 'module.exports' to export things:\n * module.exports.thing = 'a thing';\n *\n * You can import it from another modules like this:\n * var mod = require('" + mod.newModuleName + "');\n * mod.thing == 'a thing'; // true\n */\n\nmodule.exports = {\n\n};";
                    $scope.Script.activeModule = mod.newModuleName;
                    /** @type {string} */
                    mod.newModuleName = "";
                    /** @type {boolean} */
                    $scope.Script.dirty = true;
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_game__ = function() {
    var module = angular.module("app.game", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/sim", "top.sim").within("top").segment("sim", {
                templateUrl: "components/game/simulation-welcome.html?bust=1479290327467",
                controller: "Top.Sim as Sim"
            });
            $q.when("/sim/survival", "top.sim-survival").within("top").segment("sim-survival", {
                templateUrl: "components/game/game.html?bust=1479290327467",
                controller: "Top.SimGame as Game"
            });
            $q.when("/sim/tutorial/:section", "top.sim-tutorial").within("top").segment("sim-tutorial", {
                templateUrl: "components/game/game.html?bust=1479290327467",
                controller: "Top.SimGame as Game",
                dependencies: ["section"]
            });
            $q.when("/sim/custom", "top.sim-custom").within("top").segment("sim-custom", {
                templateUrl: "components/game/game.html?bust=1479290327467",
                controller: "Top.SimGame as Game"
            });
            $q.when("/history/:room", "top.game-room-history").within("top").segment("game-room-history", {
                templateUrl: "components/game/game.html?bust=1479290327467",
                controller: "Top.SimGame as Game"
            });
            $q.when("/room/:room", "top.game-room").within("top").segment("game-room", {
                templateUrl: "components/game/game.html?bust=1479290327467",
                controller: "Top.RoomGame as Game",
                resolve: {
                    data: ngInject([
                        "RoomGameLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("Top.Sim", [
        "$scope",
        "Tutorial",
        "LocalStorage",
        "$location",
        "$routeSegment",
        function(dataAndEvents, selectedElement, $templateCache, $location, res) {
            selectedElement.trigger("simulationMainMenu");
            if (!$templateCache.get("tutorialVisited", false)) {
                $templateCache.put("tutorialVisited", true);
                fbq("track", "Lead");
                $location.url(res.getSegmentUrl("top.sim-tutorial", {section: 1}));
            }
        }
    ]),
    module.controller("Top.SimGame", [
        "$scope",
        "Console",
        "Connection",
        "MemoryStorage",
        "Tutorial",
        "Constants",
        "StaticMaps",
        "$q",
        "$http",
        "LocalStorage",
        "$location",
        "Api",
        "AppInstanceId",
        "$routeSegment",
        "Loader",
        "Auth",
        "$routeParams",
        "$timeout",
        "CodeBranches",
        "TutorialCode",
        "NwLocalFileSync",
        function(scope, deepDataAndEvents, r, self, b, ignoreMethodDoesntExist, a, textAlt, keepData, $templateCache, $location, $, dataAndEvents, $scope, opt_attributes, req, time, $transition, result, dirs, fs) {
            var obj = this;
            /** @type {string} */
            this.player = "0";
            if (req.Me) {
                this.player = req.Me._id;
            }
            /** @type {boolean} */
            this.playing = false;
            /** @type {number} */
            this.speed = 100;
            /** @type {null} */
            this.survivalScore = null;
            r.setRunningLocal(true);
            r.setTickPeriod(1E5 / this.speed);
            /**
                 * @return {undefined}
                 */
            this.play = function() {
                r.run();
                /** @type {boolean} */
                obj.playing = true;
                /** @type {boolean} */
                obj.playDisabled = false;
            };
            /**
                 * @return {undefined}
                 */
            this.pause = function() {
                r.terminate();
                /** @type {boolean} */
                obj.playing = false;
            };
            /** @type {number} */
            this.maxSpeed = "top.game-room-history" == $scope.name
                ? 2E3
                : 500;
            /**
                 * @return {undefined}
                 */
            this.incSpeed = function() {
                obj.speed += obj.speed < 100
                    ? 50
                    : obj.speed < 600
                        ? 100
                        : obj.speed < 1E3
                            ? 200
                            : 500;
                if (obj.speed > obj.maxSpeed) {
                    obj.speed = obj.maxSpeed;
                }
                r.setTickPeriod(1E5 / obj.speed);
                if (obj.playing) {
                    r.terminate();
                    r.run();
                }
            };
            /**
                 * @return {undefined}
                 */
            this.decSpeed = function() {
                obj.speed -= obj.speed > 1E3
                    ? 500
                    : obj.speed > 600
                        ? 200
                        : obj.speed > 100
                            ? 100
                            : 50;
                if (obj.speed < 50) {
                    /** @type {number} */
                    obj.speed = 50;
                }
                r.setTickPeriod(1E5 / obj.speed);
                if (obj.playing) {
                    r.terminate();
                    r.run();
                }
            };
            /**
                 * @param {string} id
                 * @return {undefined}
                 */
            this.setSimulationMode = function(id) {
                /** @type {string} */
                obj.simulationMode = id;
                /** @type {Array} */
                var user = [
                    {
                        _id: "0",
                        username: "Player 1"
                    }, {
                        _id: "1",
                        username: "Player 2"
                    }, {
                        _id: "2",
                        username: "Invader"
                    }, {
                        _id: "3",
                        username: "Source Keeper"
                    }
                ];
                /** @type {Array} */
                var value = [
                    {
                        _id: "0",
                        memory: JSON.stringify({creeps: {}, spawns: {}, rooms: {}, flags: {}})
                    }, {
                        _id: "1",
                        memory: JSON.stringify({creeps: {}, spawns: {}, rooms: {}, flags: {}})
                    }, {
                        _id: "2",
                        memory: JSON.stringify({creeps: {}, spawns: {}, rooms: {}, flags: {}})
                    }, {
                        _id: "3",
                        memory: JSON.stringify({creeps: {}, spawns: {}, rooms: {}, flags: {}})
                    }
                ];
                if (req.Me && (user[0]._id = req.Me._id, user[0].username = req.Me.username, value[0]._id = req.Me._id), self.put("users", user), self.put("users.memory", value), "tutorial" == id) {
                    result.userId = obj.player;
                    /** @type {string} */
                    var resolvedPath = "tutorial-" + $scope.$routeParams.section;
                    var dir = dirs["section" + $scope.$routeParams.section];
                    result.cloneBranch(void 0, resolvedPath, dir).then(function(a) {
                        return fs.writeBranch(resolvedPath, dir, a);
                    }).then(function() {
                        return result.setActiveBranch("activeSim", resolvedPath);
                    }).then(function() {
                        return a.get("tutorial/" + $scope.$routeParams.section);
                    }).then(function(options) {
                        var name = options.objects;
                        _.find(name, {type: "controller"}).user = scope.Game.player;
                        _.find(name, {type: "spawn"}).user = scope.Game.player;
                        _.filter(name, {type: "creep"}).forEach(function(comment) {
                            return comment.user = /invader/.test(comment.name)
                                ? "2"
                                : scope.Game.player;
                        });
                        _.filter(name, {type: "constructionSite"}).forEach(function(result) {
                            return result.user = scope.Game.player;
                        });
                        _.filter(name, {type: "extension"}).forEach(function(result) {
                            return result.user = scope.Game.player;
                        });
                        b.start();
                        self.put("rooms.objects", name);
                        self.put("rooms.flags", []);
                        self.put("rooms.terrain", options.terrain);
                        self.put("gametime", 0);
                        self.put("gameinfo", {});
                        r.initReplay(null);
                        obj.play();
                        scope.$on("$destroy", function() {
                            return b.resetStep();
                        });
                    });
                } else {
                    if ("survival" == id) {
                        /** @type {string} */
                        var storageKey = "survival";
                        /** @type {null} */
                        scope.Game.survivalMap = null;
                        a.get(storageKey).then(function(options) {
                            /** @type {string} */
                            scope.Game.survivalMap = storageKey;
                            /** @type {boolean} */
                            scope.Game.playDisabled = true;
                            /** @type {boolean} */
                            scope.Game.readOnly = true;
                            self.put("rooms.objects", options.objects);
                            self.put("rooms.flags", []);
                            self.put("rooms.terrain", options.terrain);
                            self.put("gametime", 0);
                            self.put("gameinfo", {
                                mode: "survival",
                                status: "active",
                                user: scope.Game.player,
                                score: 0,
                                timeToWave: 200,
                                wave: 1,
                                survivalEnabled: true,
                                invaders: {
                                    bodies: []
                                }
                            });
                            self.put("replay", {
                                current: [],
                                log: {}
                            });
                            r.initReplay(null);
                            b.trigger("survivalModeStarted");
                        });
                    } else {
                        if ("custom" == id) {
                            self.put("rooms.terrain", []);
                            a.get("custom").then(function(options) {
                                _.find(options.objects, {type: "controller"}).user = scope.Game.player;
                                self.put("rooms.objects", options.objects);
                                self.put("rooms.flags", []);
                                self.put("rooms.terrain", options.terrain);
                                self.put("gametime", 0);
                                self.put("gameinfo", {});
                                r.initReplay(null);
                                obj.play();
                                b.trigger("customModeStarted");
                            });
                        }
                    }
                }
            };
            /**
                 * @return {undefined}
                 */
            this.clearGame = function() {
                /** @type {null} */
                obj.survivalScore = null;
                /** @type {null} */
                obj.simulationMode = null;
                /** @type {null} */
                obj.survivalMap = null;
                /** @type {null} */
                obj.replayLoaded = null;
                $location.url("/");
            };
            /**
                 * @return {undefined}
                 */
            this.playSurvivalAgain = function() {
                if (obj.survivalMap) {
                    /** @type {null} */
                    obj.survivalScore = null;
                    obj.setSimulationMode("survival");
                }
            };
            /**
                 * @param {string} i
                 * @return {undefined}
                 */
            this.saveSurvivalScore = function(i) {
                if (obj.survivalScore = i, obj.pause(), obj.speed = 100, r.setTickPeriod(1E5 / obj.speed), $scope.$routeParams.replay) {
                    obj.survivalReplayUploaded = {
                        _id: $scope.$routeParams.replay,
                        secret: $location.search().s
                    };
                } else {
                    /** @type {boolean} */
                    obj.survivalReplayUploaded = false;
                    var options = self.get("replay");
                    $.post("replays/add", {
                        map: obj.survivalMap,
                        score: i,
                        v: "1479290327467",
                        log: pako.gzip(JSON.stringify(options.log), {
                            level: 9,
                            to: "string"
                        })
                    }).then(function(id) {
                        return obj.survivalReplayUploaded = id;
                    })["catch"](function() {
                        return obj.survivalReplayUploaded = "error";
                    });
                }
            };
            /**
                 * @return {undefined}
                 */
            this.goToIndex = function() {
                $location.url("/sim");
            };
            /**
                 * @return {undefined}
                 */
            this.loadReplay = function() {
                if ("top.game-room-history" == $scope.name) {
                    $.get("game/time").then(function(e) {
                        /** @type {number} */
                        obj.historyMaxGameTime = 20 * Math.floor((e.time - 50) / 20) - 1;
                        /** @type {number} */
                        obj.historyMinGameTime = 20 * Math.floor((e.time - 2E5) / 20);
                        /** @type {null} */
                        obj.survivalScore = null;
                        /** @type {boolean} */
                        obj.replayLoaded = true;
                        /** @type {boolean} */
                        obj.readOnly = true;
                        /** @type {string} */
                        obj.simulationMode = "history";
                        /** @type {number} */
                        obj.speed = 500;
                        r.setTickPeriod(1E5 / obj.speed);
                        r.initReplay({}, scope);
                    });
                }
            };
            /**
                 * @return {undefined}
                 */
            this.exitHistory = function() {
                $location.url($scope.getSegmentUrl("top.game-room"));
            };
            /**
                 * @param {number} topOffset
                 * @return {undefined}
                 */
            this.rewindHistory = function(topOffset) {
                $location.replace();
                $location.search("t", parseInt(time.t) + topOffset);
            };
            /** @type {number} */
            this.historyTickValue = 0;
            var throttledUpdate = _.debounce(function() {
                $location.replace();
                $location.search("t", 20 * obj.historyTickValue);
            }, 200);
            /**
                 * @return {undefined}
                 */
            this.historyTickChange = function() {
                obj.pause();
                throttledUpdate();
            };
            scope.$watch(function() {
                return time.t;
            }, function(m1) {
                return obj.historyTickValue = Math.floor(parseInt(m1) / 20);
            });
            scope.$on("gameSimulationReset", function() {
                return obj.simulationReset();
            });
            scope.$on("$destroy", function() {
                self.remove("rooms.objects");
                self.remove("rooms.flags");
                self.remove("rooms.terrain");
            });
            scope.$watch(function() {
                return obj.player;
            }, function(deepDataAndEvents) {
                if ($templateCache.get("editor-popup", {}).appInstanceId == dataAndEvents) {
                    $templateCache.put("editor-popup", {
                        player: obj.player,
                        appInstanceId: dataAndEvents
                    });
                }
            });
            $transition(500).then(function() {
                if ("top.game-room-history" == $scope.name) {
                    obj.loadReplay();
                }
                if ("top.sim-survival" == $scope.name) {
                    obj.setSimulationMode("survival");
                    mixpanel.track("Start mode: survival");
                    ga("send", "event", "Simulation", "Start survival");
                }
                if ("top.sim-custom" == $scope.name) {
                    obj.setSimulationMode("custom");
                    mixpanel.track("Start mode: custom");
                    ga("send", "event", "Simulation", "Start custom");
                }
                if ("top.sim-tutorial" == $scope.name) {
                    obj.setSimulationMode("tutorial");
                }
            });
        }
    ]),
    module.controller("Top.Game.ChooseMap", [
        "$scope",
        "StaticMaps",
        "MemoryStorage",
        "Connection",
        "Tutorial",
        function(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {}
    ]),
    module.factory("RoomGameLoader", [
        "Loader",
        "Api",
        "$routeParams",
        "$q",
        function($provide, $http, data, $q) {
            return $provide.factory(function() {
                var a = data.room.match(/^survival_(.*)$/);
                return {
                    game: a
                        ? $http.get("survival/game", {id: a[1]})["catch"](function() {
                            return null;
                        })
                        : $q.when(false)
                };
            });
        }
    ]),
    module.controller("Top.RoomGame", [
        "$scope",
        "Auth",
        "Connection",
        "Socket",
        "$routeSegment",
        "$location",
        "Api",
        "$interval",
        "data",
        "$modal",
        "Dialogs",
        "LocalStorage",
        "ArenaActivator",
        "Tutorial",
        "$routeParams",
        "WorldRespawnChecker",
        function(last, item, stack, dataAndEvents, res, d, socket, method, message, $modal, $controllerProvider, deepDataAndEvents, exports, ignoreMethodDoesntExist, data, next) {
            var o = this;
            item.required(last);
            /** @type {boolean} */
            this.readOnly = true;
            last.$watch(function() {
                return data.room;
            }, function() {
                /** @type {null} */
                o.survivalScore = null;
                /** @type {null} */
                o.arenaFinishScore = null;
                /** @type {boolean} */
                o.roomError = false;
            });
            this.player = item.Me._id;
            stack.setRunningLocal(false);
            stack.listenSocket(last);
            this.play = angular.noop;
            this.pause = angular.noop;
            /** @type {number} */
            this.speed = socket.options.official
                ? 50
                : 100;
            /**
                 * @param {string} lvl
                 * @return {undefined}
                 */
            this.saveSurvivalScore = function(lvl) {
                /** @type {string} */
                o.survivalScore = lvl;
                /** @type {boolean} */
                o.survivalReplayUploaded = false;
                var b = data.room.match(/^survival_(.*)$/);
                var gameUid = (b[0], b[1]);
                /**
                     * @return {undefined}
                     */
                var message = function() {
                    socket.get("survival/replay", {game: gameUid}).then(function(lvl) {
                        if (lvl.uploaded) {
                            if (msg) {
                                method.cancel(msg);
                            }
                            /** @type {Function} */
                            o.survivalReplayUploaded = lvl;
                        }
                    });
                };
                var msg = method(message, 1E3);
                message();
            };
            /**
                 * @return {undefined}
                 */
            this.clearGame = function() {
                d.url("/g");
            };
            /**
                 * @return {?}
                 */
            this.playSurvivalAgain = function() {
                return socket.post("survival/create").then(function(room) {
                    d.url("/room/" + room.roomName);
                });
            };
            /**
                 * @return {?}
                 */
            this.playArenaAgain = function() {
                return socket.get("arena/find-init-room").then(function(connection) {
                    d.url(res.getSegmentUrl("top.game-room", {room: connection.room}));
                });
            };
            /**
                 * @return {?}
                 */
            this.isSubscribeError = function() {
                return stack.roomSubscribeError;
            };
            if (message.game) {
                if ("finished" == message.game.status) {
                    this.saveSurvivalScore(message.game.score);
                }
            }
            if (data.room.match(/^arena/)) {
                this.arena = {
                    rooms: [
                        [
                            "arena11", "arena21", "arena31"
                        ],
                        [
                            "arena12", "arena22", "arena32"
                        ],
                        ["arena13", "arena23", "arena33"]
                    ]
                };
                if (item.Me) {
                    socket.get("arena/status").then(function(jqXHR) {
                        if ("not active" == jqXHR.status) {
                            $modal.open({templateUrl: "components/game/dlg-tip-arena.html?bust=1479290327467", controller: $controllerProvider.Ctrl}).result.then(function() {
                                return exports.run(true);
                            });
                        }
                    });
                }
            }
            next.bind(last);
        }
    ]), {};
}();
var $__app_95_components_47_game_47_lobby_47_arena_47_lobby_45_arena__ = function() {
    var module = angular.module("app.game.lobby.arena", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/g/arena", "top.game-lobby-arena-no-season").when("/g/arena/:season", "top.game-lobby-arena.list").within("top").segment("game-lobby-arena-no-season", {
                resolve: {
                    data: ngInject([
                        "Api",
                        "$location",
                        "$routeSegment",
                        function($templateCache, $location, dataAndEvents) {
                            return $templateCache.get("leaderboard/seasons", {mode: "arena"}).then(function(r) {
                                $location.replace();
                                $location.url(dataAndEvents.getSegmentUrl("top.game-lobby-arena.list", {season: r.seasons[0]._id}));
                            });
                        }
                    ])
                }
            }).segment("game-lobby-arena", {
                templateUrl: "components/game/lobby/arena/lobby-arena.html?bust=1479290327467",
                controller: "Top.LobbyArena as LobbyArena",
                dependencies: ["season"],
                resolve: {
                    data: ngInject([
                        "LobbyArenaLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            }).within().segment("list", {
                controller: "Top.LobbyArena.LeaderboardList as LeaderboardList",
                dependencies: ["page"],
                resolve: {
                    data: ngInject([
                        "ArenaLeaderboardListLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("LobbyArenaLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, player, err, item, $scope, $q, $timeout) {
            return $provide.factory(function() {
                return err.Me && (_.isUndefined(item.page) && $timeout(angular.noop, 10).then(function() {
                    return player.get("leaderboard/find", {
                        mode: "arena",
                        season: item.season,
                        username: err.Me.username
                    });
                }).then(function(b) {
                    $scope.replace();
                    $scope.search("page", Math.floor(b.rank / 10) + 1);
                    $scope.search("highlight", err.Me.username);
                })["catch"](function() {
                    $scope.replace();
                    $scope.search("page", 1);
                })), {
                    seasons: player.get("leaderboard/seasons").then(function(r) {
                        return r.seasons;
                    }),
                    gameId: err.Me
                        ? player.get("survival/active-game").then(function(event) {
                            return event
                                ? event.gameId
                                : void 0;
                        })["catch"](function(dataAndEvents) {
                            return null;
                        })
                        : $q.when(),
                    myResult: err.Me
                        ? player.get("leaderboard/find", {
                            mode: "arena",
                            season: item.season,
                            username: err.Me.username
                        })["catch"](function() {
                            return null;
                        })
                        : $q.when()
                };
            });
        }
    ]),
    module.controller("Top.LobbyArena", [
        "$scope",
        "Auth",
        "Api",
        "$location",
        "data",
        "$routeParams",
        "$routeSegment",
        "Loader",
        "$q",
        "Tutorial",
        function($scope, post, player, $location, r, dataAndEvents, req, appLoading, $q, selectedElement) {
            var t = this;
            /** @type {string} */
            this.search = "";
            this.myResult = r.myResult;
            this.seasonsList = r.seasons;
            this.season = _.find(this.seasonsList, {_id: req.$routeParams.season});
            if (this.myResult) {
                /** @type {number} */
                this.myResult.page = Math.floor(this.myResult.rank / 10) + 1;
            }
            /**
                 * @return {?}
                 */
            this.start = function() {
                return post.Me && !post.Me.email
                    ? void $location.url(req.getSegmentUrl("top.register-confirm"))
                    : player.get("arena/find-init-room").then(function(connection) {
                        $location.url(req.getSegmentUrl("top.game-room", {room: connection.room}));
                    });
            };
            /**
                 * @return {?}
                 */
            this.submitSearch = function() {
                var expectedNumberOfNonCommentArgs = t.search;
                return !expectedNumberOfNonCommentArgs || expectedNumberOfNonCommentArgs.length < 5
                    ? $q.reject()
                    : appLoading.loading(player.get("leaderboard/find", {
                        mode: "arena",
                        season: t.season._id,
                        username: expectedNumberOfNonCommentArgs
                    }).then(function(b) {
                        $location.search("highlight", expectedNumberOfNonCommentArgs);
                        $location.search("page", Math.floor(b.rank / 10) + 1);
                    }));
            };
            $scope.$watch(function() {
                return req.$routeParams.page;
            }, function(dataAndEvents) {
                if (!dataAndEvents) {
                    $location.replace();
                    $location.search("page", 1);
                }
            });
            selectedElement.trigger("gameLobby");
        }
    ]),
    module.factory("ArenaLeaderboardListLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        function($provide, player, dataAndEvents, inputs) {
            return $provide.factory(function() {
                return new Object({
                    listData: player.get("leaderboard/list", {
                        mode: "arena",
                        season: inputs.season,
                        offset: 10 * (inputs.page - 1),
                        limit: 10
                    })
                });
            });
        }
    ]),
    module.controller("Top.LobbyArena.LeaderboardList", [
        "$scope",
        "Api",
        "data",
        "$routeParams",
        "$location",
        "$routeSegment",
        function($scope, dataAndEvents, req, event, deepDataAndEvents, ignoreMethodDoesntExist) {
            var opt = this;
            this.list = req.listData.list;
            this.users = req.listData.users;
            this.count = req.listData.count;
            /** @type {number} */
            var count = this.pageSize = 10;
            /** @type {Array} */
            this.pages = [];
            /** @type {number} */
            var i = Math.max(0, event.page - 1 - 2);
            for (; i <= Math.min(Math.floor((this.count - 1) / count), event.page - 1 + 2); i++) {
                this.pages.push({
                    num: i + 1,
                    active: i == event.page - 1
                });
            }
            /** @type {(boolean|number)} */
            this.startPage = event.page > 1
                ? 1
                : false;
            /** @type {(boolean|number)} */
            this.endPage = event.page < Math.floor(this.count / count)
                ? Math.floor((this.count - 1) / count) + 1
                : false;
            /** @type {(boolean|number)} */
            this.prevPage = event.page > 1
                ? parseInt(event.page) - 1
                : false;
            /** @type {(boolean|number)} */
            this.nextPage = event.page < Math.floor(this.count / count)
                ? parseInt(event.page) + 1
                : false;
            $scope.$watch(function() {
                return event.highlight;
            }, function(highlight) {
                return opt.highlight = highlight;
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_lobby_47_game_45_lobby__ = function() {
    var module = angular.module("app.game.lobby", []);
    return module.config([
        "$routeSegmentProvider",
        "$routeProvider",
        function(b, $routeProvider) {
            b.when("/g", "top.game-lobby").within("top").segment("game-lobby", {
                templateUrl: "components/game/lobby/game-lobby.html?bust=1479290327467",
                controller: "Top.GameLobby as GameLobby",
                dependencies: ["season"],
                resolve: {
                    data: ngInject([
                        "GameLobbyLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
            $routeProvider.when("/g", {redirectTo: "/map"});
        }
    ]),
    module.factory("GameLobbyLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        function($provide, player, err, dataAndEvents, deepDataAndEvents, $q) {
            return $provide.factory(function() {
                var promise = player.get("leaderboard/seasons").then(function(r) {
                    return r.seasons;
                });
                var myResults = err.Me
                    ? promise.then(function(docs) {
                        return $q.all({
                            survival: player.get("leaderboard/find", {
                                mode: "survival",
                                season: docs[0]._id,
                                username: err.Me.username
                            })["catch"](function() {
                                return null;
                            }),
                            arena: player.get("leaderboard/find", {
                                mode: "arena",
                                season: docs[0]._id,
                                username: err.Me.username
                            })["catch"](function() {
                                return null;
                            })
                        });
                    })
                    : $q.when();
                return {seasons: promise, myResults: myResults};
            });
        }
    ]),
    module.controller("Top.GameLobby", [
        "$scope",
        "Auth",
        "Api",
        "$location",
        "data",
        "$routeParams",
        "$routeSegment",
        "Loader",
        "$q",
        "Dialogs",
        "Tutorial",
        "AccountSaveRedirector",
        function(deepDataAndEvents, e, ignoreMethodDoesntExist, $location, r, textAlt, dataAndEvents, keepData, opt_attributes, $window, selectedElement, namespace) {
            if (e.Me) {
                if (!e.Me.badge) {
                    namespace.set("top.game-lobby");
                    $location.url(dataAndEvents.getSegmentUrl("top.account-badge"));
                }
            }
            this.myResults = r.myResults;
            this.seasons = r.seasons;
            /**
                 * @return {undefined}
                 */
            this.disabledModeClick = function() {
                $window.alert("In Development", {html: 'This game mode is still in development.<br><a target="_blank" href="https://indiegogo.com/projects/screeps/" app-nw-external-link>Learn more&hellip;</a>'});
            };
            selectedElement.trigger("gameLobby");
        }
    ]), {};
}();
var $__app_95_components_47_game_47_lobby_47_power_47_lobby_45_power__ = function() {
    var module = angular.module("app.game.lobby.power", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/rank/power", "top.game-lobby-power-no-season").when("/rank/power/:season", "top.game-lobby-power.list").within("top").segment("game-lobby-power-no-season", {
                resolve: {
                    data: ngInject([
                        "Api",
                        "$location",
                        "$routeSegment",
                        function($templateCache, $location, dataAndEvents) {
                            return $templateCache.get("leaderboard/seasons", {mode: "power"}).then(function(r) {
                                $location.replace();
                                $location.url(dataAndEvents.getSegmentUrl("top.game-lobby-power.list", {season: r.seasons[0]._id}));
                            });
                        }
                    ])
                }
            }).segment("game-lobby-power", {
                templateUrl: "components/game/lobby/power/lobby-power.html?bust=1479290327467",
                controller: "Top.LobbyPower as LobbyPower",
                dependencies: ["season"],
                resolve: {
                    data: ngInject([
                        "LobbyPowerLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            }).within().segment("list", {
                controller: "Top.LobbyPower.LeaderboardList as LeaderboardList",
                dependencies: ["page"],
                resolve: {
                    data: ngInject([
                        "PowerLeaderboardListLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("LobbyPowerLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, player, err, item, model, $q, $timeout) {
            return $provide.factory(function() {
                return err.Me && (_.isUndefined(item.page) && $timeout(angular.noop, 10).then(function() {
                    return player.get("leaderboard/find", {
                        mode: "power",
                        season: item.season,
                        username: err.Me.username
                    });
                }).then(function(result) {
                    model.replace();
                    model.search("page", Math.floor(result.rank / 10) + 1);
                    model.search("highlight", result.rank);
                })["catch"](function() {
                    model.replace();
                    model.search("page", 1);
                })), {
                    seasons: player.get("leaderboard/seasons").then(function(r) {
                        return r.seasons;
                    }),
                    myResult: err.Me
                        ? player.get("leaderboard/find", {
                            mode: "power",
                            season: item.season,
                            username: err.Me.username
                        })["catch"](function() {
                            return null;
                        })
                        : $q.when()
                };
            });
        }
    ]),
    module.controller("Top.LobbyPower", [
        "$scope",
        "Auth",
        "Api",
        "$location",
        "data",
        "$routeParams",
        "$routeSegment",
        "Loader",
        "$q",
        "Tutorial",
        function($scope, dataAndEvents, player, model, r, deepDataAndEvents, req, appLoading, $q, selectedElement) {
            var t = this;
            /** @type {string} */
            this.search = "";
            this.myResult = r.myResult;
            this.seasonsList = r.seasons;
            this.season = _.find(this.seasonsList, {_id: req.$routeParams.season});
            if (this.myResult) {
                /** @type {number} */
                this.myResult.page = Math.floor(this.myResult.rank / 10) + 1;
            }
            /**
                 * @return {?}
                 */
            this.submitSearch = function() {
                var h = t.search;
                return !h || h.length < 5
                    ? $q.reject()
                    : appLoading.loading(player.get("leaderboard/find", {
                        mode: "power",
                        season: t.season._id,
                        username: h
                    }).then(function(result) {
                        model.search("highlight", result.rank);
                        model.search("page", Math.floor(result.rank / 10) + 1);
                    }));
            };
            $scope.$watch(function() {
                return req.$routeParams.page;
            }, function(dataAndEvents) {
                if (!dataAndEvents) {
                    model.replace();
                    model.search("page", 1);
                }
            });
            selectedElement.trigger("gameLobby");
        }
    ]),
    module.factory("PowerLeaderboardListLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        function($provide, player, dataAndEvents, inputs) {
            return $provide.factory(function() {
                return new Object({
                    listData: player.get("leaderboard/list", {
                        mode: "power",
                        season: inputs.season,
                        offset: 10 * (inputs.page - 1),
                        limit: 10
                    })
                });
            });
        }
    ]),
    module.controller("Top.LobbyPower.LeaderboardList", [
        "$scope",
        "Api",
        "data",
        "$routeParams",
        "$location",
        "$routeSegment",
        function($scope, dataAndEvents, req, event, deepDataAndEvents, ignoreMethodDoesntExist) {
            var opt = this;
            this.list = req.listData.list;
            this.users = req.listData.users;
            this.count = req.listData.count;
            /** @type {number} */
            var count = this.pageSize = 10;
            /** @type {Array} */
            this.pages = [];
            /** @type {number} */
            var i = Math.max(0, event.page - 1 - 2);
            for (; i <= Math.min(Math.floor((this.count - 1) / count), event.page - 1 + 2); i++) {
                this.pages.push({
                    num: i + 1,
                    active: i == event.page - 1
                });
            }
            /** @type {(boolean|number)} */
            this.startPage = event.page > 1
                ? 1
                : false;
            /** @type {(boolean|number)} */
            this.endPage = event.page < Math.floor(this.count / count)
                ? Math.floor((this.count - 1) / count) + 1
                : false;
            /** @type {(boolean|number)} */
            this.prevPage = event.page > 1
                ? parseInt(event.page) - 1
                : false;
            /** @type {(boolean|number)} */
            this.nextPage = event.page < Math.floor(this.count / count)
                ? parseInt(event.page) + 1
                : false;
            $scope.$watch(function() {
                return event.highlight;
            }, function(highlight) {
                return opt.highlight = highlight;
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_lobby_47_survival_47_lobby_45_survival__ = function() {
    var module = angular.module("app.game.lobby.survival", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/g/survival", "top.game-lobby-survival-no-season").when("/g/survival/:season", "top.game-lobby-survival.list").within("top").segment("game-lobby-survival-no-season", {
                resolve: {
                    data: ngInject([
                        "Api",
                        "$location",
                        "$routeSegment",
                        function($templateCache, $location, dataAndEvents) {
                            return $templateCache.get("leaderboard/seasons", {mode: "survival"}).then(function(r) {
                                $location.replace();
                                $location.url(dataAndEvents.getSegmentUrl("top.game-lobby-survival.list", {season: r.seasons[0]._id}));
                            });
                        }
                    ])
                }
            }).segment("game-lobby-survival", {
                templateUrl: "components/game/lobby/survival/lobby-survival.html?bust=1479290327467",
                controller: "Top.LobbySurvival as LobbySurvival",
                dependencies: ["season"],
                resolve: {
                    data: ngInject([
                        "LobbySurvivalLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            }).within().segment("list", {
                controller: "Top.LobbySurvival.LeaderboardList as LeaderboardList",
                dependencies: ["page"],
                resolve: {
                    data: ngInject([
                        "SurvivalLeaderboardListLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("LobbySurvivalLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, player, err, item, $scope, $q, $timeout) {
            return $provide.factory(function() {
                return err.Me && (_.isUndefined(item.page) && $timeout(angular.noop, 10).then(function() {
                    return player.get("leaderboard/find", {
                        mode: "survival",
                        season: item.season,
                        username: err.Me.username
                    });
                }).then(function(b) {
                    $scope.replace();
                    $scope.search("page", Math.floor(b.rank / 10) + 1);
                    $scope.search("highlight", err.Me.username);
                })["catch"](function() {
                    $scope.replace();
                    $scope.search("page", 1);
                })), {
                    seasons: player.get("leaderboard/seasons").then(function(r) {
                        return r.seasons;
                    }),
                    gameId: err.Me
                        ? player.get("survival/active-game").then(function(event) {
                            return event
                                ? event.gameId
                                : void 0;
                        })["catch"](function(dataAndEvents) {
                            return null;
                        })
                        : $q.when(),
                    myResult: err.Me
                        ? player.get("leaderboard/find", {
                            mode: "survival",
                            season: item.season,
                            username: err.Me.username
                        })["catch"](function() {
                            return null;
                        })
                        : $q.when()
                };
            });
        }
    ]),
    module.controller("Top.LobbySurvival", [
        "$scope",
        "Auth",
        "Api",
        "$location",
        "data",
        "$routeParams",
        "$routeSegment",
        "Loader",
        "$q",
        "Tutorial",
        function($scope, options, cl, $location, t, dataAndEvents, req, appLoading, $q, selectedElement) {
            var item = this;
            this.activeGameId = t.gameId;
            /** @type {string} */
            this.search = "";
            this.myResult = t.myResult;
            this.seasonsList = t.seasons;
            this.season = _.find(this.seasonsList, {_id: req.$routeParams.season});
            if (this.myResult) {
                /** @type {number} */
                this.myResult.page = Math.floor(this.myResult.rank / 10) + 1;
            }
            /**
                 * @return {?}
                 */
            this.start = function() {
                return item.activeGameId && options.Me
                    ? void $location.url("/room/survival_" + item.activeGameId)
                    : (options.Me && (!options.Me.email && $location.url(req.getSegmentUrl("top.register-confirm"))), cl.post("survival/create").then(function(room) {
                        $location.url("/room/" + room.roomName);
                    }));
            };
            /**
                 * @return {?}
                 */
            this.submitSearch = function() {
                var expectedNumberOfNonCommentArgs = item.search;
                return !expectedNumberOfNonCommentArgs || expectedNumberOfNonCommentArgs.length < 5
                    ? $q.reject()
                    : appLoading.loading(cl.get("leaderboard/find", {
                        mode: "survival",
                        season: item.season._id,
                        username: expectedNumberOfNonCommentArgs
                    }).then(function(b) {
                        $location.search("highlight", expectedNumberOfNonCommentArgs);
                        $location.search("page", Math.floor(b.rank / 10) + 1);
                    }));
            };
            $scope.$watch(function() {
                return req.$routeParams.page;
            }, function(dataAndEvents) {
                if (!dataAndEvents) {
                    $location.replace();
                    $location.search("page", 1);
                }
            });
            selectedElement.trigger("gameLobby");
        }
    ]),
    module.factory("SurvivalLeaderboardListLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        function($provide, player, dataAndEvents, inputs) {
            return $provide.factory(function() {
                return new Object({
                    listData: player.get("leaderboard/list", {
                        mode: "survival",
                        season: inputs.season,
                        offset: 10 * (inputs.page - 1),
                        limit: 10
                    })
                });
            });
        }
    ]),
    module.controller("Top.LobbySurvival.LeaderboardList", [
        "$scope",
        "Api",
        "data",
        "$routeParams",
        "$location",
        "$routeSegment",
        function($scope, user, req, event, $location, dataAndEvents) {
            var opt = this;
            this.list = req.listData.list;
            this.users = req.listData.users;
            this.count = req.listData.count;
            /** @type {number} */
            var count = this.pageSize = 10;
            /** @type {Array} */
            this.pages = [];
            /** @type {number} */
            var i = Math.max(0, event.page - 1 - 2);
            for (; i <= Math.min(Math.floor((this.count - 1) / count), event.page - 1 + 2); i++) {
                this.pages.push({
                    num: i + 1,
                    active: i == event.page - 1
                });
            }
            /** @type {(boolean|number)} */
            this.startPage = event.page > 1
                ? 1
                : false;
            /** @type {(boolean|number)} */
            this.endPage = event.page < Math.floor(this.count / count)
                ? Math.floor((this.count - 1) / count) + 1
                : false;
            /** @type {(boolean|number)} */
            this.prevPage = event.page > 1
                ? parseInt(event.page) - 1
                : false;
            /** @type {(boolean|number)} */
            this.nextPage = event.page < Math.floor(this.count / count)
                ? parseInt(event.page) + 1
                : false;
            /**
                 * @param {?} enterResults
                 * @return {?}
                 */
            this.loadReplay = function(enterResults) {
                return user.get("survival/replay", {game: enterResults.game}).then(function(created) {
                    if (created) {
                        $location.url(dataAndEvents.getSegmentUrl("top.replay", {replay: created._id}) + "?s=" + created.secret);
                    }
                });
            };
            $scope.$watch(function() {
                return event.highlight;
            }, function(highlight) {
                return opt.highlight = highlight;
            });
        }
    ]),
    module.directive("appEnlargeOnClick", [
        "$window",
        "$timeout",
        "$animate",
        function(el, $anchorScroll, $animate) {
            return {
                /**
                     * @param {?} tabCtrl
                     * @param {Object} scope
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(tabCtrl, scope, attrs) {
                    /**
                         * @return {undefined}
                         */
                    function update() {
                        /** @type {boolean} */
                        perm = !perm;
                        var pos = scope.offset();
                        if (perm) {
                            /** @type {number} */
                            var dim = 386;
                            /** @type {number} */
                            var originalLeft_ = ($(el).width() - dim) / 2;
                            /** @type {number} */
                            var el_t = ($(el).height() - dim) / 2;
                            scope.find("img").css({
                                left: pos.left + "px",
                                top: pos.top + "px"
                            });
                            $anchorScroll(function() {
                                scope.find("img").addClass("animated");
                                scope.find("img").css({
                                    left: originalLeft_ + "px",
                                    top: el_t + "px",
                                    width: dim + "px",
                                    height: dim + "px"
                                });
                                $animate.removeClass(scope.find(".cover"), "ng-hide");
                            }, 10);
                        } else {
                            scope.find("img").css({
                                left: pos.left + "px",
                                top: pos.top + "px",
                                width: "80px",
                                height: "80px"
                            });
                            $animate.addClass(scope.find(".cover"), "ng-hide");
                            $anchorScroll(function() {
                                return scope.find("img").removeClass("animated");
                            }, 300);
                        }
                    }
                    /** @type {boolean} */
                    var perm = false;
                    scope.click(update);
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_lobby_47_world_47_lobby_45_world__ = function() {
    var module = angular.module("app.game.lobby.world", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/rank/world", "top.game-lobby-world-no-season").when("/rank/world/:season", "top.game-lobby-world.list").within("top").segment("game-lobby-world-no-season", {
                resolve: {
                    data: ngInject([
                        "Api",
                        "$location",
                        "$routeSegment",
                        function($templateCache, $location, dataAndEvents) {
                            return $templateCache.get("leaderboard/seasons", {mode: "world"}).then(function(r) {
                                $location.replace();
                                $location.url(dataAndEvents.getSegmentUrl("top.game-lobby-world.list", {season: r.seasons[0]._id}));
                            });
                        }
                    ])
                }
            }).segment("game-lobby-world", {
                templateUrl: "components/game/lobby/world/lobby-world.html?bust=1479290327467",
                controller: "Top.LobbyWorld as LobbyWorld",
                dependencies: ["season"],
                resolve: {
                    data: ngInject([
                        "LobbyWorldLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            }).within().segment("list", {
                controller: "Top.LobbyWorld.LeaderboardList as LeaderboardList",
                dependencies: ["page"],
                resolve: {
                    data: ngInject([
                        "WorldLeaderboardListLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("LobbyWorldLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, player, err, item, model, $q, $timeout) {
            return $provide.factory(function() {
                return err.Me && (_.isUndefined(item.page) && $timeout(angular.noop, 10).then(function() {
                    return player.get("leaderboard/find", {
                        mode: "world",
                        season: item.season,
                        username: err.Me.username
                    });
                }).then(function(result) {
                    model.replace();
                    model.search("page", Math.floor(result.rank / 10) + 1);
                    model.search("highlight", result.rank);
                })["catch"](function() {
                    model.replace();
                    model.search("page", 1);
                })), {
                    seasons: player.get("leaderboard/seasons").then(function(r) {
                        return r.seasons;
                    }),
                    myResult: err.Me
                        ? player.get("leaderboard/find", {
                            mode: "world",
                            season: item.season,
                            username: err.Me.username
                        })["catch"](function() {
                            return null;
                        })
                        : $q.when()
                };
            });
        }
    ]),
    module.controller("Top.LobbyWorld", [
        "$scope",
        "Auth",
        "Api",
        "$location",
        "data",
        "$routeParams",
        "$routeSegment",
        "Loader",
        "$q",
        "Tutorial",
        function($scope, dataAndEvents, player, model, r, deepDataAndEvents, req, appLoading, $q, selectedElement) {
            var t = this;
            /** @type {string} */
            this.search = "";
            this.myResult = r.myResult;
            this.seasonsList = r.seasons;
            this.season = _.find(this.seasonsList, {_id: req.$routeParams.season});
            if (this.myResult) {
                /** @type {number} */
                this.myResult.page = Math.floor(this.myResult.rank / 10) + 1;
            }
            /**
                 * @return {?}
                 */
            this.submitSearch = function() {
                var h = t.search;
                return !h || h.length < 5
                    ? $q.reject()
                    : appLoading.loading(player.get("leaderboard/find", {
                        mode: "world",
                        season: t.season._id,
                        username: h
                    }).then(function(result) {
                        model.search("highlight", result.rank);
                        model.search("page", Math.floor(result.rank / 10) + 1);
                    }));
            };
            $scope.$watch(function() {
                return req.$routeParams.page;
            }, function(dataAndEvents) {
                if (!dataAndEvents) {
                    model.replace();
                    model.search("page", 1);
                }
            });
            selectedElement.trigger("gameLobby");
        }
    ]),
    module.factory("WorldLeaderboardListLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        function($provide, player, dataAndEvents, inputs) {
            return $provide.factory(function() {
                return new Object({
                    listData: player.get("leaderboard/list", {
                        mode: "world",
                        season: inputs.season,
                        offset: 10 * (inputs.page - 1),
                        limit: 10
                    })
                });
            });
        }
    ]),
    module.controller("Top.LobbyWorld.LeaderboardList", [
        "$scope",
        "Api",
        "data",
        "$routeParams",
        "$location",
        "$routeSegment",
        function($scope, dataAndEvents, req, event, deepDataAndEvents, ignoreMethodDoesntExist) {
            var opt = this;
            this.list = req.listData.list;
            this.users = req.listData.users;
            this.count = req.listData.count;
            /** @type {number} */
            var count = this.pageSize = 10;
            /** @type {Array} */
            this.pages = [];
            /** @type {number} */
            var i = Math.max(0, event.page - 1 - 2);
            for (; i <= Math.min(Math.floor((this.count - 1) / count), event.page - 1 + 2); i++) {
                this.pages.push({
                    num: i + 1,
                    active: i == event.page - 1
                });
            }
            /** @type {(boolean|number)} */
            this.startPage = event.page > 1
                ? 1
                : false;
            /** @type {(boolean|number)} */
            this.endPage = event.page < Math.floor(this.count / count)
                ? Math.floor((this.count - 1) / count) + 1
                : false;
            /** @type {(boolean|number)} */
            this.prevPage = event.page > 1
                ? parseInt(event.page) - 1
                : false;
            /** @type {(boolean|number)} */
            this.nextPage = event.page < Math.floor(this.count / count)
                ? parseInt(event.page) + 1
                : false;
            $scope.$watch(function() {
                return event.highlight;
            }, function(highlight) {
                return opt.highlight = highlight;
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_market_47_all_45_orders_47_market_45_all_45_orders__ = function() {
    var module = angular.module("app.game.market.all-orders", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/market/all", "top.market.all-orders").when("/market/all/:resourceType", "top.market.all-orders-resource").within("top").within("market").segment("all-orders", {
                "default": true,
                templateUrl: "components/game/market/all-orders/market-all-orders.html?bust=1479290327467",
                controller: "Top.Market.AllOrders as AllOrders",
                resolve: {
                    data: ngInject([
                        "AllOrdersLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            }).segment("all-orders-resource", {
                templateUrl: "components/game/market/all-orders/market-all-orders-resource.html?bust=1479290327467",
                controller: "Top.Market.ResourceOrders as ResourceOrders",
                resolve: {
                    data: ngInject([
                        "ResourceOrdersLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("AllOrdersLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, $templateCache, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
            return $provide.factory(function() {
                return {
                    index: $templateCache.get("game/market/orders-index").then(function(data) {
                        return _.indexBy(data.list, "_id");
                    })
                };
            });
        }
    ]),
    module.controller("Top.Market.AllOrders", [
        "$scope",
        "data",
        "Auth",
        "ResourceTypeNames",
        function(dataAndEvents, data, arg, resources) {
            arg.required();
            /** @type {Array} */
            this.resources = resources;
            this.data = data;
        }
    ]),
    module.factory("ResourceOrdersLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, $templateCache, dataAndEvents, options, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
            return $provide.factory(function() {
                return {
                    orders: $templateCache.get("game/market/orders", {resourceType: options.resourceType}).then(function(element) {
                        return {
                            sell: _.filter(element.list, {type: "sell"}),
                            buy: _.filter(element.list, {type: "buy"})
                        };
                    }),
                    stats: $templateCache.get("game/market/stats", {resourceType: options.resourceType}).then(function(a) {
                        return a.stats;
                    }),
                    worldSize: $templateCache.get("game/world-size")
                };
            });
        }
    ]),
    module.controller("Top.Market.ResourceOrders", [
        "$scope",
        "data",
        "Auth",
        "ResourceTypeNames",
        "ResourceOrdersLoader",
        "$routeSegment",
        "MapUtils",
        "Api",
        function(deepDataAndEvents, data, arg, dataAndEvents, exports, $rootScope, obj, ignoreMethodDoesntExist) {
            var response = this;
            arg.required();
            this.resourceName = dataAndEvents[$rootScope.$routeParams.resourceType];
            this.data = data;
            /** @type {string} */
            this.targetRoom = "";
            /**
                 * @param {string} target
                 * @param {string} type
                 * @return {?}
                 */
            var handler = function(target, type) {
                if (!/^[WE]\d+[NS]\d+$/i.test(type)) {
                    return 0;
                }
                var a = obj.roomNameToXY(target);
                var left = a[0];
                var start = a[1];
                var parts = obj.roomNameToXY(type);
                var right = parts[0];
                var end = parts[1];
                /** @type {number} */
                var x = window.Math.abs(right - left);
                /** @type {number} */
                var height = window.Math.abs(end - start);
                return Math.max(Math.min(response.data.worldSize.width - x, x), Math.min(response.data.worldSize.height - height, height));
            };
            /**
                 * @return {undefined}
                 */
            var resolve = function() {
                response.data.orders.sell.forEach(function($scope) {
                    return $scope.range = handler($scope.roomName, response.targetRoom);
                });
                response.data.orders.buy.forEach(function($scope) {
                    return $scope.range = handler($scope.roomName, response.targetRoom);
                });
            };
            /**
                 * @return {undefined}
                 */
            this.onTargetRoomChange = function() {
                resolve();
            };
            /**
                 * @return {?}
                 */
            this.reload = function() {
                return exports.load().then(resolve);
            };
        }
    ]),
    module.directive("appMarketTable", function() {
        return {
            /**
                 * @return {undefined}
                 */
            controller: function() {
                /** @type {string} */
                this.sort = "";
                /**
                     * @param {string} i
                     * @return {undefined}
                     */
                this.changeSort = function(i) {
                    /** @type {string} */
                    this.sort = this.sort == "+" + i
                        ? "-" + i
                        : "+" + i;
                };
            },
            controllerAs: "MarketTable",
            /**
                 * @param {?} tabCtrl
                 * @param {?} scope
                 * @param {Object} options
                 * @param {Array} attrs
                 * @return {undefined}
                 */
            link: function(tabCtrl, scope, options, attrs) {
                attrs.sort = options.defaultSort;
            }
        };
    }), {};
}();
var $__app_95_components_47_game_47_market_47_history_47_market_45_history__ = function() {
    var module = angular.module("app.game.market.history", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/market/history", "top.market.history").within("top").within("market").segment("history", {
                templateUrl: "components/game/market/history/market-history.html?bust=1479290327467",
                controller: "Top.Market.History as History",
                resolve: {
                    data: ngInject([
                        "HistoryLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("HistoryLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, tabs, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
            return $provide.factory(function(page) {
                return {
                    money: tabs.get("user/money-history", {
                        /** @type {Function} */
                        page: page
                    })
                };
            });
        }
    ]),
    module.controller("Top.Market.History", [
        "$scope",
        "data",
        "HistoryLoader",
        "Auth",
        "ResourceTypeNames",
        function(dataAndEvents, data, exports, arg, deepDataAndEvents) {
            var user = this;
            arg.required();
            this.data = data;
            /**
                 * @return {?}
                 */
            this.reload = function() {
                return exports.load(user.data.money.page);
            };
            /**
                 * @param {?} name
                 * @return {undefined}
                 */
            this.changePage = function(name) {
                exports.load(user.data.money.page + name);
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_market_47_market__ = function() {
    var module = angular.module("app.game.market", []);
    return module.config([
        "$routeSegmentProvider",
        function(result) {
            result.when("/market", "top.market").within("top").segment("market", {templateUrl: "components/game/market/market.html?bust=1479290327467"});
        }
    ]), {};
}();
var $__app_95_components_47_game_47_market_47_my_45_orders_47_market_45_my_45_orders__ = function() {
    var module = angular.module("app.game.market.my-orders", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/market/my", "top.market.my-orders").within("top").within("market").segment("my-orders", {
                templateUrl: "components/game/market/my-orders/market-my-orders.html?bust=1479290327467",
                controller: "Top.Market.MyOrders as MyOrders",
                resolve: {
                    data: ngInject([
                        "MyOrdersLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("MyOrdersLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        function($provide, $templateCache, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
            return $provide.factory(function() {
                return {
                    orders: $templateCache.get("game/market/my-orders").then(function(cl) {
                        return cl.list;
                    })
                };
            });
        }
    ]),
    module.controller("Top.Market.MyOrders", [
        "$scope",
        "data",
        "MyOrdersLoader",
        "Auth",
        "ResourceTypeNames",
        function(deepDataAndEvents, data, exports, arg, dataAndEvents) {
            arg.required();
            this.resourceNames = dataAndEvents;
            this.data = data;
            /**
                 * @return {?}
                 */
            this.reload = function() {
                return exports.load();
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_overview_47_overview__ = function() {
    var module = angular.module("app.game.overview", []);
    return module.config([
        "$routeSegmentProvider",
        function(doc) {
            doc.when("/overview", "top.game-overview").within("top").segment("game-overview", {
                templateUrl: "components/game/overview/overview.html?bust=1479290327467",
                controller: "Top.GameOverview as GameOverview",
                resolve: {
                    data: ngInject([
                        "GameOverviewLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("GameOverviewLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        "LocalStorage",
        function($provide, player, result, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, $templateCache) {
            return $provide.factory(function() {
                var $scope = this;
                var defaults = $templateCache.get("game.overview.displayOptions", {
                    viewMode: "grid",
                    statName: "energyHarvested",
                    statInterval: 8
                });
                var promise = player.get("leaderboard/seasons").then(function(r) {
                    return r.seasons;
                });
                return {
                    auth: result.check(),
                    seasons: promise,
                    leaderboardWorld: promise.then(function(docs) {
                        return player.get("leaderboard/find", {
                            mode: "world",
                            season: docs[0]._id,
                            username: result.Me.username
                        });
                    })["catch"](function() {
                        return null;
                    }),
                    leaderboardPower: promise.then(function(docs) {
                        return player.get("leaderboard/find", {
                            mode: "power",
                            season: docs[0]._id,
                            username: result.Me.username
                        });
                    })["catch"](function() {
                        return null;
                    }),
                    overview: player.get("user/overview", {
                        statName: defaults.statName,
                        interval: defaults.statInterval
                    }).then(function(data) {
                        return $scope.displayOptions = defaults,
                        $scope.max = data.statsMax,
                        data;
                    })
                };
            });
        }
    ]),
    module.controller("Top.GameOverview", [
        "$scope",
        "Api",
        "Auth",
        "Constants",
        "data",
        "$routeSegment",
        "$location",
        "LocalStorage",
        "GameOverviewLoader",
        "$interval",
        function($scope, service, arg, coord, data, res, $location, dataAndEvents, loader, item) {
            var qTypeClass = this;
            arg.required();
            $scope.Math = Math;
            this.data = data;
            this.displayOptions = dataAndEvents.createSyncedObj("game.overview.displayOptions", {
                viewMode: "grid",
                statName: "energyHarvested",
                statInterval: 8,
                statNormalize: false
            });
            if (!service.options.official) {
                /** @type {string} */
                this.displayOptions.viewMode = "grid";
            }
            /** @type {string} */
            this.mapUrl = service.options.official
                ? "https://d3os7yery2usni.cloudfront.net/map3/"
                : "http://" + service.options.host + ":" + service.options.port + "/assets/map/";
            this.loader = loader;
            this.offsetLabels = {
                8: [
                    "-56m",
                    "-48m",
                    "-40m",
                    "-32m",
                    "-24m",
                    "-16m",
                    "-8m",
                    "0"
                ],
                180: [
                    "-21h",
                    "-18h",
                    "-15h",
                    "-12h",
                    "-9h",
                    "-6h",
                    "-3h",
                    "0"
                ],
                1440: [
                    "-6d",
                    "-5d",
                    "-4d",
                    "-3d",
                    "-2d",
                    "-1d",
                    "0"
                ]
            };
            /**
                 * @return {?}
                 */
            this.getGcl = function() {
                return arg.Me.getGcl();
            };
            /**
                 * @return {?}
                 */
            this.getGclBaseProgress = function() {
                return Math.pow(qTypeClass.getGcl() - 1, coord.GCL_POW) * coord.GCL_MULTIPLY;
            };
            /**
                 * @return {?}
                 */
            this.getGclCurrentProgress = function() {
                return (arg.Me.gcl || 0) - qTypeClass.getGclBaseProgress();
            };
            /**
                 * @return {?}
                 */
            this.getGclNeededProgress = function() {
                return Math.pow(qTypeClass.getGcl(), coord.GCL_POW) * coord.GCL_MULTIPLY - qTypeClass.getGclBaseProgress();
            };
            /**
                 * @param {?} room
                 * @return {undefined}
                 */
            this.goToRoomOverview = function(room) {
                $location.url(res.getSegmentUrl("top.game-overview-room", {room: room}));
            };
            /**
                 * @param {?} room
                 * @return {undefined}
                 */
            this.goToRoom = function(room) {
                $location.url(res.getSegmentUrl("top.game-room", {room: room}));
            };
            $scope.$watchGroup([
                function() {
                    return qTypeClass.displayOptions.statName;
                },
                function() {
                    return qTypeClass.displayOptions.statInterval;
                }
            ], function() {
                return loader.load();
            });
            var reason = item(function() {
                return loader.load();
            }, 6E4);
            $scope.$on("$destroy", function() {
                return item.cancel(reason);
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_overview_47_room_47_overview_45_room__ = function() {
    var module = angular.module("app.game.overview.room", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/overview/:room", "top.game-overview-room").within("top").segment("game-overview-room", {
                templateUrl: "components/game/overview/room/overview-room.html?bust=1479290327467",
                controller: "Top.GameOverviewRoom as GameOverviewRoom",
                dependencies: ["room"],
                resolve: {
                    data: ngInject([
                        "GameOverviewRoomLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("GameOverviewRoomLoader", [
        "Loader",
        "Api",
        "Auth",
        "$routeParams",
        "$location",
        "$q",
        "$timeout",
        "LocalStorage",
        function($provide, c2, dataAndEvents, connection, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, $templateCache) {
            return $provide.factory(function() {
                var $scope = this;
                var defaults = $templateCache.get("game.overview.displayOptions", {statInterval: 8});
                return {
                    overview: c2.get("game/room-overview", {
                        room: connection.room,
                        interval: defaults.statInterval
                    }).then(function(data) {
                        return $scope.displayOptions = defaults,
                        $scope.max = data.statsMax,
                        data;
                    })
                };
            });
        }
    ]),
    module.controller("Top.GameOverviewRoom", [
        "$scope",
        "Api",
        "Auth",
        "Constants",
        "data",
        "$routeSegment",
        "$location",
        "LocalStorage",
        "GameOverviewRoomLoader",
        "$interval",
        function($scope, service, deepDataAndEvents, ignoreMethodDoesntExist, data, $rootScope, textAlt, dataAndEvents, loader, item) {
            var qTypeClass = this;
            this.displayOptions = dataAndEvents.createSyncedObj("game.overview.displayOptions", {statInterval: 8});
            this.offsetLabels = {
                8: [
                    "-56m",
                    "-48m",
                    "-40m",
                    "-32m",
                    "-24m",
                    "-16m",
                    "-8m",
                    "0"
                ],
                180: [
                    "-21h",
                    "-18h",
                    "-15h",
                    "-12h",
                    "-9h",
                    "-6h",
                    "-3h",
                    "0"
                ],
                1440: [
                    "-6d",
                    "-5d",
                    "-4d",
                    "-3d",
                    "-2d",
                    "-1d",
                    "0"
                ]
            };
            this.data = data;
            this.roomName = $rootScope.$routeParams.room;
            this.loader = loader;
            /** @type {string} */
            this.mapUrl = service.options.official
                ? "https://d3os7yery2usni.cloudfront.net/map3/"
                : "http://" + service.options.host + ":" + service.options.port + "/assets/map/";
            $scope.$watch(function() {
                return qTypeClass.displayOptions.statInterval;
            }, function() {
                return loader.load();
            });
            var reason = item(function() {
                return loader.load();
            }, 6E4);
            $scope.$on("$destroy", function() {
                return item.cancel(reason);
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_replay_45_list_47_replay_45_list__ = function() {
    var module = angular.module("app.game.replay-list", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/r", "top.replay-list").within("top").segment("replay-list", {
                templateUrl: "components/game/replay-list/replay-list.html?bust=1479290327467",
                controller: "Top.ReplayList as ReplayList"
            });
        }
    ]),
    module.controller("Top.ReplayList", [
        "Api",
        "$location",
        function($templateCache, exports) {
            var self = this;
            $templateCache.get("replays/list").then(function(result) {
                self.list = result.list;
                _.forEach(self.list, function(obj) {
                    /** @type {Date} */
                    obj.date = new Date(obj.date);
                });
            });
            /** @type {string} */
            this.filter = "";
            /**
                 * @param {Object} options
                 * @return {undefined}
                 */
            this.view = function(options) {
                exports.url("/replay/" + options._id);
                exports.search("s", options.secret);
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_constructed_45_wall_47_constructed_45_wall__ = function() {
    var ngModule = angular.module("app.game.constructed-wall", []);
    return ngModule.controller("ConstructedWall", [
        "$scope",
        function($scope) {
            $scope.Math = Math;
        }
    ]),
    ngModule.directive("appGameConstructedWall", function() {
        return {
            scope: {
                objectData: "="
            },
            templateUrl: "components/game/room/constructed-wall/constructed-wall.html?bust=1479290327467",
            bindToController: true,
            controller: "ConstructedWall as ConstructedWall"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_construction_45_site_47_construction_45_site__ = function() {
    var module = angular.module("app.game.construction-site", []);
    return module.controller("ConstructionSite", [
        "$scope",
        "$element",
        "$rootScope",
        "$timeout",
        "Connection",
        function($scope, sourceContainer, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            var initial;
            var def = this;
            $scope.Math = Math;
            $scope.$on("roomObjectsUpdated", function() {
                if (!_.isUndefined(initial)) {
                    if (def.objectData.progress > initial) {
                        $(sourceContainer).find(".anim-build animate").each(function(dataAndEvents, a) {
                            return a.beginElement();
                        });
                    }
                }
                initial = def.objectData.progress;
            });
        }
    ]),
    module.directive("appGameConstructionSite", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/construction-site/construction-site.html?bust=1479290327467",
            bindToController: true,
            controller: "ConstructionSite as ConstructionSite"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_container_47_container__ = function() {
    var app = angular.module("app.game.container", []);
    return app.directive("appGameContainer", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "="
            },
            templateUrl: "components/game/room/container/container.html?bust=1479290327467",
            bindToController: true,
            controller: "Container as Container"
        };
    }),
    app.controller("Container", [
        "$scope",
        "$element",
        "Connection",
        "Constants",
        function(self, dataAndEvents, deepDataAndEvents, filePair) {
            var plane = this;
            self.Math = Math;
            self._ = _;
            /**
                 * @return {undefined}
                 */
            var onComplete = function() {
                /** @type {number} */
                plane.resourcesTotal = 0;
                filePair.RESOURCES_ALL.forEach(function(tx) {
                    if (plane.objectData[tx]) {
                        plane.resourcesTotal += plane.objectData[tx];
                    }
                });
            };
            self.$on("roomObjectsUpdated", onComplete);
            onComplete();
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_controller_47_controller__ = function() {
    var app = angular.module("app.game.controller", []);
    return app.directive("appGameController", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                users: "=",
                speed: "=",
                gameTime: "=",
                player: "="
            },
            templateUrl: "components/game/room/controller/controller.html?bust=1479290327467",
            bindToController: true,
            controller: "Controller as Controller"
        };
    }),
    app.controller("Controller", [
        "$scope",
        "$element",
        "Constants",
        "Connection",
        "Auth",
        "Tutorial",
        function($scope, sourceContainer, logger, deepDataAndEvents, dataAndEvents, controller) {
            var initial;
            var valueToSet;
            var event = this;
            $scope.Math = Math;
            /**
                 * @return {?}
                 */
            $scope.Me = function() {
                return dataAndEvents.Me;
            };
            /**
                 * @return {?}
                 */
            this.getLevelsPath = function() {
                /** @type {string} */
                var optsData = "";
                /** @type {number} */
                var angleDegrees = 0;
                for (; angleDegrees < event.objectData.level; angleDegrees++) {
                    /** @type {number} */
                    var tth = -Math.PI / 2;
                    tth += angleDegrees * Math.PI / 4;
                    optsData += "M 0 0 L " + 75 * Math.cos(tth - Math.PI / 8) + " " + 75 * Math.sin(tth - Math.PI / 8) + "\n                L " + 75 * Math.cos(tth + Math.PI / 8) + " " + 75 * Math.sin(tth + Math.PI / 8) + " Z";
                }
                return optsData;
            };
            /**
                 * @return {?}
                 */
            this.progress = function() {
                return Math.min(event.objectData.progress, logger.CONTROLLER_LEVELS[event.objectData.level] - 0.01);
            };
            /**
                 * @return {?}
                 */
            this.progressTotal = function() {
                return event.objectData.tutorial && 1 == event.objectData.level
                    ? 4
                    : logger.CONTROLLER_LEVELS[event.objectData.level];
            };
            /**
                 * @return {?}
                 */
            this.getDowngradingOpacity = function() {
                return (logger.CONTROLLER_DOWNGRADE[event.objectData.level] - (event.objectData.downgradeTime - event.gameTime)) / logger.CONTROLLER_DOWNGRADE[event.objectData.level];
            };
            $scope.$on("roomObjectsUpdated", function() {
                if (event.objectData.downgradeTime < event.gameTime + logger.CONTROLLER_DOWNGRADE[event.objectData.level]) {
                    $(sourceContainer).find(".anim-downgrade animate").each(function(dataAndEvents, a) {
                        return a.beginElement();
                    });
                }
                if (!_.isUndefined(initial)) {
                    if (event.objectData.progress > initial) {
                        $(sourceContainer).find(".anim-upgrade animate").each(function(dataAndEvents, a) {
                            return a.beginElement();
                        });
                    }
                }
                if (!_.isUndefined(valueToSet)) {
                    if (event.objectData.reservation) {
                        if (event.objectData.reservation.endTime > valueToSet) {
                            $(sourceContainer).find(".anim-upgrade animate").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                }
                initial = event.objectData.progress;
                valueToSet = event.objectData.reservation
                    ? event.objectData.reservation.endTime
                    : void 0;
                if (event.objectData.user == event.player) {
                    if (1 == event.objectData.level) {
                        if (event.objectData.downgradeTime - event.gameTime < 19800) {
                            if (event.objectData.downgradeTime - event.gameTime > 0) {
                                controller.trigger("controllerDowngrade", {controller: event.objectData});
                            }
                        }
                    }
                }
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_creep_47_creep__ = function() {
    var module = angular.module("app.game.creep", []);
    return module.controller("Creep", [
        "$scope",
        "$element",
        "Connection",
        "$timeout",
        "Constants",
        function(self, sourceContainer, dataAndEvents, item, element) {
            var data = this;
            self.Math = Math;
            self._ = _;
            var b;
            var y;
            var i;
            /** @type {number} */
            this.rotate = 45 * Math.floor(8 * Math.random());
            /** @type {boolean} */
            this.animActive = false;
            /** @type {string} */
            this.say = "";
            /** @type {null} */
            var reason = null;
            /**
                 * @param {?} a
                 * @param {?} x
                 * @param {?} b
                 * @param {?} y
                 * @return {undefined}
                 */
            var max = function(a, x, b, y) {
                if (!i && (a != b || x != y)) {
                    /** @type {boolean} */
                    i = true;
                    var value;
                    if (a == b) {
                        if (y > x) {
                            /** @type {number} */
                            value = 0;
                        }
                    }
                    if (a > b) {
                        if (y > x) {
                            /** @type {number} */
                            value = 45;
                        }
                    }
                    if (a > b) {
                        if (x == y) {
                            /** @type {number} */
                            value = 90;
                        }
                    }
                    if (a > b) {
                        if (x > y) {
                            /** @type {number} */
                            value = 135;
                        }
                    }
                    if (a == b) {
                        if (x > y) {
                            /** @type {number} */
                            value = 180;
                        }
                    }
                    if (b > a) {
                        if (x > y) {
                            /** @type {number} */
                            value = -135;
                        }
                    }
                    if (b > a) {
                        if (x == y) {
                            /** @type {number} */
                            value = -90;
                        }
                    }
                    if (b > a) {
                        if (y > x) {
                            /** @type {number} */
                            value = -45;
                        }
                    }
                    for (; value - data.rotate > 180;) {
                        value -= 360;
                    }
                    for (; value - data.rotate < -180;) {
                        value += 360;
                    }
                    /** @type {(number|undefined)} */
                    data.rotate = value;
                }
            };
            if (!(this.users[this.objectData.user] && (this.users[this.objectData.user].badge && this.users[this.objectData.user].badge._watching))) {
                if (0 == this.objectData.x) {
                    /** @type {number} */
                    this.rotate = 90;
                }
                if (49 == this.objectData.x) {
                    /** @type {number} */
                    this.rotate = -90;
                }
                if (0 == this.objectData.y) {
                    /** @type {number} */
                    this.rotate = 180;
                }
                if (49 == this.objectData.y) {
                    /** @type {number} */
                    this.rotate = 0;
                }
            }
            /**
                 * @return {undefined}
                 */
            var bind = function() {
                /** @type {boolean} */
                i = false;
                if (!_.isUndefined(b)) {
                    max(data.objectData.x, data.objectData.y, b, y);
                }
            };
            /**
                 * @return {undefined}
                 */
            var init = function() {
                var names = element.BODYPARTS_ALL;
                var old = {};
                data.activeBodyparts = {};
                names.forEach(function(name) {
                    data.activeBodyparts[name] = _.filter(data.objectData.body, function(t) {
                        return t.type == name && t.hits > 0;
                    }).length;
                });
                names = _.filter(names, function(ch) {
                    return "tough" != ch && ("carry" != ch && data.activeBodyparts[ch] > 0);
                });
                names.sort(function(key, x) {
                    return data.activeBodyparts[key] > data.activeBodyparts[x]
                        ? 1
                        : data.activeBodyparts[key] < data.activeBodyparts[x]
                            ? -1
                            : 0;
                });
                /** @type {number} */
                var dr = 0;
                names.forEach(function(name) {
                    /** @type {number} */
                    var angle = Math.PI * data.activeBodyparts[name] / element.MAX_CREEP_SIZE;
                    /** @type {number} */
                    var length = 39;
                    if ("move" == name) {
                        /** @type {number} */
                        angle = -angle - Math.PI / 2;
                    } else {
                        angle += dr;
                        dr = angle;
                        angle += Math.PI / 2;
                    }
                    /** @type {string} */
                    old[name] = "M " + -length * Math.cos(angle) + " " + -length * Math.sin(angle) + " A " + length + " " + length + " 0 " + (angle > Math.PI || angle < -Math.PI
                        ? 1
                        : 0) + " " + (0 > angle
                        ? 1
                        : 0) + " " + length * Math.cos(angle) + " " + -length * Math.sin(angle);
                });
                names.reverse();
                data.bodypartPaths = _.map(names, function(name) {
                    return new Object({type: name, path: old[name]});
                });
            };
            /**
                 * @param {?} a
                 * @return {undefined}
                 */
            var reset = function(a) {
                if (a) {
                    if (a.x == data.objectData.x) {
                        if (a.y < data.objectData.y) {
                            $(sourceContainer).find(".anim-top").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x > data.objectData.x) {
                        if (a.y < data.objectData.y) {
                            $(sourceContainer).find(".anim-top-right").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x > data.objectData.x) {
                        if (a.y == data.objectData.y) {
                            $(sourceContainer).find(".anim-right").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x > data.objectData.x) {
                        if (a.y > data.objectData.y) {
                            $(sourceContainer).find(".anim-bottom-right").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x == data.objectData.x) {
                        if (a.y > data.objectData.y) {
                            $(sourceContainer).find(".anim-bottom").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x < data.objectData.x) {
                        if (a.y > data.objectData.y) {
                            $(sourceContainer).find(".anim-bottom-left").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x < data.objectData.x) {
                        if (a.y == data.objectData.y) {
                            $(sourceContainer).find(".anim-left").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    if (a.x < data.objectData.x) {
                        if (a.y < data.objectData.y) {
                            $(sourceContainer).find(".anim-top-left").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }
                    }
                    max(a.x, a.y, data.objectData.x, data.objectData.y);
                }
            };
            /**
                 * @param {number} opt_attributes
                 * @param {?} win
                 * @return {undefined}
                 */
            var openDialog = function(opt_attributes, win) {
                if (win) {
                    data.workAnim = {
                        size: opt_attributes,
                        x: win.x,
                        y: win.y
                    };
                    item(function() {
                        return $(sourceContainer).find(".anim-work animate").each(function(dataAndEvents, a) {
                            return a.beginElement();
                        });
                    }, 0);
                }
            };
            /**
                 * @param {string} res
                 * @param {?} options
                 * @return {undefined}
                 */
            var createOptions = function(res, options) {
                if (options) {
                    $(sourceContainer).find(".anim-" + res).each(function(dataAndEvents, a) {
                        return a.beginElement();
                    });
                }
            };
            /**
                 * @return {undefined}
                 */
            var eachEvent = function() {
                /** @type {number} */
                data.resourcesTotal = 0;
                element.RESOURCES_ALL.forEach(function(ch) {
                    if (data.objectData[ch]) {
                        data.resourcesTotal += data.objectData[ch];
                    }
                });
            };
            bind();
            init();
            eachEvent();
            self.$on("roomObjectsUpdated", function() {
                bind();
                init();
                eachEvent();
                if (data.animActive && (data.objectData.actionLog && (data.objectData.actionLog.rangedAttack || (data.objectData.actionLog.rangedHeal || (data.objectData.actionLog.repair || (data.objectData.actionLog.build || data.objectData.actionLog.upgradeController)))))) {
                    data.shotAnim = _.cloneDeep(data.objectData.actionLog.rangedAttack || (data.objectData.actionLog.rangedHeal || (data.objectData.actionLog.repair || (data.objectData.actionLog.build || data.objectData.actionLog.upgradeController))));
                    data.shotAnim.fromX = b;
                    data.shotAnim.fromY = y;
                    /** @type {string} */
                    data.shotAnim.type = data.objectData.actionLog.rangedAttack
                        ? "rangedAttack"
                        : data.objectData.actionLog.rangedHeal
                            ? "rangedHeal"
                            : "work";
                    item(function() {
                        return $(sourceContainer).find(".anim-shot animate").each(function(dataAndEvents, a) {
                            return a.beginElement();
                        });
                    }, 0);
                } else {
                    /** @type {null} */
                    data.shotAnim = null;
                }
                /** @type {boolean} */
                data.animActive = true;
                /** @type {null} */
                data.workAnim = null;
                reset(data.objectData.actionLog && data.objectData.actionLog.harvest);
                reset(data.objectData.actionLog && data.objectData.actionLog.attack);
                reset(data.objectData.actionLog && data.objectData.actionLog.heal);
                reset(data.objectData.actionLog && data.objectData.actionLog.reserveController);
                createOptions("attacked", data.objectData.actionLog && data.objectData.actionLog.attacked);
                createOptions("healed", data.objectData.actionLog && data.objectData.actionLog.healed);
                openDialog(36, data.objectData.actionLog && data.objectData.actionLog.upgradeController);
                openDialog(36, data.objectData.actionLog && data.objectData.actionLog.reserveController);
                openDialog(16, data.objectData.actionLog && data.objectData.actionLog.build);
                openDialog(46, data.objectData.actionLog && data.objectData.actionLog.repair);
                if (data.objectData.actionLog && data.objectData.actionLog.rangedMassAttack) {
                    /** @type {boolean} */
                    data.massShotAnim = true;
                    item(function() {
                        return $(sourceContainer).find(".anim-mass-shot animate").each(function(dataAndEvents, a) {
                            return a.beginElement();
                        });
                    }, 0);
                } else {
                    /** @type {boolean} */
                    data.massShotAnim = false;
                }
                if (data.objectData.actionLog) {
                    if (data.objectData.actionLog.say) {
                        data.say = data.objectData.actionLog.say;
                        /** @type {boolean} */
                        data.say._visible = false;
                        if (reason) {
                            item.cancel(reason);
                        }
                        reason = item(function() {
                            /** @type {null} */
                            data.say = null;
                        }, 2E3);
                        item(function() {
                            var prevValue;
                            $(sourceContainer).find(".creep-say text").each(function(dataAndEvents, sprite) {
                                return prevValue = sprite.getBBox().width + 60;
                            });
                            $(sourceContainer).find(".creep-say rect").each(function(dataAndEvents, bar) {
                                bar.setAttribute("width", prevValue);
                                bar.setAttribute("x", 50 + (400 - prevValue) / 2);
                            });
                            /** @type {boolean} */
                            data.say._visible = true;
                        }, 0);
                    }
                }
                data.oldX = b;
                data.oldY = y;
                b = data.objectData.x;
                y = data.objectData.y;
            });
            self.$on("rotateCreep", function(dataAndEvents, d) {
                if (d._id == data.objectData._id) {
                    data.rotate += 45;
                }
            });
        }
    ]),
    module.directive("appGameCreep", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                users: "=",
                speed: "=",
                roomController: "=",
                gameTime: "="
            },
            templateUrl: "components/game/room/creep/creep.html?bust=1479290327467",
            bindToController: true,
            controller: "Creep as Creep"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_disabled_45_object_47_disabled_45_object__ = function() {
    var ngModule = angular.module("app.game.disabled-object", []);
    return ngModule.controller("DisabledObject", [
        "$scope",
        function($scope) {
            $scope.Math = Math;
        }
    ]),
    ngModule.directive("appGameDisabledObject", function() {
        return {
            scope: {
                objectData: "="
            },
            templateUrl: "components/game/room/disabled-object/disabled-object.html?bust=1479290327467",
            bindToController: true,
            controller: "DisabledObject as DisabledObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_display_45_options_45_block_47_display_45_options_45_block__ = function() {
    var ngModule = angular.module("app.game.room.display-options-block", []);
    return ngModule.directive("appDisplayOptionsBlock", function() {
        return {
            templateUrl: "components/game/room/display-options-block/display-options-block.html?bust=1479290327467",
            controller: "DisplayOptionsBlock as DisplayOptionsBlock",
            scope: {
                model: "=",
                heading: "@",
                parent: "@",
                children: "="
            },
            bindToController: true,
            /**
                 * @param {?} tabCtrl
                 * @param {?} scope
                 * @param {?} attrs
                 * @param {?} $attrs
                 * @return {undefined}
                 */
            link: function(tabCtrl, scope, attrs, $attrs) {}
        };
    }),
    ngModule.controller("DisplayOptionsBlock", [
        "$scope",
        function(assert) {
            var self = this;
            if (this.parentSelected = void 0, this.parentModel = void 0, this.parent) {
                assert.$watch(function() {
                    return self.model[self.parent];
                }, function(theTitle) {
                    return self.parentModel = theTitle;
                });
                /**
                     * @return {?}
                     */
                this.parentChange = function() {
                    return self.model[self.parent] = self.parentModel;
                };
            } else {
                /**
                     * @return {undefined}
                     */
                var init = function() {
                    /** @type {number} */
                    var partial = 0;
                    /** @type {number} */
                    var all = 0;
                    var i;
                    for (i in self.children) {
                        if (self.model[i]) {
                            partial++;
                        } else {
                            all++;
                        }
                    }
                    /** @type {string} */
                    self.parentSelected = 0 == partial
                        ? "none"
                        : all > 0
                            ? "partial"
                            : "all";
                    /** @type {boolean} */
                    self.parentModel = "all" == self.parentSelected;
                };
                /** @type {Array} */
                var progressValues = [];
                _.forEach(this.children, function(dataAndEvents, timeoutKey) {
                    progressValues.push(function() {
                        return self.model[timeoutKey];
                    });
                });
                assert.$watchGroup(progressValues, function() {
                    return init();
                });
                /**
                     * @return {undefined}
                     */
                this.parentChange = function() {
                    _.forEach(self.children, function(dataAndEvents, key) {
                        self.model[key] = self.parentModel;
                    });
                };
            }
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_dlg_45_arena_45_activation_47_dlg_45_arena_45_activation__ = function() {
    var ngModule = angular.module("app.game.room.dlg-arena-activation", []);
    return ngModule.controller("DlgArenaActivation", [
        "$scope",
        "MemoryStorage",
        "$modalInstance",
        "Api",
        function(dataAndEvents, deepDataAndEvents, gridStore, test) {
            var e = this;
            /** @type {string} */
            this.code = "";
            /** @type {string} */
            this.error = "";
            /**
                 * @return {undefined}
                 */
            this.submit = function() {
                test.post("arena/activate", {code: e.code}).then(function(dataAndEvents) {
                    mixpanel.track("Arena activated");
                    gridStore.close();
                })["catch"](function(dataAndEvents) {
                    if ("invalid code" == dataAndEvents) {
                        /** @type {string} */
                        e.error = "Activation code is invalid";
                    } else {
                        /** @type {string} */
                        e.error = "Unknown error";
                    }
                });
            };
        }
    ]),
    ngModule.factory("ArenaActivator", [
        "Api",
        "$routeSegment",
        "$routeParams",
        "$modal",
        function(socket, dataAndEvents, connection, $modal) {
            var _self = {};
            return _self.run = function(application) {
                return socket.post("arena/status", {
                    respawn: application,
                    room: connection.room
                })["catch"](function(dataAndEvents) {
                    if ("activation needed" == dataAndEvents) {
                        $modal.open({templateUrl: "components/game/room/dlg-arena-activation/dlg-arena-activation.html?bust=1479290327467", controller: "DlgArenaActivation as DlgArenaActivation"}).result.then(function() {
                            return _self.run(application);
                        });
                    }
                });
            },
            _self;
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_dlg_45_creep_47_dlg_45_creep__ = function() {
    var ngModule = angular.module("app.game.room.dlg-creep", []);
    return ngModule.controller("DlgCreep", [
        "$scope",
        "MemoryStorage",
        "$modalInstance",
        "data",
        "Constants",
        function(dataAndEvents, deepDataAndEvents, c, _arg, y) {
            var self = this;
            this.name = _arg.name;
            /** @type {Array} */
            this.body = [];
            /**
             * @return {undefined}
             */
            this.submit = function() {
                if (self.body.length > 0) {
                    c.close({name: self.name, body: self.body});
                }
            };
            /**
             * @param {?} spaceName
             * @return {undefined}
             */
            this.addBodypart = function(spaceName) {
                if (self.body.length != y.MAX_CREEP_SIZE) {
                    self.body.push(spaceName);
                }
            };
            /**
             * @param {?} r2
             * @return {undefined}
             */
            this.removeBodypart = function(r2) {
                self.body.splice(r2, 1);
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_dlg_45_flag_47_dlg_45_flag__ = function() {
    var ngModule = angular.module("app.game.room.dlg-flag", []);
    return ngModule.controller("DlgFlag", [
        "$scope",
        "MemoryStorage",
        "$modalInstance",
        "data",
        "Connection",
        function(dataAndEvents, deepDataAndEvents, ret, params, $) {
            var series = this;
            this.name = params.name;
            this.flag = params.flag;
            /** @type {number} */
            this.color = 10;
            /** @type {number} */
            this.secondaryColor = 10;
            /** @type {Array} */
            this.colorsList = [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ];
            if (this.flag) {
                this.color = this.flag.color;
                this.secondaryColor = this.flag.secondaryColor || this.flag.color;
            }
            /**
             * @return {undefined}
             */
            this.checkName = function() {
                $.checkUniqueFlagName(series.name, params.player).then(function() {
                    return series.overwriteWarning = false;
                })["catch"](function(dataAndEvents) {
                    return series.overwriteWarning = "name exists" == dataAndEvents;
                });
            };
            /**
             * @return {undefined}
             */
            this.submit = function() {
                ret.close({name: series.name, color: series.color, secondaryColor: series.secondaryColor});
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_energy_47_energy__ = function() {
    var ngModule = angular.module("app.game.energy", []);
    return ngModule.controller("Energy", [
        "$scope",
        function($scope) {
            $scope.Math = Math;
        }
    ]),
    ngModule.directive("appGameEnergy", function() {
        return {
            scope: {
                objectData: "="
            },
            templateUrl: "components/game/room/energy/energy.html?bust=1479290327467",
            bindToController: true,
            controller: "Energy as Energy"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_exit_47_exit__ = function() {
    var ngModule = angular.module("app.game.exit", []);
    return ngModule.controller("Exit", [
        "$scope",
        "Constants",
        function($scope, dataAndEvents) {
            $scope.Math = Math;
            /**
                 * @return {?}
                 */
            this.getPath = function() {
                /** @type {string} */
                var resolvedPath = "";
                /** @type {number} */
                var b = 0;
                for (; 50 > b; b++) {
                    resolvedPath += "M " + (100 * b + 50) + " 20 l 30 50 h -60 Z";
                }
                /** @type {number} */
                b = 0;
                for (; 50 > b; b++) {
                    resolvedPath += "M " + (100 * b + 50) + " 4980 l 30 -50 h -60 Z";
                }
                /** @type {number} */
                b = 0;
                for (; 50 > b; b++) {
                    resolvedPath += "M 20 " + (100 * b + 50) + " l 50 30 v -60 Z";
                }
                /** @type {number} */
                b = 0;
                for (; 50 > b; b++) {
                    resolvedPath += "M 4980 " + (100 * b + 50) + " l -50 30 v -60 Z";
                }
                return resolvedPath;
            };
        }
    ]),
    ngModule.directive("appGameExit", function() {
        return {
            scope: {
                objectData: "="
            },
            templateUrl: "components/game/room/exit/exit.html?bust=1479290327467",
            bindToController: true,
            controller: "Exit as Exit"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_extension_47_extension__ = function() {
    var ngModule = angular.module("app.game.extension", []);
    return ngModule.controller("Extension", [
        "$scope",
        "Constants",
        function($scope, dataAndEvents) {
            var plane = this;
            $scope.Math = Math;
            /**
                 * @return {?}
                 */
            this.getSize = function() {
                return 200 == plane.objectData.energyCapacity
                    ? 50
                    : 100 == plane.objectData.energyCapacity
                        ? 40
                        : 34;
            };
        }
    ]),
    ngModule.directive("appGameExtension", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "="
            },
            templateUrl: "components/game/room/extension/extension.html?bust=1479290327467",
            bindToController: true,
            controller: "Extension as Extension"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_extractor_47_extractor__ = function() {
    var app = angular.module("app.game.extractor", []);
    return app.directive("appGameExtractor", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/extractor/extractor.html?bust=1479290327467",
            bindToController: true,
            controller: "Extractor as Extractor"
        };
    }),
    app.controller("Extractor", [
        "$scope",
        "$rootScope",
        "Constants",
        "$element",
        function($scope, dataAndEvents, $location, sourceContainer) {
            var plane = this;
            $scope.Math = Math;
            $scope.Constants = $location;
            var cooldown;
            $scope.$on("roomObjectsUpdated", function() {
                if (plane.objectData.cooldown) {
                    if (!cooldown) {
                        $(sourceContainer).find("svg").each(function(deepDataAndEvents, dataAndEvents) {
                            return dataAndEvents.unpauseAnimations();
                        });
                    }
                }
                if (!plane.objectData.cooldown) {
                    if (cooldown > 0 || void 0 === cooldown) {
                        $(sourceContainer).find("svg").each(function(deepDataAndEvents, dataAndEvents) {
                            return dataAndEvents.pauseAnimations();
                        });
                    }
                }
                cooldown = plane.objectData.cooldown;
            });
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_flag_47_flag__ = function() {
    var ngModule = angular.module("app.game.flag", []);
    return ngModule.controller("Flag", [
        "$scope",
        function($scope) {
            $scope.Math = Math;
        }
    ]),
    ngModule.directive("appGameFlag", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "="
            },
            templateUrl: "components/game/room/flag/flag.html?bust=1479290327467",
            bindToController: true,
            controller: "Flag as Flag"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_keeper_45_lair_47_keeper_45_lair__ = function() {
    var app = angular.module("app.game.keeper-lair", []);
    return app.controller("KeeperLair", [
        "$scope",
        "$rootScope",
        function($scope, dataAndEvents) {
            $scope.Math = Math;
        }
    ]),
    app.directive("appGameKeeperLair", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "="
            },
            templateUrl: "components/game/room/keeper-lair/keeper-lair.html?bust=1479290327467",
            bindToController: true,
            controller: "KeeperLair as KeeperLair"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_lab_47_lab__ = function() {
    var module = angular.module("app.game.lab", []);
    return module.controller("Lab", [
        "$scope",
        "$element",
        "Connection",
        "$timeout",
        function(self, sourceContainer, dataAndEvents, deepDataAndEvents) {
            var plane = this;
            self.Math = Math;
            self._ = _;
            /** @type {boolean} */
            this.animActive = false;
            self.$on("roomObjectsUpdated", function() {
                /** @type {boolean} */
                plane.animActive = true;
                if (plane.objectData.actionLog && plane.objectData.actionLog.runReaction) {
                    plane.shotAnim = _.cloneDeep(plane.objectData.actionLog.runReaction);
                    $(sourceContainer).find(".anim-shot animate").each(function(dataAndEvents, a) {
                        return a.beginElement();
                    });
                } else {
                    /** @type {null} */
                    plane.shotAnim = null;
                }
            });
        }
    ]),
    module.directive("appGameLab", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/lab/lab.html?bust=1479290327467",
            bindToController: true,
            controller: "Lab as Lab"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_link_47_link__ = function() {
    var module = angular.module("app.game.link", []);
    return module.controller("Link", [
        "$scope",
        "$element",
        "Connection",
        "$timeout",
        function(self, sourceContainer, dataAndEvents, deepDataAndEvents) {
            var plane = this;
            self.Math = Math;
            self._ = _;
            /** @type {boolean} */
            this.animActive = false;
            self.$on("roomObjectsUpdated", function() {
                /** @type {boolean} */
                plane.animActive = true;
                if (plane.objectData.actionLog && plane.objectData.actionLog.transferEnergy) {
                    plane.shotAnim = _.cloneDeep(plane.objectData.actionLog.transferEnergy);
                    $(sourceContainer).find(".anim-shot animate").each(function(dataAndEvents, a) {
                        return a.beginElement();
                    });
                } else {
                    /** @type {null} */
                    plane.shotAnim = null;
                }
            });
        }
    ]),
    module.directive("appGameLink", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/link/link.html?bust=1479290327467",
            bindToController: true,
            controller: "Link as Link"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_mineral_47_mineral__ = function() {
    var extendCustomValidations = angular.module("app.game.mineral", []);
    return extendCustomValidations.directive("appGameMineral", function() {
        return {
            scope: {
                objectData: "="
            },
            templateUrl: "components/game/room/mineral/mineral.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_nuke_47_nuke__ = function() {
    var extendCustomValidations = angular.module("app.game.nuke", []);
    return extendCustomValidations.directive("appGameNuke", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                gameTime: "="
            },
            templateUrl: "components/game/room/nuke/nuke.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_nuker_47_nuker__ = function() {
    var extendCustomValidations = angular.module("app.game.nuker", []);
    return extendCustomValidations.directive("appGameNuker", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "="
            },
            templateUrl: "components/game/room/nuker/nuker.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_observer_47_observer__ = function() {
    var extendCustomValidations = angular.module("app.game.observer", []);
    return extendCustomValidations.directive("appGameObserver", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/observer/observer.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_portal_47_portal__ = function() {
    var extendCustomValidations = angular.module("app.game.portal", []);
    return extendCustomValidations.directive("appGamePortal", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "="
            },
            templateUrl: "components/game/room/portal/portal.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_power_45_bank_47_power_45_bank__ = function() {
    var ngModule = angular.module("app.game.power-bank", []);
    return ngModule.controller("PowerBank", [
        "$scope",
        "Constants",
        function($scope, $location) {
            var plane = this;
            $scope.Math = Math;
            $scope.Constants = $location;
            /**
                 * @return {?}
                 */
            this.getRadius = function() {
                return Math.sqrt(plane.objectData.power / $location.POWER_BANK_CAPACITY_MAX * 3E3 / Math.PI);
            };
        }
    ]),
    ngModule.directive("appGamePowerBank", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "="
            },
            templateUrl: "components/game/room/power-bank/power-bank.html?bust=1479290327467",
            bindToController: true,
            controller: "PowerBank as PowerBank"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_power_45_spawn_47_power_45_spawn__ = function() {
    var app = angular.module("app.game.power-spawn", []);
    return app.controller("PowerSpawn", [
        "$scope",
        "$rootScope",
        "Tutorial",
        "Connection",
        function($scope, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            $scope.Math = Math;
        }
    ]),
    app.directive("appGamePowerSpawn", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                users: "="
            },
            templateUrl: "components/game/room/power-spawn/power-spawn.html?bust=1479290327467",
            bindToController: true,
            controller: "PowerSpawn as PowerSpawn"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_properties_47_controller__ = function() {
    var app = angular.module("app.game.room.controller-properties", []);
    return app.controller("Top.Game.Room.ControllerProperties", [
        "$scope",
        "$rootScope",
        "Constants",
        "Connection",
        "WorldRespawnChecker",
        "Dialogs",
        function(self, dataAndEvents, deepDataAndEvents, socket, engineTools, o) {
            var askUnclaim = this;
            /** @type {boolean} */
            this.askUnclaim = false;
            /**
             * @return {undefined}
             */
            this.increaseLevel = function() {
                var o = self.Room.selectedObject;
                o.level++;
                if (o.level > 8) {
                    /** @type {number} */
                    o.level = 8;
                }
                if (1 == o.level) {
                    /** @type {number} */
                    o.progress = 0;
                }
                o.user = self.Game.player;
            };
            /**
             * @return {undefined}
             */
            this.decreaseLevel = function() {
                var o = self.Room.selectedObject;
                o.level--;
                if (o.level <= 0) {
                    /** @type {number} */
                    o.level = 0;
                    /** @type {null} */
                    o.user = null;
                    /** @type {number} */
                    o.progress = 0;
                }
            };
            /**
             * @return {?}
             */
            this.unclaim = function() {
                if (!askUnclaim.askUnclaim) {
                    return void(askUnclaim.askUnclaim = true);
                }
                var user = self.Room.selectedObject;
                socket.addObjectIntent(user._id, self.Game.player, "unclaim", {id: user._id});
                var throttledUpdate = self.$on("roomObjectsUpdated", function() {
                    engineTools.check();
                    throttledUpdate();
                });
            };
            /**
             * @return {?}
             */
            this.activateSafeMode = function() {
                return o.ask("", "This action will consume 1 available safe mode activation. Proceed?").result.then(function() {
                    var user = self.Room.selectedObject;
                    socket.addObjectIntent(user._id, self.Game.player, "activateSafeMode", {id: user._id})["catch"](function(dataAndEvents) {
                        if ("safe mode active already" == dataAndEvents) {
                            o.alert("", "There is a room in safe mode already. You can activate safe mode in only one room at the same time.");
                        }
                    });
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_properties_47_creep__ = function() {
    var app = angular.module("app.game.room.creep-properties", []);
    return app.controller("Top.Game.Room.CreepProperties", [
        "$scope",
        "$rootScope",
        "Connection",
        "Api",
        function(self, $rootScope, socket, db) {
            var askSuicide = this;
            /** @type {boolean} */
            this.askSuicide = false;
            /**
             * @return {undefined}
             */
            this.addMemoryWatch = function() {
                $rootScope.$broadcast("addMemoryWatch", "creeps." + self.Room.selectedObject.name);
            };
            /**
             * @return {?}
             */
            this.suicide = function() {
                if (!askSuicide.askSuicide) {
                    return void(askSuicide.askSuicide = true);
                }
                var user = self.Room.selectedObject;
                socket.addObjectIntent(user._id, self.Game.player, "suicide", {id: user._id});
                /** @type {null} */
                self.Room.selectedObject = null;
            };
            /**
             * @return {undefined}
             */
            this.removeInvader = function() {
                db.post("game/remove-invader", {_id: self.Room.selectedObject._id});
                /** @type {null} */
                self.Room.selectedObject = null;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_properties_47_flag__ = function() {
    var app = angular.module("app.game.room.flag-properties", []);
    return app.controller("Top.Game.Room.FlagProperties", [
        "$scope",
        "$rootScope",
        "Api",
        "Dialogs",
        "$modal",
        "Connection",
        function(self, $rootScope, dataAndEvents, deepDataAndEvents, $modal, socket) {
            /**
             * @return {undefined}
             */
            this.addMemoryWatch = function() {
                $rootScope.$broadcast("addMemoryWatch", "flags." + self.Room.selectedObject.name);
            };
            /**
             * @return {undefined}
             */
            this.changeColor = function() {
                $modal.open({
                    templateUrl: "components/game/room/dlg-flag/dlg-flag.html?bust=1479290327467",
                    controller: "DlgFlag as DlgFlag",
                    resolve: {
                        /**
                         * @return {?}
                         */
                        data: function() {
                            return new Object({flag: self.Room.selectedObject});
                        }
                    }
                }).result.then(function(message) {
                    return socket.changeFlagColor(self.Room.selectedObject.name, message.color, message.secondaryColor, self.Game.player);
                });
            };
            /**
             * @return {undefined}
             */
            this.removeFlag = function() {
                /** @type {boolean} */
                self.Room.selectedObject.tempRemove = true;
                socket.removeFlag(self.Room.selectedObject.name, self.Game.player);
                /** @type {null} */
                self.Room.selectedObject = null;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_properties_47_rampart__ = function() {
    var app = angular.module("app.game.room.rampart-properties", []);
    return app.controller("Top.Game.Room.RampartProperties", [
        "$scope",
        "$rootScope",
        "Connection",
        function(self, dataAndEvents, socket) {
            /**
             * @param {?} dataAndEvents
             * @return {undefined}
             */
            this.setPublic = function(dataAndEvents) {
                socket.addObjectIntent(self.Room.selectedObject._id, self.Game.player, "setPublic", {isPublic: dataAndEvents});
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_properties_47_spawn__ = function() {
    var app = angular.module("app.game.room.spawn-properties", []);
    return app.controller("Top.Game.Room.SpawnProperties", [
        "$scope",
        "$rootScope",
        "Api",
        "Dialogs",
        function(dataAndEvents, $rootScope, deepDataAndEvents, ignoreMethodDoesntExist) {
            /**
             * @return {undefined}
             */
            this.addMemoryWatch = function() {
                $rootScope.$broadcast("addMemoryWatch", "spawns." + dataAndEvents.Room.selectedObject.name);
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_rampart_47_rampart__ = function() {
    var extendCustomValidations = angular.module("app.game.rampart", []);
    return extendCustomValidations.directive("appGameRampart", function() {
        return {
            scope: {
                objectData: "=",
                player: "="
            },
            templateUrl: "components/game/room/rampart/rampart.html?bust=1479290327467",
            bindToController: true,
            controller: "GenericObject as GenericObject"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_rendered_45_svg_45_path_47_rendered_45_svg_45_path__ = function() {
    var googleMapsModule = angular.module("app.game.room.rendered-svg-path", []);
    return googleMapsModule.directive("appRoomRenderedSvgPath", [
        "RoomCanvasRenderer",
        "$timeout",
        function(object, dataAndEvents) {
            return {
                restrict: "E", templateUrl: "components/game/room/rendered-svg-path/rendered-svg-path.html?bust=1479290327467",
                /**
                 * @return {undefined}
                 */
                controller: function() {
                    /** @type {number} */
                    this.activeCanvas = 0;
                },
                controllerAs: "RenderedSvgPath",
                /**
                 * @param {?} scope
                 * @param {?} el
                 * @param {Error} attrs
                 * @param {?} tabCtrl
                 * @return {undefined}
                 */
                link: function(scope, el, attrs, tabCtrl) {
                    var openElement;
                    var url;
                    /** @type {number} */
                    var n = 0;
                    var self = object.register();
                    /** @type {number} */
                    var a = 0;
                    /** @type {number} */
                    var b = 0;
                    /**
                     * @param {?} element
                     * @return {undefined}
                     */
                    var update = function(element) {
                        /** @type {number} */
                        a = Date.now();
                        openElement = element;
                        if (!b) {
                            start();
                        }
                    };
                    /**
                     * @return {undefined}
                     */
                    var start = function() {
                        /** @type {number} */
                        b = Date.now();
                        self.start();
                        /** @type {number} */
                        var i = 1 - n;
                        var w = $(el).parent().width();
                        var imagesHeight = $(el).parent().height();
                        /** @type {string} */
                        var text = '<svg xmlns="http://www.w3.org/2000/svg" width="' + w + '" height="' + imagesHeight + '" ' + _.map(scope.$eval(attrs.svgOptions), function(ctag, otag) {
                            return otag + '="' + ctag + '"';
                        }).join(" ") + "><path " + _.map(scope.$eval(attrs.pathOptions), function(ctag, otag) {
                            return otag + '="' + ctag + '"';
                        }).join(" ") + ' d="' + openElement + '"></path></svg>';
                        /** @type {DOMURL} */
                        var URL = window.URL || (window.webkitURL || window);
                        var img = $(el).find("img")[i];
                        img.width = w;
                        img.height = imagesHeight;
                        /** @type {Blob} */
                        var blob = new Blob([text], {type: "image/svg+xml"});
                        if (url) {
                            URL.revokeObjectURL(url);
                        }
                        /** @type {string} */
                        url = URL.createObjectURL(blob);
                        /**
                         * @return {undefined}
                         */
                        img.onload = function() {
                            /** @type {string} */
                            $(el).find("img")[n].style.display = "none";
                            /** @type {string} */
                            $(el).find("img")[i].style.display = "";
                            /** @type {number} */
                            n = i;
                            setTimeout(function() {
                                self.resolve();
                                if (a > b) {
                                    start();
                                } else {
                                    /** @type {number} */
                                    b = 0;
                                }
                            }, 0);
                        };
                        /** @type {string} */
                        img.src = url;
                    };
                    scope.$watch(attrs.path, update);
                    scope.$watch(attrs.pathOptions, function() {
                        return update(scope.$eval(attrs.path));
                    });
                    scope.$on("resize", _.debounce(function(dataAndEvents, putativeSpy) {
                        if (!(putativeSpy && putativeSpy.sameSize)) {
                            update(scope.$eval(attrs.path));
                        }
                    }, 20));
                    $(window).resize(_.debounce(function() {
                        return scope.$apply(function() {
                            update(scope.$eval(attrs.path));
                        });
                    }, 20));
                    scope.$on("$destroy", function() {
                        object.unregister(self);
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_roads__ = function() {
    var value = angular.module("app.game.room.roads", []);
    return value.factory("RoomRoads", function() {
        return function(failures) {
            if (!failures) {
                return "";
            }
            /** @type {string} */
            var b = (performance.now(), "");
            var tiles = {};
            /** @type {number} */
            var i = -10;
            for (; 50 >= i; i++) {
                tiles[i] = {};
            }
            failures.forEach(function(tile) {
                tiles[tile.x][tile.y] = tile;
            });
            /** @type {number} */
            i = 0;
            for (; 50 > i; i++) {
                /** @type {number} */
                var j = 0;
                for (; 50 > j; j++) {
                    if (tiles[i][j]) {
                        var pair = tiles[i][j];
                        b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " h 0 ";
                        if (tiles[i][j - 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l 0 -50 ";
                        }
                        if (tiles[i + 1][j - 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l 50 -50 ";
                        }
                        if (tiles[i + 1][j]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l 50 0 ";
                        }
                        if (tiles[i + 1][j + 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l 50 50 ";
                        }
                        if (tiles[i][j + 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l 0 50 ";
                        }
                        if (tiles[i - 1][j + 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l -50 50 ";
                        }
                        if (tiles[i - 1][j]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l -50 0 ";
                        }
                        if (tiles[i - 1][j - 1]) {
                            b += "M " + (100 * pair.x + 50) + " " + (100 * pair.y + 50) + " l -50 -50 ";
                        }
                    }
                }
            }
            return b;
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_room__ = function() {
    var module = angular.module("app.game.room", []);
    return module.factory("RoomViewPendingSelector", function() {
        var boolHook;
        var id;
        return boolHook = {
            /**
                 * @param {string} dest
                 * @return {undefined}
                 */
            set: function(dest) {
                /** @type {string} */
                id = dest;
            },
            /**
                 * @param {?} element
                 * @return {?}
                 */
            check: function(element) {
                if (!id) {
                    return false;
                }
                var elementRect = _.find(element, {_id: id});
                return elementRect
                    ? (id = null, elementRect)
                    : void 0;
            }
        };
    }),
    module.factory("RoomChanger", [
        "$timeout",
        function(item) {
            var record;
            var r;
            var points;
            var reason;
            return record = {
                /**
                         * @return {undefined}
                         */
                reset: function() {
                    points = {
                        x: 0,
                        y: 0
                    };
                    /** @type {null} */
                    r = null;
                },
                /**
                         * @param {Function} keepData
                         * @return {undefined}
                         */
                setExit: function(keepData) {
                    /** @type {Function} */
                    r = keepData;
                    if (reason) {
                        item.cancel(reason);
                    }
                },
                /**
                         * @param {number} off
                         * @return {?}
                         */
                getPanScaled: function(off) {
                    return off *= 0.6,
                    points = _.clone(points),
                    "right" == r && (points.x += off),
                    "top" == r && (points.y -= off),
                    "left" == r && (points.x -= off),
                    "bottom" == r && (points.y += off),
                    reason = item(function() {
                        return r = null;
                    }, 1E3),
                    points;
                },
                /**
                         * @return {?}
                         */
                getExit: function() {
                    return r;
                }
            },
            record.reset(),
            record;
        }
    ]),
    module.factory("RoomCanvasRenderer", function() {
        /** @type {Array} */
        var parents = [];
        var values = {
            dirty: false,
            /**
                 * @return {?}
                 */
            register: function() {
                var record = {
                    status: "inactive",
                    /**
                         * @return {undefined}
                         */
                    start: function() {
                        /** @type {boolean} */
                        values.dirty = false;
                        this.time = performance.now();
                        /** @type {string} */
                        this.status = "pending";
                    },
                    /**
                         * @return {undefined}
                         */
                    resolve: function() {
                        /** @type {string} */
                        this.status = "inactive";
                    }
                };
                return parents.push(record),
                record;
            },
            /**
                 * @param {?} item
                 * @return {undefined}
                 */
            unregister: function(item) {
                parents = _.without(parents, item);
            },
            /**
                 * @return {?}
                 */
            isComplete: function() {
                return !_.any(parents, {status: "pending"});
            }
        };
        return values;
    }),
    module.controller("Top.Game.Room", [
        "$scope",
        "Connection",
        "$timeout",
        "LocalStorage",
        "MemoryStorage",
        "RoomWalls",
        "RoomRoads",
        "$modal",
        "Dialogs",
        "Constants",
        "Tutorial",
        "StaticMaps",
        "$q",
        "$window",
        "Api",
        "$routeSegment",
        "RoomViewPendingSelector",
        "$location",
        "ArenaActivator",
        "$routeParams",
        "RoomChanger",
        "MapUtils",
        "WorldActivator",
        "Auth",
        "Socket",
        "ResourceTypeNames",
        "WorldRespawnChecker",
        "$rootScope",
        "$templateCache",
        function($scope, self, set, $templateCache, assert, callback, $sanitize, $modal, worker, obj, child, arr, promise, ignoreMethodDoesntExist, db, controller, test, body, d, options, evt, Math, details, ins, dataAndEvents, deepDataAndEvents, engineTools, config, context) {
            var data = this;
            /** @type {number} */
            var dataText = 1 / 0;
            var room = this;
            if (evt.reset(), this.zIndexByType = {
                constructedWall: 0,
                energy: 1,
                source: 2,
                keeperLair: 3,
                controller: 4,
                creep: 5,
                portal: 6,
                extension: 7,
                spawn: 8,
                link: 9,
                constructionSite: 10,
                flag: 11
            }, this.resourceTypeNames = deepDataAndEvents, this.densityNames = {
                1: "Low",
                2: "Moderate",
                3: "High",
                4: "Ultra"
            }, this.mapUrl = db.options.official
                ? "https://d3os7yery2usni.cloudfront.net/map3/"
                : "http://" + db.options.host + ":" + db.options.port + "/assets/map/", this.objects = [], this.flags = [], this.terrain = [], this.users = {}, this.hasExit = {}, this.Constants = obj, this.gameTime = null, !db.options.official && db.options.serverData.customObjectTypes) {
                this.customObjectTypes = db.options.serverData.customObjectTypes;
                var id;
                for (id in db.options.serverData.customObjectTypes) {
                    context.put("customObjectTypeSvg_" + id, db.options.serverData.customObjectTypes[id].svg || "");
                    context.put("customObjectTypeProperties_" + id, db.options.serverData.customObjectTypes[id].sidepanel || "");
                }
            }
            if (!$scope.Game.simulationMode) {
                db.get("game/time").then(function(ev) {
                    data.gameTime = ev.time;
                });
            }
            $scope.$watch(function() {
                return options.room;
            }, function() {
                if (data.objects = [], data.flags = [], data.terrain = [], data.users = {}, data.hasExit = {}, data.isRoomUpdatedOnce = false, data.roomName = options.room, data.safeMode = null, data.roomController = null, data.canCreateInvaders = false, "history" != $scope.Game.simulationMode && self.reloadRoom(), data.terrain && 0 != data.terrain.length || empty()["catch"](function() {
                    return $scope.Game.roomError = true;
                }),
                data.roomName) {
                    var vec0 = Math.roomNameToXY(data.roomName);
                    var y = vec0[0];
                    var x = vec0[1];
                    data.hasExit.left = Math.getRoomNameFromXY(y - 1, x);
                    data.hasExit.right = Math.getRoomNameFromXY(y + 1, x);
                    data.hasExit.top = Math.getRoomNameFromXY(y, x - 1);
                    data.hasExit.bottom = Math.getRoomNameFromXY(y, x + 1);
                    /** @type {boolean} */
                    data.respawnProhibited = false;
                    if (ins.Me) {
                        db.get("user/respawn-prohibited-rooms").then(function(host) {
                            if (_.contains(host.rooms, data.roomName)) {
                                /** @type {boolean} */
                                data.respawnProhibited = true;
                            }
                        });
                        db.get("game/room-status", {room: data.roomName}).then(function(response) {
                            data.roomStatusInfo = response.room;
                        });
                    }
                }
                ga("send", "event", "World", "Room entered", data.roomName);
            });
            this.displayOptions = $templateCache.createSyncedObj("game.room.displayOptions", {
                showMyNames: {
                    spawns: true,
                    creeps: false
                },
                showEnemyNames: {
                    spawns: true,
                    creeps: false
                },
                showFlags: true,
                showFlagsNames: true,
                asideCollapsed: false,
                showCreepSpeech: true,
                animations: true
            });
            this.asidePanels = $templateCache.createSyncedObj("game.room.asidePanels", {
                simulation: true,
                displayOptions: false,
                cursor: true,
                playerControl: false,
                customize: true,
                construct: true,
                view: true,
                arena: true,
                worldRoom: true,
                worldMap: false,
                invasion: false
            });
            this.selectedAction = {
                action: "view"
            };
            /** @type {null} */
            this.selectedObject = null;
            /** @type {null} */
            this.cursorPos = null;
            /** @type {Array} */
            var user = [
                20,
                30,
                40,
                50,
                65,
                80,
                100
            ];
            /** @type {number} */
            this.zoomLevel = 3;
            /** @type {number} */
            this.zoom = 50;
            /** @type {boolean} */
            this.panActive = false;
            /** @type {string} */
            this.symmetry = "none";
            /** @type {boolean} */
            this.arenaRespawn = false;
            /** @type {null} */
            this.roomController = null;
            /**
                 * @return {?}
                 */
            this.now = function() {
                return Date.now();
            };
            this.dummyRoad = {
                0: {
                    type: "road",
                    x: 1,
                    y: 1
                }
            };
            this.dummyRampart = {
                0: {
                    type: "rampart",
                    x: 1,
                    y: 1,
                    user: 0
                }
            };
            this.dummyWall = {
                0: {
                    type: "constructedWall",
                    x: 1,
                    y: 1
                }
            };
            /** @type {boolean} */
            this.isPlacingFirstSpawn = false;
            self.onRoomUpdate($scope, function(items, o2, self, key, p) {
                if (result = {}, data.gameTime = key, data.isRoomUpdatedOnce = true, o2) {
                    var o;
                    for (o in o2) {
                        data.users[o] = o2[o];
                    }
                }
                /** @type {Array} */
                data.objects = items;
                /** @type {Array} */
                data.flags = [];
                if (p) {
                    if (!_.isString(p)) {
                        if (p[0] && !_.isUndefined(p[0].user)) {
                            p = _.find(p, {user: $scope.Game.player}) || {
                                data: ""
                            };
                            /** @type {string} */
                            p = p.data;
                        } else {
                            p = void 0;
                        }
                    }
                }
                if (p) {
                    p.split("|").forEach(function(pair) {
                        if (pair) {
                            var match = pair.split("~");
                            data.flags.push({
                                name: match[0].replace(/\$VLINE\$/g, "|").replace(/\$TILDE\$/g, "~"),
                                color: Number(match[1]),
                                secondaryColor: Number(match[2]),
                                x: Number(match[3]),
                                y: Number(match[4]),
                                _id: "flag_" + match[0],
                                type: "flag"
                            });
                        }
                    });
                }
                /** @type {null} */
                data.safeMode = null;
                /** @type {null} */
                data.roomController = null;
                /** @type {number} */
                var n = 0;
                for (; n < data.objects.length; n++) {
                    o = data.objects[n];
                    if ("controller" == o.type && (data.roomController = o, o.safeMode && (data.safeMode = o.safeMode)), o.temp && o.temp !== true) {
                        var head = _.find(data.objects, function(data) {
                            return data._id == o.temp || data.name == o.temp;
                        });
                        if (head) {
                            if (head.x == o.x) {
                                if (head.y == o.y) {
                                    data.objects.splice(n--, 1);
                                }
                            }
                        }
                    }
                }
                if (data.canCreateInvaders = data.roomController && (data.roomController.user == $scope.Game.player && (_.filter(data.objects, {
                    type: "creep",
                    user: "2"
                }).length < 5 && 0 == _.filter(data.objects, function(user) {
                    return "creep" == user.type && ("2" != user.user && user.user != data.roomController.user);
                }).length)), data.canCreateInvaders || ("createInvader" != data.selectedAction.action || (data.selectedAction.action = "view")), self) {
                    if ("survival" == self.mode) {
                        data.roomMode = obj.MODE_SURVIVAL;
                        data.survivalScore = self.score || 0;
                        data.timeToWave = self.timeToWave || 200;
                        data.wave = self.wave || 1;
                        if (self.user == $scope.Game.player) {
                            /** @type {boolean} */
                            $scope.Game.readOnly = false;
                            if (!_.any(data.objects, {type: "spawn"})) {
                                /** @type {string} */
                                data.selectedAction.action = "spawn";
                                /** @type {boolean} */
                                data.isPlacingFirstSpawn = true;
                            }
                        }
                        data.survivalEnabled = self.survivalEnabled;
                        "finished" == self.status;
                    } else {
                        if ("arena" == self.mode) {
                            data.roomMode = obj.MODE_ARENA;
                            data.timeToNextRound = self.timeToNextRound;
                            data.gladiators = self.gladiators;
                            data.arenaRespawn = self.respawn;
                            if (data.timeToNextRound > dataText) {
                                $scope.Game.arenaFinishScore = data.arenaScore;
                            }
                            dataText = data.timeToNextRound;
                            data.arenaScore = self.score;
                            /** @type {boolean} */
                            $scope.Game.readOnly = false;
                            var coords = options.room.match(/^arena(\d)(\d)$/);
                            var x = (coords[0], coords[1]);
                            var y = coords[2];
                            /** @type {number} */
                            x = parseInt(x);
                            /** @type {number} */
                            y = parseInt(y);
                            if (x > 1) {
                                /** @type {string} */
                                data.hasExit.left = "arena" + (x - 1) + y;
                            }
                            if (3 > x) {
                                /** @type {string} */
                                data.hasExit.right = "arena" + (x + 1) + y;
                            }
                            if (y > 1) {
                                /** @type {string} */
                                data.hasExit.top = "arena" + x + (y - 1);
                            }
                            if (3 > y) {
                                /** @type {string} */
                                data.hasExit.bottom = "arena" + x + (y + 1);
                            }
                        } else {
                            if ("world" == self.mode) {
                                data.roomMode = obj.MODE_WORLD;
                                if ($scope.Game.readOnly) {
                                    if ("top.game-room-history" != controller.name) {
                                        db.get("user/world-status").then(function(jqXHR) {
                                            if ("empty" == jqXHR.status) {
                                                /** @type {string} */
                                                data.selectedAction.action = "spawn";
                                                /** @type {boolean} */
                                                data.isPlacingFirstSpawn = true;
                                            }
                                            /** @type {boolean} */
                                            $scope.Game.readOnly = false;
                                        });
                                    }
                                }
                                data.historyTimestamp = self.historyTimestamp;
                            }
                        }
                    }
                }
                if (data.isPlacingFirstSpawn && (_.any(items, {
                    type: "spawn",
                    user: $scope.Game.player
                }) && (data.isPlacingFirstSpawn = false, "spawn" == data.selectedAction.action && (data.selectedAction.action = "view"))), data.selectedObject && ("flag" == data.selectedObject.type
                    ? data.selectedObject = _.find(data.flags, {_id: data.selectedObject._id})
                    : data.selectedObject = _.find(data.objects, {_id: data.selectedObject._id})), "tutorial" == $scope.Game.simulationMode && (child.trigger("objectsStart"), _.forEach(items, function(controller) {
                    if ("creep" == controller.type) {
                        child.trigger("creep", {creep: controller});
                    }
                    if ("controller" == controller.type) {
                        child.trigger("controller", {controller: controller});
                    }
                    if ("road" == controller.type) {
                        child.trigger("road", {road: controller});
                    }
                    if ("constructionSite" == controller.type) {
                        child.trigger("constructionSite", {constructionSite: controller});
                    }
                }), child.trigger("objectsEnd", {objects: items})), data.selectedObject = test.check(data.objects) || data.selectedObject, "history" == $scope.Game.simulationMode && (key >= $scope.Game.historyMaxGameTime && $scope.Game.pause()), data.autoCreateCreeps) {
                    /** @type {Array} */
                    data.objects = [];
                    /** @type {number} */
                    var col = 5;
                    for (; 45 >= col; col++) {
                        /** @type {number} */
                        var i = 5;
                        for (; 45 >= i; i++) {
                            if (!((col + i) % 2)) {
                                var d = {
                                    _id: "id" + Math.floor(1E5 * Math.random()) + Date.now(),
                                    type: "creep",
                                    user: $scope.Game.player,
                                    body: [
                                        {
                                            type: "move",
                                            hits: 100
                                        }
                                    ],
                                    name: "x" + col + "y" + i,
                                    x: col,
                                    y: i,
                                    room: "sim",
                                    hits: 100,
                                    hitsMax: 100,
                                    carryCapacity: 0,
                                    energy: 0,
                                    ageTime: 1E12
                                };
                                data.objects.push(d);
                            }
                        }
                    }
                    /** @type {number} */
                    o = 0;
                    for (; 400 > o; o++) {
                        var out = {
                            _id: "id" + Math.floor(1E5 * Math.random()) + Date.now(),
                            type: "road",
                            x: Math.floor(40 * Math.random()) + 5,
                            y: Math.floor(40 * Math.random()) + 5,
                            room: "sim",
                            hits: 1E5,
                            hitsMax: 1E5,
                            decayTime: 1E12
                        };
                        data.objects.push(out);
                        out = {
                            _id: "id" + Math.floor(1E5 * Math.random()) + Date.now(),
                            type: "rampart",
                            user: $scope.Game.player,
                            decayTime: 1E7,
                            x: Math.floor(40 * Math.random()) + 5,
                            y: Math.floor(40 * Math.random()) + 5,
                            room: "sim",
                            hits: 1E5,
                            hitsMax: 1E5
                        };
                        data.objects.push(out);
                    }[
                        "container",
                        "controller",
                        "extension",
                        "extractor",
                        "keeperLair",
                        "lab",
                        "link",
                        "mineral",
                        "nuker",
                        "observer",
                        "powerBank",
                        "powerSpawn",
                        "source",
                        "spawn",
                        "storage",
                        "terminal",
                        "tower"
                    ].forEach(function(paramType) {
                        /** @type {number} */
                        var c = 0;
                        for (; 5 > c; c++) {
                            data.objects.push({
                                _id: "id" + Math.floor(1E5 * Math.random()) + Date.now(),
                                type: paramType,
                                user: $scope.Game.player,
                                x: Math.floor(30 * Math.random()) + 10,
                                y: Math.floor(30 * Math.random()) + 10,
                                room: "sim",
                                hits: 100,
                                hitsMax: 100
                            });
                        }
                    });
                    assert.put("rooms.objects", data.objects);
                }
                set(10).then(function() {
                    return $scope.$broadcast("roomObjectsUpdated");
                });
            });
            if ($scope.Game.simulationMode) {
                if (!$scope.Game.readOnly) {
                    if ("history" != $scope.Game.simulationMode) {
                        self.setSimLostWarning($scope);
                    }
                }
            }
            $scope.$on("$destroy", function() {
                $scope.Game.pause();
            });
            /**
                 * @return {undefined}
                 */
            this.onNotifyWhenAttackedChange = function() {
                db.post("game/set-notify-when-attacked", {
                    _id: data.selectedObject._id,
                    enabled: data.selectedObject.notifyWhenAttacked
                });
            };
            /**
                 * @param {Function} key
                 * @return {undefined}
                 */
            this.switchRoom = function(key) {
                if (evt.setExit(key), data.hasExit[key]) {
                    var rvar = controller.getSegmentUrl(controller.name, {room: data.hasExit[key]});
                    if ("top.game-room-history" == controller.name) {
                        rvar += "?t=" + data.gameTime;
                    }
                    body.url(rvar);
                }
            };
            /**
                 * @param {?} width
                 * @param {?} from
                 * @return {?}
                 */
            this.getNeighborRoom = function(width, from) {
                if (options.room) {
                    var vals = Math.roomNameToXY(options.room);
                    var val = vals[0];
                    var length = vals[1];
                    return Math.getRoomNameFromXY(val + width, length + from);
                }
            };
            /**
                 * @return {undefined}
                 */
            this.goToMap = function() {
                var args = Math.roomNameToXY(options.room);
                var pageY = args[0];
                var pageX = args[1];
                body.url(controller.getSegmentUrl("top.game-world-map") + ("?pos=" + (pageY + 0.5) + "," + (pageX + 0.5)));
            };
            /**
                 * @param {string} clone
                 * @return {undefined}
                 */
            this.selectObjectPending = function(clone) {
                test.set(clone);
                data.selectedAction = {
                    action: "view"
                };
                data.selectedObject = test.check(data.objects) || data.selectedObject;
                db.get("game/find-object", {_id: clone}).then(function(res) {
                    if (res.object) {
                        if (res.object.room != options.room) {
                            body.url(controller.getSegmentUrl("top.game-room", {room: res.object.room}));
                        }
                    }
                });
            };
            /**
                 * @return {undefined}
                 */
            this.onArenaRespawnChange = function() {
                d.run(data.arenaRespawn);
            };
            var result = {};
            /**
                 * @param {string} option
                 * @param {Array} name
                 * @param {boolean} dataAndEvents
                 * @return {?}
                 */
            this.getRenderedPath = function(option, name, dataAndEvents) {
                if (result[option] && !dataAndEvents) {
                    return result[option];
                }
                var value;
                if ((!result[option] || dataAndEvents) && ("walls" == option && (value = callback(name
                    ? [name]
                    : [
                        data.objects, data.terrain
                    ], function(statement) {
                    return "wall" == statement.type || "constructedWall" == statement.type;
                }, false)), "swamps" == option && (value = callback([data.terrain], function(statement) {
                    return "swamp" == statement.type;
                }, false)), "roads" == option && (value = $sanitize(_.filter(name || data.objects, {type: "road"}))), /^ramparts/.test(option))) {
                    var meta = option.match(/^ramparts:(.*)$/);
                    value = callback(name
                        ? [name]
                        : [data.objects], function(obj) {
                        return "rampart" == obj.type && (!obj.isPublic && obj.user == meta[1]);
                    }, false);
                }
                return dataAndEvents || (result[option] = value),
                value;
            };
            /**
                 * @return {?}
                 */
            this.getUsersWithRamparts = function() {
                /** @type {Array} */
                var app = [];
                return _.forEach(data.objects, function(msg) {
                    if ("rampart" == msg.type) {
                        if (-1 == app.indexOf(msg.user)) {
                            app.push(msg.user);
                        }
                    }
                }),
                app;
            };
            var current;
            /**
                 * @param {Object} last
                 * @return {undefined}
                 */
            this.cursorPaint = function(last) {
                if ("view" == data.selectedAction.action && ("mouseup" == last.type
                    ? current = null
                    : current
                        ? window.Math.max(window.Math.abs(current.x - last.pageX), window.Math.abs(current.y - last.pageY)) > 10 && (data.panActive = _.cloneDeep(current), current = null)
                        : current = {
                            x: last.pageX,
                            y: last.pageY
                        }), data.isLocationValid() && (data.cursorPos && "customize" == data.selectedAction.action)) {
                    if ("erase" == data.selectedAction.customize) {
                        var key = assert.get("rooms.objects");
                        _.remove(key, {
                            x: data.cursorPos.x,
                            y: data.cursorPos.y
                        });
                        assert.put("rooms.objects", key);
                        update(data.cursorPos.x, data.cursorPos.y, "plain");
                    }
                    if (_.isObject(data.selectedAction.customize)) {
                        if ("create" == data.selectedAction.customize.action) {
                            if ("spawn" != data.selectedAction.customize.type) {
                                init(data.selectedAction.customize.type, data.cursorPos);
                            }
                        }
                    }
                }
            };
            /**
                 * @param {Object} e
                 * @return {?}
                 */
            this.cursorClick = function(e) {
                if (data.isLocationValid() && data.cursorPos) {
                    if ("spawn" == data.selectedAction.action) {
                        var cnl = _.filter(data.objects, {type: "source"}).length;
                        if (0 == cnl) {
                            return void worker.alert("", {html: '<img src="components/game/room/room-spawn-2sources.png" align="left" style="margin-left:-15px">There are no energy sources in this room. It is not a very good idea to start playing in a room without ability to harvest energy. Please choose another room.'});
                        }
                        if (data.roomMode == obj.MODE_WORLD && data.timeUntilCanSpawn()) {
                            return;
                        }
                        if (data.respawnProhibited) {
                            return;
                        }
                        var newX = data.cursorPos.x;
                        var newY = data.cursorPos.y;
                        var defer = promise.when();
                        if (data.roomMode == obj.MODE_WORLD) {
                            if (db.options.official) {
                                if (!$templateCache.get("placeSpawnTutorialAsked", 0)) {
                                    defer = defer.then(function() {
                                        return worker.ask({message: "Before you start in the real World, we recommend you to take the Tutorial that explains the game basics and everything you are going to face step by step. Have you already taken the tutorial? ", buttonLabel: "Yes, I have", buttonCancelLabel: "Go to Tutorial"}).result.then(function() {
                                            $templateCache.put("placeSpawnTutorialAsked", 1);
                                        })["catch"](function(dataAndEvents) {
                                            return "cancel click" == dataAndEvents && body.url(controller.getSegmentUrl("top.sim-tutorial-index")),
                                            promise.reject();
                                        });
                                    });
                                }
                            }
                            if (db.options.official) {
                                if (2 > cnl) {
                                    defer = defer.then(function() {
                                        return worker.ask({message: '<img src="components/game/room/room-spawn-2sources.png" align="left" style="margin-left:-15px">There is only 1 energy source in this room. It may create a resource deficit when developing your new colony. We recommend to choose a room with 2 energy sources for your first start in the game.<br><br>Do you really want to place your spawn in this room?'}).result;
                                    });
                                }
                            }
                            if (db.options.official) {
                                if (!data.roomStatusInfo.novice || data.roomStatusInfo.novice < Date.now()) {
                                    if (ins.Me) {
                                        if (ins.Me.getGcl() <= 2) {
                                            defer = defer.then(function() {
                                                return worker.ask({message: "<b>Warning!</b> You are to settle a room outside the Novice Area! The <b>Novice Area</b> sector was created in order to protect novice players from fights with more skilled ones in the initial stages of the game. By settling outside of it, you risk becoming an easy prey in the case you are not familiar with the game yet.<br><br>Are you sure you want to found your colony here?", buttonLabel: "Proceed", buttonCancelLabel: "Go to Novice Area"}).result["catch"](function(dataAndEvents) {
                                                    return "cancel click" == dataAndEvents && body.url(controller.getSegmentUrl("top.game-world-map")),
                                                    promise.reject();
                                                });
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        defer.then(function() {
                            return data.roomMode == obj.MODE_WORLD && (ins.Me.credits < 50 && !ins.Me.cpu)
                                ? void body.url(controller.getSegmentUrl("top.order"))
                                : worker.askForName("spawn", $scope.Game.player).then(function(millis) {
                                    return self.placeSpawn(newX, newY, millis, $scope.Game.player);
                                }).then(function(dataAndEvents) {
                                    if (data.selectedAction.action = "view", $scope.Game.play(), data.roomMode == obj.MODE_WORLD) {
                                        if (db.options.official) {
                                            if (dataAndEvents.newbie) {
                                                mixpanel.track("Place first spawn");
                                                ga("send", "event", "World", "Place first spawn", data.roomName);
                                                worker.alert("", {html: '<h4>Congratulations!</h4>\n                                        <p>This is your first room with your first spawn. This is where your expansion within the Screeps World gets started.</p>\n                                        <p>Since you have just spawned, we have turned on <strong>safe mode</strong> in your room. It means that no other creep will be able to use any harmful methods in this room. Safe mode lasts 20,000 game ticks (approx. 15 hours depending on the tick duration), so use this grace period to get familiarized with the game and <a href="http://support.screeps.com/hc/en-us/articles/203339002-Defending-your-room" app-nw-external-link target="_blank">set up your own defenses</a>.</p>\n                                        <p>Good luck and have fun scripting!</p>'});
                                            } else {
                                                mixpanel.track("Respawn");
                                                ga("send", "event", "World", "Respawn");
                                            }
                                        }
                                    } else {
                                        var self = _.find(data.objects, {type: "controller"});
                                        self.user = $scope.Game.player;
                                        /** @type {number} */
                                        self.level = 1;
                                        /** @type {number} */
                                        self.progress = 0;
                                        /** @type {number} */
                                        self.progressTotal = 0;
                                    }
                                })["catch"](function(dataAndEvents) {
                                    if ("out of borders" == dataAndEvents) {
                                        worker.alert("", "This room is not available for settlement yet. Please choose another room.");
                                    }
                                    if ("novice area" == dataAndEvents) {
                                        worker.alert("", "This room is marked as Novice Area. Only players with Global Control Level < 3 can spawn here. Please choose another room.");
                                    }
                                    if ("no cpu" == dataAndEvents) {
                                        body.url(controller.getSegmentUrl("top.order"));
                                    }
                                });
                        });
                    }
                    if ("construct" == data.selectedAction.action && remove(data.selectedAction.construct, data.cursorPos), "view" == data.selectedAction.action) {
                        if (data.selectedAction.changeFlag) {
                            var udataCur = data.selectedAction.changeFlag.color || obj.COLOR_WHITE;
                            var head = data.selectedAction.changeFlag.secondaryColor || udataCur;
                            newX = data.cursorPos.x;
                            newY = data.cursorPos.y;
                            var from = data.selectedAction.changeFlag.name;
                            var p = {
                                type: "flag",
                                _id: "tempFlag_" + data.cursorPos.x + "_" + data.cursorPos.y + "_" + from,
                                color: udataCur,
                                secondaryColor: head,
                                user: $scope.Game.player,
                                x: newX,
                                y: newY,
                                temp: from
                            };
                            data.flags.push(p);
                            self.createFlag(newX, newY, from, udataCur, head, $scope.Game.player);
                            delete data.selectedAction.changeFlag;
                        } else {
                            $scope.$broadcast("view", {event: e});
                        }
                    }
                    if ("flag" == data.selectedAction.action) {
                        render(data.cursorPos);
                    }
                    if ("customize" == data.selectedAction.action) {
                        if ("createCreep" == data.selectedAction.customize) {
                            success(data.cursorPos);
                        }
                        if (_.isObject(data.selectedAction.customize)) {
                            if ("create" == data.selectedAction.customize.action) {
                                init(data.selectedAction.customize.type, data.cursorPos);
                            }
                        }
                    }
                    if ("createInvader" == data.selectedAction.action) {
                        $scope.$broadcast("createInvader");
                    }
                } else {
                    if (data.roomMode == obj.MODE_WORLD) {
                        var msg = data.checkController().msg;
                        if ("spawn" == data.selectedAction.action) {
                            if ("no controller" == msg) {
                                worker.alert("", "There is no Controller in this room. Controllers allow players capture rooms and build facilities in them. A room with no Controller cannot be captured. Please choose another room.");
                            }
                            if ("controller busy" == msg) {
                                worker.alert("", "The Controller in this room is already captured by another player. It seems that somebody has come here ahead of you. Please choose another room.");
                            }
                        }
                        if ("construct" == data.selectedAction.action) {
                            if ("no controller" == msg) {
                                worker.alert("", "There is no Controller in this room. Controllers allow players capture rooms and build facilities in them. Construction is impossible in this room.");
                            }
                            if ("not a controller owner" == msg) {
                                worker.alert("", {html: '<p>You can build facilities in your own rooms only. In order to do that, you must claim the Controller of the room.</p>\n                            <p>Read more about territory control in <a target="_blank" href="http://support.screeps.com/hc/en-us/articles/203086021-Territory-control" app-nw-external-link>How to Play</a> articles.</p>'});
                            }
                            if ("RCL not enough" == msg) {
                                worker.alert("", {html: '<p>The Room Controller Level of this room is insufficient for building this facility. You have to upgrade your Controller to the needed level.</p>\n                            <p>Read more about territory control in <a target="_blank" href="http://support.screeps.com/hc/en-us/articles/203086021-Territory-control" app-nw-external-link>How to Play</a> articles.</p>'});
                            }
                        }
                    }
                }
            };
            /**
                 * @return {undefined}
                 */
            this.save = function() {
                /** @type {(Window|null)} */
                var imgTarget = window.open("");
                var key = _.cloneDeep(data.terrain);
                key = key.concat(_.filter(data.objects, function(statement) {
                    return "wall" == statement.type || "swamp" == statement.type;
                }));
                imgTarget.document.write(JSON.stringify({
                    terrain: [
                        {
                            _id: "terrain",
                            type: "terrain",
                            terrain: arr.encodeTerrain(key)
                        }
                    ],
                    objects: _(data.objects).filter(function(statement) {
                        return "wall" != statement.type && "swamp" != statement.type;
                    }).map(function(config) {
                        return config = _.cloneDeep(config),
                        delete config.room,
                        delete config._id,
                        config;
                    }).value()
                }));
            };
            /**
                 * @return {undefined}
                 */
            this.restore = function() {
                /** @type {*} */
                var options = JSON.parse(data.restoreData);
                options.objects = options.objects.concat(arr.decodeTerrain(options.terrain[0].terrain, "sim"));
                options.objects.forEach(function(self) {
                    if (!self._id) {
                        self._id = arr.getUniqueId(options.objects);
                    }
                    if (2 == self.user) {
                        /** @type {number} */
                        self.user = 1;
                    }
                    /** @type {string} */
                    self.room = "sim";
                    if (self.body) {
                        self.body = _.reduce(self.body, function(assigns, vvar) {
                            return assigns.push(vvar),
                            assigns;
                        }, []);
                    }
                });
                data.objects = options.objects;
                assert.put("rooms.objects", options.objects);
            };
            /**
                 * @return {?}
                 */
            this.isLocationValid = function() {
                if (!data.cursorPos) {
                    return false;
                }
                var currentPosition = data.cursorPos;
                var x = currentPosition.x;
                var y = currentPosition.y;
                if ("none" != data.symmetry && ("diagonal" == data.symmetry && x > y || ("horizontal" == data.symmetry && x > 24 || "quadrant" == data.symmetry && (x > 24 || (y > 24 || x > y))))) {
                    return false;
                }
                if ("construct" == data.selectedAction.action || "spawn" == data.selectedAction.action) {
                    if (_.any(data.objects, {
                        x: x,
                        y: y,
                        type: data.selectedAction.construct
                    })) {
                        return false;
                    }
                    if (_.any(data.objects, {
                        x: x,
                        y: y,
                        type: "constructionSite"
                    })) {
                        return false;
                    }
                    if ("extractor" == data.selectedAction.construct) {
                        return _.any(data.objects, {
                            type: "mineral",
                            x: x,
                            y: y
                        });
                    }
                    if (_.any([
                        data.objects, data.terrain
                    ], function(protoProps) {
                        return _.any(protoProps, function(d) {
                            return d.x == x && (d.y == y && "wall" == d.type);
                        });
                    })) {
                        return false;
                    }
                    if ("road" != data.selectedAction.construct && ("rampart" != data.selectedAction.construct && _.any(data.objects, function(d) {
                        return d.x == x && (d.y == y && ("rampart" != d.type && ("road" != d.type && obj.CONSTRUCTION_COST[d.type])));
                    }))) {
                        return false;
                    }
                    if (0 >= x || (0 >= y || (x >= 49 || y >= 49))) {
                        return false;
                    }
                    if ("road" != data.selectedAction.construct && (1 == x && !_.every([
                        -1, 0, 1
                    ], function(h) {
                        return "wall" == data.getTerrainAtCursor({
                            x: 0,
                            y: y + h
                        });
                    }) || (48 == x && !_.every([
                        -1, 0, 1
                    ], function(h) {
                        return "wall" == data.getTerrainAtCursor({
                            x: 49,
                            y: y + h
                        });
                    }) || (1 == y && !_.every([
                        -1, 0, 1
                    ], function(ox) {
                        return "wall" == data.getTerrainAtCursor({
                            x: x + ox,
                            y: 0
                        });
                    }) || 48 == y && !_.every([
                        -1, 0, 1
                    ], function(ox) {
                        return "wall" == data.getTerrainAtCursor({
                            x: x + ox,
                            y: 49
                        });
                    }))))) {
                        return false;
                    }
                    if ("OK" != data.checkController().msg) {
                        return false;
                    }
                }
                if (data.selectedAction.customize) {
                    /**
                         * @param {number} val
                         * @return {?}
                         */
                    var isNumber = function(val) {
                        return 0 == val || 49 == val;
                    };
                    if ("erase" == data.selectedAction.customize) {
                        return !(isNumber(x) && isNumber(y));
                    }
                    if (_.isEqual(data.selectedAction.customize, {
                        action: "create",
                        type: "extractor"
                    }) && !_.any(data.objects, {
                        type: "mineral",
                        x: x,
                        y: y
                    })) {
                        return false;
                    }
                }
                if ("createInvader" == data.selectedAction.action) {
                    if (0 != x && (49 != x && (0 != y && 49 != y))) {
                        return false;
                    }
                    if ("wall" == data.getTerrainAtCursor()) {
                        return false;
                    }
                }
                return true;
            };
            /**
                 * @param {Node} position
                 * @return {?}
                 */
            this.getTerrainAtCursor = function(position) {
                if (position || data.cursorPos) {
                    if (!position) {
                        position = data.cursorPos;
                    }
                    var reversed = _.filter(data.objects, {
                        x: position.x,
                        y: position.y
                    }).concat(_.filter(data.terrain, {
                        x: position.x,
                        y: position.y
                    }));
                    /** @type {string} */
                    var city_walls = _.any(reversed, {type: "wall"})
                        ? "wall"
                        : _.any(reversed, {type: "swamp"})
                            ? "swamp"
                            : "plain";
                    return city_walls;
                }
            };
            /**
                 * @return {undefined}
                 */
            this.showTutorial = function() {
                child.show();
            };
            /**
                 * @return {undefined}
                 */
            this.removeSelectedObject = function() {
                if (data.selectedObject) {
                    if (_.contains([
                        "flag", "constructionSite"
                    ], data.selectedObject.type)) {
                        if (data.selectedObject.user == $scope.Game.player || data.roomController && data.roomController.user == $scope.Game.player) {
                            /** @type {boolean} */
                            data.selectedObject.tempRemove = true;
                            self.addObjectIntent(data.selectedObject._id, $scope.Game.player, "remove", {});
                            /** @type {null} */
                            data.selectedObject = null;
                        }
                    }
                }
            };
            /**
                 * @return {undefined}
                 */
            this.destroySelectedObject = function() {
                if (data.selectedObject && obj.CONSTRUCTION_COST[data.selectedObject.type]) {
                    /** @type {boolean} */
                    data.selectedObject.tempRemove = true;
                    self.addObjectIntent("room", $scope.Game.player, "destroyStructure", [
                        {
                            id: data.selectedObject._id,
                            roomName: data.selectedObject.room,
                            user: data.roomController.user
                        }
                    ]);
                    /** @type {null} */
                    data.selectedObject = null;
                    var throttledUpdate = $scope.$on("roomObjectsUpdated", function() {
                        engineTools.check();
                        throttledUpdate();
                    });
                }
            };
            /**
                 * @return {undefined}
                 */
            this.zoomIn = function() {
                data.zoomLevel++;
                if (data.zoomLevel >= user.length) {
                    data.zoomLevel--;
                }
                data.zoom = user[data.zoomLevel];
            };
            /**
                 * @return {undefined}
                 */
            this.zoomOut = function() {
                data.zoomLevel--;
                if (data.zoomLevel < 0) {
                    data.zoomLevel++;
                }
                data.zoom = user[data.zoomLevel];
            };
            /**
                 * @param {Event} statement
                 * @return {?}
                 */
            this.creepFilter = function(statement) {
                return "creep" == statement.type && (!statement.ticksToSpawn || statement.ticksToSpawn < 3);
            };
            /**
                 * @return {?}
                 */
            this.finishGame = function() {
                return self.finishGame();
            };
            /**
                 * @return {undefined}
                 */
            this.symmetryMirror = function() {
                var request;
                var key = assert.get("rooms.objects");
                if ("diagonal" == data.symmetry) {
                    _.remove(key, function(point) {
                        return point.y < point.x;
                    });
                    request = _.cloneDeep(key);
                    _.forEach(request, function(data) {
                        var args;
                        if (data.x != data.y) {
                            /** @type {Array} */
                            args = [data.y, data.x];
                            data.x = args[0];
                            data.y = args[1];
                            args;
                            data._id = arr.getUniqueId(key);
                            key.push(data);
                        }
                    });
                }
                if ("horizontal" == data.symmetry) {
                    _.remove(key, function(pair) {
                        return pair.x > 24;
                    });
                    request = _.cloneDeep(key);
                    _.forEach(request, function(remote) {
                        /** @type {number} */
                        remote.x = 49 - remote.x;
                        remote._id = arr.getUniqueId(key);
                        key.push(remote);
                    });
                }
                if ("quadrant" == data.symmetry) {
                    _.remove(key, function(point) {
                        return point.x > 24 || (point.y > 24 || point.y < point.x);
                    });
                    request = _.cloneDeep(key);
                    _.forEach(request, function(data) {
                        var args;
                        if (data.x != data.y) {
                            /** @type {Array} */
                            args = [data.y, data.x];
                            data.x = args[0];
                            data.y = args[1];
                            args;
                            data._id = arr.getUniqueId(key);
                            key.push(data);
                        }
                    });
                    request = _.cloneDeep(key);
                    _.forEach(request, function(element) {
                        /** @type {Object} */
                        var container = element;
                        element = _.cloneDeep(container);
                        /** @type {number} */
                        element.x = 49 - element.x;
                        element._id = arr.getUniqueId(key);
                        key.push(element);
                        element = _.cloneDeep(container);
                        /** @type {number} */
                        element.y = 49 - element.y;
                        element._id = arr.getUniqueId(key);
                        key.push(element);
                        element = _.cloneDeep(container);
                        /** @type {number} */
                        element.x = 49 - element.x;
                        /** @type {number} */
                        element.y = 49 - element.y;
                        element._id = arr.getUniqueId(key);
                        key.push(element);
                    });
                }
                assert.put("rooms.objects", key);
            };
            /**
                 * @return {undefined}
                 */
            this.rotate = function() {
                /** @type {Array} */
                data.objects = [];
                set(function() {
                    var items = assert.get("rooms.objects");
                    items.forEach(function(e) {
                        var startY = e.y;
                        e.y = e.x;
                        /** @type {number} */
                        e.x = 49 - startY;
                        if ("exit" == e.type) {
                            e.exit += 2;
                            if (e.exit > 8) {
                                e.exit -= 8;
                            }
                        }
                        if (_.contains(["portal"], e.type)) {
                            e._id = arr.getUniqueId(items);
                        }
                    });
                    assert.put("rooms.objects", items);
                    data.objects = items;
                }, 10);
            };
            /**
                 * @return {?}
                 */
            this.getChangeAnimClass = function() {
                return "anim-change-" + evt.getExit();
            };
            /**
                 * @return {?}
                 */
            this.timeUntilCanSpawn = function() {
                if (!ins.Me || !ins.Me.lastRespawnDate) {
                    return false;
                }
                /** @type {number} */
                var inner = ins.Me.lastRespawnDate - dataAndEvents.timeCorrection;
                var arr = ins.Me.respawnPenalty || 18E4;
                return Date.now() > inner + arr
                    ? false
                    : Math.floor((inner + arr - Date.now()) / 1E3);
            };
            /**
                 * @return {?}
                 */
            this.worldLaunched = function() {
                return Date.now() >= details.launchTime;
            };
            /**
                 * @return {?}
                 */
            this.runWave = function() {
                return self.runWave();
            };
            /**
                 * @return {undefined}
                 */
            this.pauseSurvival = function() {
                /** @type {boolean} */
                data.survivalEnabled = false;
                self.survivalEnabled(false);
            };
            /**
                 * @return {undefined}
                 */
            this.resumeSurvival = function() {
                /** @type {boolean} */
                data.survivalEnabled = true;
                self.survivalEnabled(true);
            };
            /**
                 * @return {undefined}
                 */
            this.saveObjectsToMemory = function() {
                assert.put("rooms.objects", data.objects);
            };
            /**
                 * @return {undefined}
                 */
            this.goToHistory = function() {
                db.get("game/time").then(function(e) {
                    /** @type {number} */
                    var name = 20 * Math.floor((e.time - 150) / 20);
                    body.url(controller.getSegmentUrl("top.game-room-history") + "?t=" + name);
                });
            };
            this.historyShare = {
                url: "",
                room: "",
                time: 0,
                /**
                     * @return {?}
                     */
                create: function() {
                    var $scope = this;
                    return db.post("game/history-share", {
                        room: room.roomName,
                        time: room.gameTime
                    }).then(function(data) {
                        /** @type {string} */
                        $scope.url = "screeps.com/s/" + data.code;
                        $scope.room = data.room;
                        $scope.time = data.time;
                    });
                }
            };
            /**
                 * @param {Object} action
                 * @return {?}
                 */
            this.isStructureDisabled = function(action) {
                if ("extractor" == action.type && !action.user) {
                    return false;
                }
                if ($scope.Game.simulationMode || void 0 === action._isDisabled) {
                    if (obj.CONSTRUCTION_COST[action.type]) {
                        if ("rampart" == action.type || ("constructedWall" == action.type || "road" == action.type)) {
                            /** @type {boolean} */
                            action._isDisabled = false;
                        } else {
                            var keys = _.filter(data.objects, {
                                type: action.type,
                                user: action.user
                            });
                            var i = data.roomController
                                ? data.roomController.level
                                : 0;
                            if (obj.CONTROLLER_STRUCTURES[action.type][0] || data.roomController && (!(1 > i) && data.roomController.user == action.user)) {
                                if (keys.length > obj.CONTROLLER_STRUCTURES[action.type][i]) {
                                    keys.sort(move(data.roomController));
                                    keys = _.take(keys, obj.CONTROLLER_STRUCTURES[action.type][i]);
                                    /** @type {boolean} */
                                    action._isDisabled = !_.contains(keys, action);
                                } else {
                                    /** @type {boolean} */
                                    action._isDisabled = false;
                                }
                            } else {
                                /** @type {boolean} */
                                action._isDisabled = true;
                            }
                        }
                    } else {
                        /** @type {boolean} */
                        action._isDisabled = false;
                    }
                }
                return action._isDisabled;
            };
            /**
                 * @param {Array} buf
                 * @return {?}
                 */
            this.calcResources = function(buf) {
                return _.sum(obj.RESOURCES_ALL, function(off) {
                    return buf[off];
                });
            };
            if (config.isDebug) {
                $scope.$watch(function() {
                    return data.selectedObject;
                }, function(dataAndEvents) {
                    /** @type {string} */
                    data.selectedObjectJSON = JSON.stringify(data.selectedObject);
                }, true);
                /**
                     * @return {undefined}
                     */
                this.setSelectedObjectJSON = function() {
                    var objID = _.findIndex(data.objects, {_id: data.selectedObject._id});
                    /** @type {*} */
                    data.selectedObject = data.objects[objID] = JSON.parse(data.selectedObjectJSON);
                };
            }
            /**
                 * @param {number} size
                 * @param {number} bytes
                 * @param {string} timer
                 * @return {undefined}
                 */
            var update = function(size, bytes, timer) {
                var children = assert.get("rooms.terrain");
                var c = _.find(children, {room: "sim"});
                /** @type {string} */
                var g = "wall" == timer
                    ? "1"
                    : "swamp" == timer
                        ? "2"
                        : "0";
                c.terrain = c.terrain.substring(0, 50 * bytes + size) + g + c.terrain.substring(50 * bytes + size + 1);
                empty();
                result = {};
            };
            /**
                 * @return {?}
                 */
            var empty = function() {
                return self.getRoomTerrain().then(function(key) {
                    data.terrain = key;
                });
            };
            /**
                 * @param {string} id
                 * @param {Object} position
                 * @param {string} file
                 * @return {?}
                 */
            var init = function(id, position, file) {
                /** @type {Array} */
                var locals = [
                    "H",
                    "H",
                    "H",
                    "H",
                    "H",
                    "O",
                    "O",
                    "O",
                    "O",
                    "O",
                    "Z",
                    "Z",
                    "Z",
                    "K",
                    "K",
                    "K",
                    "X",
                    "U",
                    "U",
                    "U",
                    "L",
                    "L",
                    "L"
                ];
                return promise(function(behavior, done) {
                    if (_.contains([
                        "swamp",
                        "wall",
                        "road",
                        "spawn",
                        "extension",
                        "rampart",
                        "constructedWall",
                        "source",
                        "keeperLair",
                        "controller",
                        "portal",
                        "link",
                        "storage",
                        "tower",
                        "observer",
                        "powerBank",
                        "powerSpawn",
                        "energy",
                        "invader",
                        "mineral",
                        "terminal",
                        "lab",
                        "extractor",
                        "container",
                        "nuker"
                    ], id)) {
                        /** @type {Object} */
                        var p = position;
                        var i = p.x;
                        var size = p.y;
                        if ("custom" != $scope.Game.simulationMode && ("survival" != $scope.Game.simulationMode && "spawn" != data.selectedAction.action)) {
                            return void done();
                        }
                        var options = {
                            type: id,
                            x: i,
                            y: size,
                            room: "sim",
                            name: file
                        };
                        if ("wall" == id || "swamp" == id) {
                            return void update(i, size, id);
                        }
                        if ("spawn" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: "spawn" == data.selectedAction.action
                                ? obj.SPAWN_ENERGY_START
                                : obj.SPAWN_ENERGY_CAPACITY,
                            energyCapacity: obj.SPAWN_ENERGY_CAPACITY,
                            hits: obj.SPAWN_HITS,
                            hitsMax: obj.SPAWN_HITS,
                            spawning: null
                        }), "extension" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: 0,
                            energyCapacity: 0,
                            hits: obj.EXTENSION_HITS,
                            hitsMax: obj.EXTENSION_HITS
                        }), "storage" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: obj.STORAGE_CAPACITY / 2,
                            energyCapacity: obj.STORAGE_CAPACITY,
                            L: 0.3 * obj.STORAGE_CAPACITY,
                            hits: obj.STORAGE_HITS,
                            hitsMax: obj.STORAGE_HITS
                        }), "link" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: obj.LINK_CAPACITY / 2,
                            energyCapacity: obj.LINK_CAPACITY,
                            hits: obj.LINK_HITS,
                            hitsMax: obj.LINK_HITS,
                            cooldown: 0
                        }), "tower" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: obj.TOWER_CAPACITY / 2,
                            energyCapacity: obj.TOWER_CAPACITY,
                            hits: obj.TOWER_HITS,
                            hitsMax: obj.TOWER_HITS
                        }), "terminal" == id && _.extend(options, {
                            user: $scope.Game.player,
                            energy: obj.TERMINAL_CAPACITY / 2,
                            energyCapacity: obj.TERMINAL_CAPACITY,
                            hits: obj.TERMINAL_HITS,
                            hitsMax: obj.TERMINAL_HITS
                        }), "extractor" == id && _.extend(options, {
                            user: $scope.Game.player,
                            hits: obj.EXTRACTOR_HITS,
                            hitsMax: obj.EXTRACTOR_HITS
                        }), "lab" == id && _.extend(options, {
                            user: $scope.Game.player,
                            mineralAmount: obj.LAB_MINERAL_CAPACITY / 2,
                            mineralType: locals[Math.floor(Math.random() * locals.length)],
                            mineralCapacity: obj.LAB_MINERAL_CAPACITY,
                            energy: obj.LAB_ENERGY_CAPACITY / 2,
                            energyCapacity: obj.LAB_ENERGY_CAPACITY,
                            hits: obj.LAB_HITS,
                            hitsMax: obj.LAB_HITS,
                            cooldown: 0
                        }), "observer" == id && _.extend(options, {
                            user: $scope.Game.player,
                            hits: obj.OBSERVER_HITS,
                            hitsMax: obj.OBSERVER_HITS
                        }), "source" == id && _.extend(options, {
                            energy: obj.SOURCE_ENERGY_CAPACITY,
                            energyCapacity: obj.SOURCE_ENERGY_CAPACITY,
                            ticksToRegeneration: obj.ENERGY_REGEN_TIME
                        }), "mineral" == id) {
                            var local = locals[Math.floor(Math.random() * locals.length)];
                            _.extend(options, {
                                mineralType: local,
                                mineralAmount: obj.MINERAL_MIN_AMOUNT[local] * (1 + Math.random() * (obj.MINERAL_RANDOM_FACTOR - 1)),
                                ticksToRegeneration: null
                            });
                        }
                        if ("rampart" == id && _.extend(options, {
                            user: $scope.Game.player,
                            hits: obj.RAMPART_HITS,
                            hitsMax: obj.RAMPART_HITS,
                            nextDecayTime: data.gameTime + obj.RAMPART_DECAY_TIME
                        }), "powerBank" == id && _.extend(options, {
                            power: Math.floor(Math.random() * (obj.POWER_BANK_CAPACITY_MAX - obj.POWER_BANK_CAPACITY_MIN) + obj.POWER_BANK_CAPACITY_MIN),
                            hits: obj.POWER_BANK_HITS,
                            hitsMax: obj.POWER_BANK_HITS,
                            decayTime: data.gameTime + obj.POWER_BANK_DECAY
                        }), "powerSpawn" == id && _.extend(options, {
                            user: $scope.Game.player,
                            power: obj.POWER_SPAWN_POWER_CAPACITY / 2,
                            powerCapacity: obj.POWER_SPAWN_POWER_CAPACITY,
                            energy: obj.POWER_SPAWN_ENERGY_CAPACITY / 2,
                            energyCapacity: obj.POWER_SPAWN_ENERGY_CAPACITY,
                            hits: obj.POWER_SPAWN_HITS,
                            hitsMax: obj.POWER_SPAWN_HITS
                        }), "container" == id && _.extend(options, {
                            energy: obj.CONTAINER_CAPACITY / 2,
                            energyCapacity: obj.CONTAINER_CAPACITY,
                            hits: obj.CONTAINER_HITS,
                            hitsMax: obj.CONTAINER_HITS,
                            nextDecayTime: data.gameTime + obj.CONTAINER_DECAY_TIME
                        }), "road" == id) {
                            var terse = obj.ROAD_HITS;
                            if (_.any([
                                data.objects, data.terrain
                            ], function(protoProps) {
                                return _.any(protoProps, {
                                    x: i,
                                    y: size,
                                    type: "swamp"
                                });
                            })) {
                                terse *= obj.CONSTRUCTION_COST_ROAD_SWAMP_RATIO;
                            }
                            _.extend(options, {
                                hits: terse,
                                hitsMax: terse
                            });
                        }
                        if ("constructedWall" == id) {
                            _.extend(options, {
                                hits: obj.WALL_HITS,
                                hitsMax: obj.WALL_HITS_MAX
                            });
                        }
                        if ("keeperLair" == id) {
                            _.extend(options, {
                                ticksToSpawn: 1,
                                user: "3"
                            });
                        }
                        if ("controller" == id) {
                            _.extend(options, {level: 0});
                        }
                        if ("nuker" == id) {
                            _.extend(options, {
                                user: $scope.Game.player,
                                hits: obj.NUKER_HITS,
                                hitsMax: obj.NUKER_HITS,
                                energy: obj.NUKER_ENERGY_CAPACITY,
                                energyCapacity: obj.NUKER_ENERGY_CAPACITY,
                                G: obj.NUKER_GHODIUM_CAPACITY,
                                GCapacity: obj.NUKER_GHODIUM_CAPACITY,
                                cooldownTime: data.gameTime + 10
                            });
                        }
                        /**
                             * @return {?}
                             */
                        var init = function() {
                            var key = assert.get("rooms.objects");
                            return _.any(key, {
                                x: position.x,
                                y: position.y,
                                type: id
                            })
                                ? void done()
                                : ("controller" == id && _.remove(key, {type: "controller"}), "storage" == id && _.remove(key, {type: "storage"}), options._id = self.genUniqueId(key), key.push(options), assert.put("rooms.objects", key), behavior(), void(result = {}));
                        };
                        if ("spawn" != id || options.name) {
                            init();
                        } else {
                            worker.askForName("spawn", $scope.Game.player).then(function(name) {
                                /** @type {string} */
                                options.name = name;
                                init();
                            })["catch"](function() {
                                return done();
                            });
                        }
                    }
                });
            };
            /**
                 * @param {?} info
                 * @return {undefined}
                 */
            var render = function(info) {
                self.genUniqueFlagName($scope.Game.player).then(function(errorName) {
                    $modal.open({
                        templateUrl: "components/game/room/dlg-flag/dlg-flag.html?bust=1479290327467",
                        controller: "DlgFlag as DlgFlag",
                        resolve: {
                            /**
                                 * @return {?}
                                 */
                            data: function() {
                                return new Object({name: errorName, player: $scope.Game.player});
                            }
                        }
                    }).result.then(function(p) {
                        var d = {
                            type: "flag",
                            _id: "tempFlag_" + info.x + "_" + info.y + "_" + p.name,
                            color: p.color,
                            secondaryColor: p.secondaryColor,
                            user: $scope.Game.player,
                            x: info.x,
                            y: info.y,
                            temp: p.name
                        };
                        data.flags.push(d);
                        self.createFlag(info.x, info.y, p.name, p.color, p.secondaryColor, $scope.Game.player)["catch"](function(dataAndEvents) {
                            if ("flags limit exceeded" == dataAndEvents) {
                                worker.alert("", "You cannot create more than 10,000 flags.");
                            }
                        });
                    });
                });
            };
            /**
                 * @param {string} owner
                 * @param {?} position
                 * @return {undefined}
                 */
            var remove = function(owner, position) {
                if (owner) {
                    var promise;
                    var obj = {
                        type: "constructionSite",
                        _id: "tempConstructionSite_" + position.x + "_" + position.y,
                        x: position.x,
                        y: position.y,
                        user: $scope.Game.player,
                        structureType: owner,
                        temp: true
                    };
                    data.objects.push(obj);
                    promise = "spawn" == owner
                        ? worker.askForName("spawn", $scope.Game.player).then(function(deepDataAndEvents) {
                            return self.createConstruction(owner, position.x, position.y, $scope.Game.player, deepDataAndEvents);
                        })
                        : self.createConstruction(owner, position.x, position.y, $scope.Game.player);
                    promise.then(function(resp) {
                        return obj.temp = resp;
                    });
                    promise["catch"](function(dataAndEvents) {
                        _.remove(data.objects, obj);
                        if ("too many" == dataAndEvents) {
                            worker.alert("", "You have too many construction sites. The maximum number of construction sites per player is 100.");
                        }
                    });
                }
            };
            /**
                 * @param {?} info
                 * @return {undefined}
                 */
            var success = function(info) {
                self.genUniqueNameForType("creep", $scope.Game.player).then(function(errorName) {
                    $modal.open({
                        templateUrl: "components/game/room/dlg-creep/dlg-creep.html?bust=1479290327467",
                        controller: "DlgCreep as DlgCreep",
                        resolve: {
                            /**
                                 * @return {?}
                                 */
                            data: function() {
                                return new Object({name: errorName});
                            }
                        }
                    }).result.then(function(details) {
                        var expected = details.body;
                        /** @type {number} */
                        var curtop = 0;
                        expected = _.map(expected, function(paramType) {
                            return "carry" == paramType && (curtop += obj.CARRY_CAPACITY), {
                                type: paramType,
                                hits: 100
                            };
                        });
                        var items = assert.get("rooms.objects");
                        items.push({
                            _id: self.genUniqueId(),
                            type: "creep",
                            name: details.name,
                            body: expected,
                            x: info.x,
                            y: info.y,
                            user: $scope.Game.player,
                            room: "sim",
                            energy: 0,
                            power: 0,
                            energyCapacity: curtop,
                            hits: 100 * expected.length,
                            hitsMax: 100 * expected.length,
                            spawning: false,
                            fatigue: 0,
                            ageTime: data.gameTime + (_.any(expected, {type: "claim"})
                                ? obj.CREEP_CLAIM_LIFE_TIME
                                : obj.CREEP_LIFE_TIME)
                        });
                        assert.put("rooms.objects", items);
                    });
                });
            };
            /**
                 * @param {Object} pos
                 * @return {?}
                 */
            var move = function(pos) {
                return pos.pos && (pos = pos.pos),
                function(pos2, position) {
                    if (pos2.pos) {
                        pos2 = pos2.pos;
                    }
                    if (position.pos) {
                        position = position.pos;
                    }
                    /** @type {number} */
                    var a = Math.max(window.Math.abs(pos2.x - pos.x), window.Math.abs(pos2.y - pos.y));
                    /** @type {number} */
                    var b = Math.max(window.Math.abs(position.x - pos.x), window.Math.abs(position.y - pos.y));
                    return a - b;
                };
            };
            /**
                 * @param {Object} entry
                 * @return {?}
                 */
            this.checkController = function(entry) {
                if (!entry) {
                    entry = data.selectedAction;
                }
                var options = _.find(data.objects, {type: "controller"});
                if ("spawn" == entry.action) {
                    return options
                        ? options.user
                            ? {
                                msg: "controller busy"
                            }
                            : options.reservation
                                ? {
                                    msg: "controller busy"
                                }
                                : {
                                    msg: "OK"
                                }
                        : {
                            msg: "no controller"
                        };
                }
                if (entry.construct) {
                    /** @type {number} */
                    var prev = 0;
                    if (options && (prev = options.level), options && (options.user && options.user != $scope.Game.player || options.reservation && options.reservation.user != $scope.Game.player)) {
                        return {msg: "not a controller owner", rcl: 1};
                    }
                    if ("road" == entry.construct) {
                        return {msg: "OK", count: 2500};
                    }
                    var b = _(data.objects).filter(function(child) {
                        return child.type == entry.construct || "constructionSite" == child.type && child.structureType == entry.construct;
                    }).size();
                    var a = obj.CONTROLLER_STRUCTURES[entry.construct][prev];
                    if (a > b) {
                        return {
                            msg: "OK",
                            count: a - b
                        };
                    }
                    if (options && options.level) {
                        /** @type {number} */
                        var node = -1;
                        var fragment = options.level + 1;
                        for (; 8 >= fragment; fragment++) {
                            if (obj.CONTROLLER_STRUCTURES[entry.construct][fragment] > b) {
                                node = fragment;
                                break;
                            }
                        }
                        return {msg: "RCL not enough", rcl: node};
                    }
                    return {msg: "RCL not enough", rcl: 1};
                }
            };
            child.trigger("roomEntered");
        }
    ]),
    module.controller("GenericObject", [
        "$scope",
        "$rootScope",
        "Constants",
        function($scope, dataAndEvents, $location) {
            $scope.Math = Math;
            $scope.Constants = $location;
        }
    ]),
    module.controller("Top.Game.Room.Invasion", [
        "$scope",
        "MemoryStorage",
        "Connection",
        "Dialogs",
        function(self, dataAndEvents, ctx, o) {
            var d = this;
            /** @type {string} */
            this.type = "Melee";
            /** @type {string} */
            this.size = "small";
            self.$on("createInvader", function() {
                ctx.createInvader(self.Room.cursorPos.x, self.Room.cursorPos.y, d.type, d.size, d.boosted)["catch"](function(dataAndEvents) {
                    if ("not owned" == dataAndEvents) {
                        o.alert("", "You must own or reserve this room to generate invaders.");
                    }
                });
            });
        }
    ]),
    module.directive("appAsideBlock", function() {
        return {
            scope: {
                heading: "@",
                show: "=visibilityModel"
            },
            transclude: true,
            templateUrl: "room-aside-block-template",
            /**
                 * @return {undefined}
                 */
            controller: function() {
                var activeItem = this;
                /**
                     * @return {?}
                     */
                this.toggle = function() {
                    return activeItem.show = !activeItem.show;
                };
            },
            controllerAs: "AsideBlock",
            bindToController: true
        };
    }),
    module.directive("appRoomCursorPos", [
        "$parse",
        "$document",
        function($parse, el) {
            return {
                /**
                     * @param {?} scope
                     * @param {?} elem
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(scope, elem, attrs) {
                    /** @type {boolean} */
                    var f = false;
                    var $transition = _.throttle(function() {
                        return scope.$apply();
                    }, 15);
                    $(elem).mousemove(function(event) {
                        var nodeOfs = $(event.target).offset();
                        /** @type {number} */
                        var moveX = Math.floor((event.pageX - nodeOfs.left) / $(elem).width() * 50);
                        /** @type {number} */
                        var moveY = Math.floor((event.pageY - nodeOfs.top) / $(elem).height() * 50);
                        $parse(attrs.appRoomCursorPos).assign(scope, {
                            x: moveX,
                            y: moveY
                        });
                        if (f) {
                            $parse(attrs.appRoomCursorPaint)(scope, {$event: event});
                        }
                        $transition();
                    });
                    $(elem).mouseleave(function(dataAndEvents) {
                        scope.$apply(function() {
                            $parse(attrs.appRoomCursorPos).assign(scope, null);
                        });
                    });
                    $(elem).click(function(event) {
                        return scope.$apply(function() {
                            $parse(attrs.appRoomCursorClick)(scope, {$event: event});
                        }),
                        false;
                    });
                    $(elem).mousedown(function() {
                        return scope.$apply(function() {
                            /** @type {boolean} */
                            f = true;
                        }),
                        false;
                    });
                    /**
                         * @param {Event} event
                         * @return {?}
                         */
                    var fn = function(event) {
                        return scope.$apply(function() {
                            if (f) {
                                $parse(attrs.appRoomCursorPaint)(scope, {$event: event});
                            }
                            /** @type {boolean} */
                            f = false;
                        }),
                        false;
                    };
                    $(el).bind("mouseup", fn);
                    scope.$on("$destroy", function() {
                        el.unbind("mouseup", fn);
                    });
                }
            };
        }
    ]),
    module.directive("appRoomResize", [
        "$timeout",
        "$document",
        "RoomChanger",
        "RoomCanvasRenderer",
        function(dataAndEvents, $this, matchIndexes, p) {
            return {
                /**
                     * @param {?} scope
                     * @param {Object} el
                     * @param {(Object|string)} attrs
                     * @return {undefined}
                     */
                link: function(scope, el, attrs) {
                    var tref;
                    var obj;
                    var dest;
                    /**
                         * @param {boolean} dataAndEvents
                         * @return {undefined}
                         */
                    var initialize = function(dataAndEvents) {
                        /**
                             * @return {undefined}
                             */
                        function render() {
                            /** @type {number} */
                            tref = setTimeout(function() {
                                return p.dirty || !p.isComplete()
                                    ? void render()
                                    : (el.css({visibility: "visible"}), bar.css({display: "none"}), void(tref = null));
                            }, 20);
                        }
                        var quat = scope.$eval(attrs.zoom);
                        var bar = (scope.$eval(attrs.panLeft), scope.$eval(attrs.panTop), el.parent().find(".resize-placeholder"));
                        [el, bar].forEach(function($item) {
                            var val = $item.parent().width();
                            var olen = $item.parent().height();
                            var rval = val;
                            /** @type {number} */
                            var i = rval * quat / 100;
                            if (!obj) {
                                obj = matchIndexes.getPanScaled(i);
                            }
                            $item.css({
                                width: i + "px",
                                height: i + "px",
                                left: (val - i) / 2 + obj.x + "px",
                                top: (olen - i) / 2 + obj.y + "px"
                            });
                        });
                        if (dest != quat || dataAndEvents) {
                            el.css({visibility: "hidden"});
                            bar.css({display: "block"});
                            if (tref) {
                                clearTimeout(tref);
                            }
                            /** @type {boolean} */
                            p.dirty = true;
                            render();
                        }
                        dest = quat;
                    };
                    initialize();
                    $(window).resize(function() {
                        return initialize(true);
                    });
                    scope.$on("resize", function() {
                        return initialize();
                    });
                    scope.$watch(attrs.zoom, function() {
                        scope.$broadcast("resize");
                        initialize();
                    });
                    var $parse = _.throttle(scope.$applyAsync, 500);
                    el.parent().mousedown(function(touches) {
                        return scope.Room.panActive = {
                            x: touches.pageX,
                            y: touches.pageY
                        },
                        $parse(),
                        false;
                    });
                    /**
                         * @param {Touch} event
                         * @return {undefined}
                         */
                    var handler = function(event) {
                        if (scope.Room.panActive) {
                            obj.x += event.pageX - scope.Room.panActive.x;
                            obj.y += event.pageY - scope.Room.panActive.y;
                            scope.Room.panActive = {
                                x: event.pageX,
                                y: event.pageY
                            };
                            initialize();
                        }
                        $parse();
                    };
                    /**
                         * @param {?} e
                         * @return {undefined}
                         */
                    var clickHandler = function(e) {
                        scope.$applyAsync(function() {
                            /** @type {null} */
                            scope.Room.panActive = null;
                        });
                    };
                    el.parent().bind("wheel", function(e) {
                        if (!(window.Math.abs(e.originalEvent.deltaY) < 4)) {
                            scope.$applyAsync(function() {
                                window.console.log("wheel deltaY=" + e.originalEvent.deltaY);
                                var zoom = scope.Room.zoom;
                                var b = el.width();
                                var a = el.parent().width();
                                var g = el.parent().height();
                                /** @type {number} */
                                var targetX = e.originalEvent.pageX - el.parent().offset().left;
                                /** @type {number} */
                                var targetY = e.originalEvent.pageY - el.parent().offset().top;
                                if (e.originalEvent.deltaY < 0) {
                                    scope.Room.zoomIn();
                                } else {
                                    scope.Room.zoomOut();
                                }
                                initialize();
                                var r = el.width();
                                obj.x += (targetX - obj.x - (a - b) / 2) * (1 - scope.Room.zoom / zoom) + (a - b) / 2 + (r - a) / 2;
                                obj.y += (targetY - obj.y - (g - b) / 2) * (1 - scope.Room.zoom / zoom) + (g - b) / 2 + (r - g) / 2;
                            });
                        }
                    });
                    $this.bind("mousemove", handler);
                    $this.bind("mouseup", clickHandler);
                    scope.$on("$destroy", function() {
                        $this.unbind("mousemove", handler);
                        $this.unbind("mouseup", clickHandler);
                    });
                }
            };
        }
    ]),
    module.directive("appRoomConstructionAvailable", function() {
        return {
            templateUrl: "room-construction-available",
            bindToController: {
                structure: "@"
            },
            /**
                 * @return {undefined}
                 */
            controller: function() {},
            controllerAs: "RoomConstructionAvailable",
            scope: true
        };
    }),
    module.directive("appRoomDestroyStructure", [
        "Auth",
        "Dialogs",
        function(opts, o) {
            return {
                templateUrl: "room-destroy-structure",
                bindToController: {},
                controller: [
                    "$scope",
                    function(self) {
                        var $window = this;
                        /** @type {boolean} */
                        this.confirm = false;
                        /**
                             * @return {undefined}
                             */
                        this.start = function() {
                            if (_.any(self.Room.objects, function(player) {
                                return "creep" == player.type && (player.user != self.Game.player && (0 != player.user || (!opts.Me || self.Game.player != opts.Me._id)));
                            })) {
                                o.alert("", "It is not allowed to destroy a structure when hostile creeps are in the room.");
                            } else {
                                /** @type {boolean} */
                                $window.confirm = true;
                            }
                        };
                    }
                ],
                controllerAs: "RoomDestroyStructure",
                scope: true
            };
        }
    ]),
    module.filter("orderByNameNumerically", [
        "$filter",
        function($sanitize) {
            return function(copy) {
                return _.isObject(copy) && !_.isArray(copy)
                    ? (copy = $sanitize("keyFilter")(copy),
                    copy.sort(function(value, item) {
                        return parseInt(value.$name) - parseInt(item.$name);
                    }),
                    copy)
                    : copy;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_source_47_source__ = function() {
    var ngModule = angular.module("app.game.source", []);
    return ngModule.controller("Source", [
        "$scope",
        function($scope) {
            $scope.Math = Math;
        }
    ]),
    ngModule.directive("appGameSource", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "="
            },
            templateUrl: "components/game/room/source/source.html?bust=1479290327467",
            bindToController: true,
            controller: "Source as Source"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_spawn_47_spawn__ = function() {
    var app = angular.module("app.game.spawn", []);
    return app.controller("Spawn", [
        "$scope",
        "$rootScope",
        "Tutorial",
        "Connection",
        function($scope, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            var plane = this;
            $scope.Math = Math;
            /**
                 * @return {?}
                 */
            this.isSpawning = function() {
                return plane.objectData.spawning;
            };
        }
    ]),
    app.directive("appGameSpawn", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                users: "="
            },
            templateUrl: "components/game/room/spawn/spawn.html?bust=1479290327467",
            bindToController: true,
            controller: "Spawn as Spawn"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_storage_47_storage__ = function() {
    var ngModule = angular.module("app.game.storage", []);
    return ngModule.controller("Storage", [
        "$scope",
        "Connection",
        "Constants",
        function($scope, dataAndEvents, data) {
            var plane = this;
            $scope.Math = Math;
            $scope.Constants = data;
            /**
                 * @return {undefined}
                 */
            var save = function() {
                /** @type {number} */
                plane.resourcesTotal = 0;
                data.RESOURCES_ALL.forEach(function(tx) {
                    if (plane.objectData[tx]) {
                        plane.resourcesTotal += plane.objectData[tx];
                    }
                });
            };
            $scope.$on("roomObjectsUpdated", save);
            save();
        }
    ]),
    ngModule.directive("appGameStorage", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "="
            },
            templateUrl: "components/game/room/storage/storage.html?bust=1479290327467",
            bindToController: true,
            controller: "Storage as Storage"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_terminal_47_terminal__ = function() {
    var app = angular.module("app.game.terminal", []);
    return app.controller("Terminal", [
        "$scope",
        "$element",
        "Connection",
        "Constants",
        function(self, dataAndEvents, deepDataAndEvents, filePair) {
            var plane = this;
            self.Math = Math;
            self._ = _;
            /**
                 * @return {undefined}
                 */
            var onComplete = function() {
                /** @type {number} */
                plane.resourcesTotal = 0;
                filePair.RESOURCES_ALL.forEach(function(tx) {
                    if (plane.objectData[tx]) {
                        plane.resourcesTotal += plane.objectData[tx];
                    }
                });
            };
            self.$on("roomObjectsUpdated", onComplete);
            onComplete();
        }
    ]),
    app.directive("appGameTerminal", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/terminal/terminal.html?bust=1479290327467",
            bindToController: true,
            controller: "Terminal as Terminal"
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_tower_47_tower__ = function() {
    var module = angular.module("app.game.tower", []);
    return module.controller("Tower", [
        "$scope",
        "$element",
        "Connection",
        "$timeout",
        function(self, sourceContainer, dataAndEvents, $sanitize) {
            var options = this;
            self.Math = Math;
            self._ = _;
            /** @type {boolean} */
            this.animActive = false;
            /** @type {number} */
            this.rotate = Math.random() * Math.PI * 2;
            this.shotAnim = void 0;
            /**
                 * @param {number} x
                 * @param {number} targetY
                 * @return {undefined}
                 */
            var draw = function(x, targetY) {
                /** @type {number} */
                var a = x - options.objectData.x;
                /** @type {number} */
                var o = targetY - options.objectData.y;
                /** @type {number} */
                var result = (0 == a
                    ? o > 0
                        ? -Math.PI / 2
                        : Math.PI / 2
                    : Math.atan(o / a)) - Math.PI / 2;
                if (a > 0) {
                    result += Math.PI;
                }
                for (; result - options.rotate > Math.PI;) {
                    result -= 2 * Math.PI;
                }
                for (; result - options.rotate < -Math.PI;) {
                    result += 2 * Math.PI;
                }
                /** @type {number} */
                options.rotate = result;
            };
            self.$on("roomObjectsUpdated", function() {
                /** @type {boolean} */
                options.animActive = true;
                /** @type {null} */
                options.workAnim = null;
                if (options.objectData.actionLog && (options.objectData.actionLog.attack || (options.objectData.actionLog.heal || options.objectData.actionLog.repair))) {
                    options.shotAnim = _.cloneDeep(options.objectData.actionLog.attack || (options.objectData.actionLog.heal || options.objectData.actionLog.repair));
                    /** @type {string} */
                    options.shotAnim.type = options.objectData.actionLog.attack
                        ? "attack"
                        : options.objectData.actionLog.heal
                            ? "heal"
                            : "repair";
                    draw(options.shotAnim.x, options.shotAnim.y);
                    $(sourceContainer).find(".anim-shot animate").each(function(dataAndEvents, a) {
                        return a.beginElement();
                    });
                    if (options.objectData.actionLog.repair) {
                        options.workAnim = {
                            size: 46,
                            x: options.objectData.actionLog.repair.x,
                            y: options.objectData.actionLog.repair.y
                        };
                        $sanitize(function() {
                            return $(sourceContainer).find(".anim-work animate").each(function(dataAndEvents, a) {
                                return a.beginElement();
                            });
                        }, 0);
                    }
                } else {
                    /** @type {null} */
                    options.shotAnim = null;
                }
            });
        }
    ]),
    module.directive("appGameTower", function() {
        return {
            scope: {
                objectData: "=",
                displayOptions: "=",
                player: "=",
                speed: "="
            },
            templateUrl: "components/game/room/tower/tower.html?bust=1479290327467",
            bindToController: true,
            controller: "Tower as Tower"
        };
    }),
    module.directive("appGameTowerAutoRotate", function() {
        return {
            require: "^appGameTower",
            /**
                 * @param {?} $scope
                 * @param {Object} $element
                 * @param {?} tabCtrl
                 * @param {?} scope
                 * @return {undefined}
                 */
            link: function($scope, $element, tabCtrl, scope) {
                /** @type {boolean} */
                var e = false;
                /** @type {number} */
                var f = Date.now();
                /** @type {number} */
                var oldInput = -1;
                /** @type {number} */
                var h = Date.now();
                /**
                     * @return {undefined}
                     */
                var update = function() {
                    if (!e) {
                        if (!scope.shotAnim) {
                            if (Date.now() > h + 1E4) {
                                /** @type {number} */
                                scope.rotate = Math.random() * Math.PI * 2;
                                /** @type {number} */
                                h = Date.now();
                            }
                        }
                        if (scope.shotAnim) {
                            /** @type {number} */
                            h = Date.now();
                        }
                        if (oldInput != scope.rotate) {
                            $element.css({
                                transform: "rotate(" + scope.rotate + "rad)",
                                transition: $scope.Tower.displayOptions.animations
                                    ? "transform " + (scope.shotAnim
                                        ? "0.1s"
                                        : "2s")
                                    : "none"
                            });
                        }
                        /** @type {number} */
                        f = Date.now();
                        oldInput = scope.rotate;
                        setTimeout(update, 30);
                    }
                };
                update();
                $scope.$on("$destroy", function() {
                    return e = true;
                });
            }
        };
    }), {};
}();
var $__app_95_components_47_game_47_room_47_view_45_popup_47_view_45_popup__ = function() {
    var module = angular.module("app.game.room.view-popup", []);
    return module.controller("ViewPopup", [
        "$scope",
        "Tutorial",
        "$rootScope",
        function($httpBackend, chain, $rootScope) {
            var col = this;
            /** @type {boolean} */
            this.visible = false;
            /**
                 * @param {Object} data
                 * @return {undefined}
                 */
            this.select = function(data) {
                /** @type {Object} */
                $httpBackend.Room.selectedObject = data;
                $rootScope.$broadcast("roomObjectSelected", data);
                /** @type {boolean} */
                col.visible = false;
                chain.trigger("view", {object: data});
                if ($httpBackend.Room.rotateCreepOnClick) {
                    if ("creep" == data.type) {
                        $httpBackend.$broadcast("rotateCreep", {_id: data._id});
                    }
                }
            };
        }
    ]),
    module.directive("appViewPopup", [
        "$document",
        "MemoryStorage",
        "$timeout",
        function(pagerItem, dataAndEvents, $transition) {
            return {
                templateUrl: "components/game/room/view-popup/view-popup.html?bust=1479290327467", controller: "ViewPopup as ViewPopup", bindToController: true,
                /**
                     * @param {?} self
                     * @param {?} tabCtrl
                     * @param {?} scope
                     * @param {Object} layer
                     * @return {undefined}
                     */
                link: function(self, tabCtrl, scope, layer) {
                    self.$on("view", function(dataAndEvents, evt) {
                        /** @type {null} */
                        self.Room.selectedObject = null;
                        $transition(function() {
                            layer.mouseX = (evt.event.offsetX || evt.event.clientX - $(evt.event.target).offset().left) + 10;
                            layer.mouseY = (evt.event.offsetY || evt.event.clientY - $(evt.event.target).offset().top) + 10;
                            var array = self.Room.objects;
                            var flags = self.Room.flags;
                            layer.objects = _.filter([].concat(array, flags), function(item) {
                                return item.temp
                                    ? false
                                    : "creep" == item.type && item.spawning
                                        ? false
                                        : item.x == self.Room.cursorPos.x && (item.y == self.Room.cursorPos.y && ("wall" != item.type && ("swamp" != item.type && "exit" != item.type)));
                            });
                            /** @type {boolean} */
                            layer.visible = layer.objects.length > 1;
                            if (1 == layer.objects.length) {
                                layer.select(layer.objects[0]);
                            }
                            if (0 == layer.objects.length) {
                                layer.select(null);
                            }
                        }, 0);
                    });
                    $(pagerItem).click(function() {
                        self.$apply(function() {
                            return layer.visible = false;
                        });
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_room_47_walls__ = function() {
    var value = angular.module("app.game.room.walls", []);
    return value.factory("RoomWalls", [
        "Connection",
        function(dataAndEvents) {
            return function(placeholders, process, dataAndEvents) {
                /**
                 * @param {number} i
                 * @param {number} n
                 * @return {undefined}
                 */
                function f(i, n) {
                    m += i > 0 && (n > 0 && !pieceEltss[i - 1][n])
                        ? "a 50 50 0 0 0 -50 -50 h 50 "
                        : "v -50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function a(i, j) {
                    m += j > 0 && (i > 0 && !pieceEltss[i][j - 1])
                        ? "v -50 a 50 50 0 0 0 50 50 "
                        : "h 50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function fill(i, j) {
                    m += 0 == i || (pieceEltss[i - 1][j] || (0 == j || pieceEltss[i][j - 1]))
                        ? "v -50 h 50 "
                        : "a 50 50 0 0 1 50 -50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function hash(i, j) {
                    m += j > 0 && (49 > i && !pieceEltss[i][j - 1])
                        ? "a 50 50 0 0 0 50 -50 v 50 "
                        : "h 50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} t
                 * @return {undefined}
                 */
                function cb(i, t) {
                    m += 49 > i && (t > 0 && !pieceEltss[i + 1][t])
                        ? "h 50 a 50 50 0 0 0 -50 50 "
                        : "v 50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function func(i, j) {
                    m += 49 == i || (pieceEltss[i + 1][j] || (0 == j || pieceEltss[i][j - 1]))
                        ? "h 50 v 50 "
                        : "a 50 50 0 0 1 50 50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function load_frame(i, j) {
                    m += 49 == i || (pieceEltss[i + 1][j] || (49 == j || (pieceEltss[i][j + 1] || pieceEltss[i + 1][j + 1] && pieceEltss[i + 1][j])))
                        ? "v 50 h -50 "
                        : "a 50 50 0 0 1 -50 50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @return {undefined}
                 */
                function callback(i, j) {
                    m += 0 == i || (pieceEltss[i - 1][j] || (49 == j || (pieceEltss[i][j + 1] || pieceEltss[i - 1][j + 1] && pieceEltss[i - 1][j])))
                        ? "h -50 v -50 "
                        : "a 50 50 0 0 1 -50 -50 ";
                }
                /**
                 * @param {number} i
                 * @param {number} j
                 * @param {number} recurring
                 * @param {number} v33
                 * @return {?}
                 */
                function run(i, j, recurring, v33) {
                    return codeSegments[i][j]
                        ? void(m += recurring
                            ? "v 100 "
                            : "h -100 ")
                        : (dataAndEvents
                            ? recurring
                                ? (m += "h 100 ", 49 > i && pieceEltss[i + 1][j]
                                    ? run(i + 1, j, 1, 0)
                                    : m += "v 100 ",
                                m += "h -100 ")
                                : (m += "v 100 ", 49 > j && pieceEltss[i][j + 1]
                                    ? run(i, j + 1, 0, 1)
                                    : m += "h -100 ", m += "v -100 ")
                            : recurring
                                ? (0 == i || (0 == j || pieceEltss[i - 1][j - 1] && (pieceEltss[i - 1][j] || pieceEltss[i][j - 1]))
                                    ? a(i, j)
                                    : m += "h 50 ", 49 > i && pieceEltss[i + 1][j]
                                    ? (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))
                                        ? hash(i, j)
                                        : m += "h 50 ", run(i + 1, j, 1, 0), m += "h -100 ")
                                    : (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))
                                        ? (hash(i, j), cb(i, j))
                                        : func(i, j), load_frame(i, j), m += "h -50 "))
                                : (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))
                                    ? cb(i, j)
                                    : m += "v 50 ", 49 > j && pieceEltss[i][j + 1]
                                    ? (m += "v 50 ", run(i, j + 1, 0, 1), m += "v -50 ")
                                    : (load_frame(i, j), callback(i, j)), 0 == i || (0 == j || pieceEltss[i - 1][j - 1])
                                    ? f(i, j)
                                    : m += "v -50 "), void(50 > i && (50 > j && (codeSegments[i][j] = true))));
                }
                /** @type {string} */
                var m = (performance.now(), "");
                var pieceEltss = {};
                var codeSegments = {};
                /** @type {number} */
                var i = 0;
                for (; 50 > i; i++) {
                    pieceEltss[i] = {};
                    codeSegments[i] = {};
                }
                /** @type {number} */
                var p = 0;
                for (; p < placeholders.length; p++) {
                    if (placeholders[p]) {
                        _.forEach(placeholders[p], function(last) {
                            if (process(last)) {
                                pieceEltss[last.x][last.y] = last;
                            }
                            /** @type {boolean} */
                            codeSegments[last.x][last.y] = false;
                        });
                    } else {
                        if (0 == p) {
                            return "";
                        }
                    }
                }
                /** @type {number} */
                i = 0;
                for (; 50 > i; i++) {
                    /** @type {number} */
                    var j = 0;
                    for (; 50 > j; j++) {
                        if (pieceEltss[i][j] && !codeSegments[i][j]) {
                            m += dataAndEvents
                                ? "M " + 100 * i + " " + 100 * j + " "
                                : "M " + 100 * i + " " + (100 * j + 50) + " ";
                            /** @type {boolean} */
                            codeSegments[i][j] = true;
                            /** @type {number} */
                            var diff = 0;
                            do {
                                diff++;
                            } while (50 > i + diff && pieceEltss[i + diff][j]);
                            /** @type {number} */
                            var start = 0;
                            do {
                                start++;
                            } while (50 > j + start && pieceEltss[i][j + start]);
                            if (diff > start) {
                                if (dataAndEvents) {
                                    m += "h 100 ";
                                } else {
                                    if (0 == i || (0 == j || pieceEltss[i - 1][j - 1] && (pieceEltss[i - 1][j] || pieceEltss[i][j - 1]))) {
                                        f(i, j);
                                        a(i, j);
                                    } else {
                                        fill(i, j);
                                    }
                                }
                                if (49 > i && pieceEltss[i + 1][j]) {
                                    if (!dataAndEvents) {
                                        if (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))) {
                                            hash(i, j);
                                        } else {
                                            m += "h 50 ";
                                        }
                                    }
                                    run(i + 1, j, 1, 0);
                                    if (!dataAndEvents) {
                                        m += "h -50 ";
                                    }
                                } else {
                                    if (dataAndEvents) {
                                        m += "v 100 ";
                                    } else {
                                        if (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))) {
                                            hash(i, j);
                                            cb(i, j);
                                        } else {
                                            func(i, j);
                                        }
                                        load_frame(i, j);
                                    }
                                }
                                if (dataAndEvents) {
                                    m += "h -100 v -100 ";
                                } else {
                                    callback(i, j);
                                }
                            } else {
                                if (dataAndEvents) {
                                    m += "h 100 v 100 ";
                                } else {
                                    if (0 == i || (0 == j || pieceEltss[i - 1][j - 1] && (pieceEltss[i - 1][j] || pieceEltss[i][j - 1]))) {
                                        f(i, j);
                                        a(i, j);
                                    } else {
                                        fill(i, j);
                                    }
                                    if (49 == i || (0 == j || pieceEltss[i + 1][j - 1] && (pieceEltss[i + 1][j] || pieceEltss[i][j - 1]))) {
                                        hash(i, j);
                                        cb(i, j);
                                    } else {
                                        func(i, j);
                                    }
                                }
                                if (49 > j && pieceEltss[i][j + 1]) {
                                    if (!dataAndEvents) {
                                        m += "v 50 ";
                                    }
                                    run(i, j + 1, 0, 1);
                                    if (!dataAndEvents) {
                                        m += "v -50 ";
                                    }
                                } else {
                                    if (dataAndEvents) {
                                        m += "h -100 ";
                                    } else {
                                        load_frame(i, j);
                                        callback(i, j);
                                    }
                                }
                                if (dataAndEvents) {
                                    m += "v -100 ";
                                }
                            }
                            m += "Z ";
                        }
                    }
                }
                return m;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_index_47_tutorial_45_index__ = function() {
    var module = angular.module("app.game.tutorial.index", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/sim/tutorial", "top.sim-tutorial-index").within("top").segment("sim-tutorial-index", {
                templateUrl: "components/game/tutorial/index/tutorial-index.html?bust=1479290327467",
                controller: "Top.TutorialIndex as TutorialIndex"
            });
        }
    ]),
    module.controller("Top.TutorialIndex", [
        "$scope",
        "LocalStorage",
        "$location",
        "Dialogs",
        "$routeSegment",
        "Auth",
        function(dataAndEvents, $templateCache, $location, child, res, arg) {
            var that = this;
            /**
                 * @param {?} el
                 * @return {?}
                 */
            this.isTutorialDone = function(el) {
                var pkg = $templateCache.get("tutorialSectionsDone", {});
                return !!pkg[el];
            };
            /**
                 * @return {?}
                 */
            this.isAllTutorialDone = function() {
                return _.every([
                    1, 2, 3, 4, 5
                ], function(failures) {
                    return that.isTutorialDone(failures);
                });
            };
            /**
                 * @param {string} section
                 * @return {undefined}
                 */
            this.goToSection = function(section) {
                /**
                     * @return {undefined}
                     */
                var init = function() {
                    var data = $templateCache.get("tutorialSectionsDone", {});
                    /** @type {boolean} */
                    data[section] = false;
                    $templateCache.put("tutorialSectionsDone", data);
                    $location.url(res.getSegmentUrl("top.sim-tutorial", {section: section}));
                };
                if (that.isTutorialDone(section)) {
                    child.ask("", 'This will remove your existing code from the "tutorial-' + section + '" branch. Do you want to restart this tutorial section?').result.then(init);
                } else {
                    init();
                }
            };
            /**
                 * @return {?}
                 */
            this.goToWorld = function() {
                return arg.required()
                    ? arg.Me.cpu
                        ? void $location.url(res.getSegmentUrl("top.game-world-map"))
                        : void $location.url(res.getSegmentUrl("top.order"))
                    : void 0;
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_section1_47_tutorial_45_section1__ = function() {
    var app = angular.module("app.game.tutorial.section1", []);
    return app.run([
        "TutorialCode",
        "TutorialSteps",
        "MemoryStorage",
        "Connection",
        function(module, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            module.section1 = {
                main: "module.exports.loop = function () {\n\n}"
            };
            dataAndEvents.section1 = {
                1: {},
                2: {
                    selector: ".room-controls .md-button:last-child img",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                3: {
                    selector: ".game-field svg.spawn",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                4: {
                    selector: ".console-tab",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    /**
                     * @param {string} target
                     * @return {?}
                     */
                    trigger: function(target) {
                        return "consoleClick" == target;
                    }
                },
                5: {
                    selector: "section.console .console-input .tutorial-dummy",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    /**
                     * @param {string} target
                     * @return {?}
                     */
                    trigger: function(target) {
                        return "sendConsole" == target;
                    }
                },
                6: {
                    selector: "section.console .console-message:last-child",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    anchor: {
                        left: true,
                        offset: 100
                    }
                },
                7: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" == target && ("Harvester1" == opt_attributes.creep.name && !opt_attributes.creep.spawning);
                    },
                    codeHint: "Game.spawns['Spawn1'].createCreep( [WORK, CARRY, MOVE], 'Harvester1' );"
                },
                8: {
                    selector: ".game-field .creep",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                9: {
                    selector: ".room-controls .md-button:first-child img",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                10: {
                    selector: ".game-field .creep",
                    snap: {
                        bottom: true,
                        center: true
                    },
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "view" == target;
                    }
                },
                11: {
                    selector: "section.room aside .object-properties label:first-child",
                    snap: {
                        top: true,
                        right: true
                    }
                },
                12: {
                    selector: ".game-field svg.source",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                13: {
                    selector: ".script-tab",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    anchor: {
                        offset: 20
                    },
                    /**
                     * @param {string} target
                     * @return {?}
                     */
                    trigger: function(target) {
                        return "scriptClick" == target;
                    }
                },
                14: {
                    selector: "section.script button.submit",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    anchor: {
                        offset: 10
                    }
                },
                15: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" == target && ("Harvester1" == opt_attributes.creep.name && opt_attributes.creep.energy > 0);
                    },
                    codeHint: "module.exports.loop = function () {\n    var creep = Game.creeps['Harvester1'];\n    var sources = creep.room.find(FIND_SOURCES);\n    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n        creep.moveTo(sources[0]);\n    }\n}"
                },
                16: {
                    selector: ".game-field .creep",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                17: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" == target && ("Harvester1" == opt_attributes.creep.name && opt_attributes.creep.x <= 26);
                    },
                    codeHint: "module.exports.loop = function () {\n    var creep = Game.creeps['Harvester1'];\n\n    if(creep.carry.energy < creep.carryCapacity) {\n        var sources = creep.room.find(FIND_SOURCES);\n        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n            creep.moveTo(sources[0]);\n        }\n    }\n    else {\n        if( creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) {\n            creep.moveTo(Game.spawns['Spawn1']);\n        }\n    }\n}"
                },
                18: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" == target && ("Harvester2" == opt_attributes.creep.name && !opt_attributes.creep.spawning);
                    },
                    codeHint: "Game.spawns['Spawn1'].createCreep( [WORK, CARRY, MOVE], 'Harvester2' );"
                },
                19: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" == target && ("Harvester2" == opt_attributes.creep.name && opt_attributes.creep.x > 26);
                    },
                    codeHint: "module.exports.loop = function () {\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n\n        if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n    }\n}"
                },
                20: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && opt_attributes.modules["role.harvester"];
                    },
                    codeHint: "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;"
                },
                21: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && /require/.test(opt_attributes.modules.main);
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        roleHarvester.run(creep);\n    }\n}"
                },
                22: {}
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_section2_47_tutorial_45_section2__ = function() {
    var app = angular.module("app.game.tutorial.section2", []);
    return app.run([
        "TutorialCode",
        "TutorialSteps",
        "MemoryStorage",
        "Connection",
        function(module, dataAndEvents, $templateCache, deepDataAndEvents) {
            module.section2 = {
                main: "var roleHarvester = require('role.harvester');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        roleHarvester.run(creep);\n    }\n}",
                "role.harvester": "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else if(Game.spawns['Spawn1'].energy < Game.spawns['Spawn1'].energyCapacity) {\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;"
            };
            dataAndEvents.section2 = {
                1: {
                    selector: ".game-field svg.controller",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                2: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" != target || ("Upgrader1" != opt_attributes.creep.name || opt_attributes.creep.spawning)
                            ? void 0
                            : (dataAndEvents.section2[3].selector = ".game-field .creep#" + opt_attributes.creep._id, true);
                    },
                    codeHint: "Game.spawns['Spawn1'].createCreep( [WORK, CARRY, MOVE], 'Upgrader1' );"
                },
                3: {
                    selector: "",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                4: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        if ("creep" == target && "Upgrader1" == opt_attributes.creep.name) {
                            var memory = $templateCache.get("users.memory");
                            /** @type {*} */
                            var object = JSON.parse(memory[0].memory);
                            return _.isObject(object.creeps) && (_.isObject(object.creeps.Upgrader1) && "upgrader" == object.creeps.Upgrader1.role);
                        }
                    },
                    codeHint: "Game.creeps['Harvester1'].memory.role = 'harvester';\nGame.creeps['Upgrader1'].memory.role = 'upgrader';"
                },
                5: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && opt_attributes.modules["role.upgrader"];
                    },
                    codeHint: "var roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy == 0) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleUpgrader;"
                },
                6: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "controller" == target && 2 == opt_attributes.controller.level;
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}"
                },
                7: {
                    selector: ".game-field svg.controller",
                    snap: {
                        top: true,
                        center: true
                    }
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_section3_47_tutorial_45_section3__ = function() {
    var app = angular.module("app.game.tutorial.section3", []);
    return app.run([
        "TutorialCode",
        "TutorialSteps",
        "MemoryStorage",
        "Connection",
        "$timeout",
        function(module, dataAndEvents, $templateCache, deepDataAndEvents, ignoreMethodDoesntExist) {
            module.section3 = {
                main: "var roleHarvester = require('role.harvester');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n    }\n}",
                "role.harvester": "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else if(Game.spawns['Spawn1'].energy < Game.spawns['Spawn1'].energyCapacity) {\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;"
            };
            dataAndEvents.section3 = {
                1: {
                    /**
                     * @return {undefined}
                     */
                    init: function() {
                        var memory = $templateCache.get("users.memory");
                        /** @type {*} */
                        var generatedColumn = JSON.parse(memory[0].memory);
                        generatedColumn.creeps = {
                            Harvester1: {
                                role: "harvester"
                            }
                        };
                        /** @type {string} */
                        memory[0].memory = JSON.stringify(generatedColumn);
                    }
                },
                2: {
                    selector: ".game-field svg.construction-site",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                3: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" != target || ("Builder1" != opt_attributes.creep.name || opt_attributes.creep.spawning)
                            ? void 0
                            : (dataAndEvents.section3[4].selector = ".game-field .creep#" + opt_attributes.creep._id, true);
                    },
                    codeHint: "Game.spawns['Spawn1'].createCreep( [WORK, CARRY, MOVE], 'Builder1',\n    { role: 'builder' } );"
                },
                4: {
                    selector: "",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                5: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && opt_attributes.modules["role.builder"];
                    },
                    codeHint: "var roleBuilder = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n\t    if(creep.memory.building && creep.carry.energy == 0) {\n            creep.memory.building = false;\n            creep.say('harvesting');\n\t    }\n\t    if(!creep.memory.building && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.building = true;\n\t        creep.say('building');\n\t    }\n\n\t    if(creep.memory.building) {\n\t        var targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n            if(targets.length) {\n                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n\t    }\n\t    else {\n\t        var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n\t    }\n\t}\n};\n\nmodule.exports = roleBuilder;"
                },
                6: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target
                            ? 5 == _(opt_attributes.objects).filter({type: "extension"}).size()
                            : void 0;
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleBuilder = require('role.builder');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'builder') {\n            roleBuilder.run(creep);\n        }\n    }\n}"
                },
                7: {
                    selector: ".game-field svg.extension",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                8: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && /STRUCTURE_EXTENSION/.test(opt_attributes.modules["role.harvester"]);
                    },
                    codeHint: "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                    filter: (structure) => {\n                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &&\n                            structure.energy < structure.energyCapacity;\n                    }\n            });\n            if(targets.length > 0) {\n                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;"
                },
                9: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target
                            ? 5 == _(opt_attributes.objects).filter({type: "extension", energy: 50}).size() && 300 == _.find(opt_attributes.objects, {type: "spawn"}).energy
                            : void 0;
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleBuilder = require('role.builder');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.rooms) {\n        console.log('Room \"'+name+'\" has '+Game.rooms[name].energyAvailable+' energy');\n    }\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'builder') {\n            roleBuilder.run(creep);\n        }\n    }\n}"
                },
                10: {
                    selector: ".game-field svg.extension",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                11: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "creep" != target || ("HarvesterBig" != opt_attributes.creep.name || opt_attributes.creep.spawning)
                            ? void 0
                            : (dataAndEvents.section3[12].selector = ".game-field .creep#" + opt_attributes.creep._id, true);
                    },
                    codeHint: "Game.spawns['Spawn1'].createCreep( [WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE],\n    'HarvesterBig',\n    { role: 'harvester' } );"
                },
                12: {
                    selector: "",
                    snap: {
                        top: true,
                        center: true
                    },
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "view" == target;
                    }
                },
                13: {
                    selector: "section.room aside .object-properties .body",
                    snap: {
                        bottom: true,
                        right: true
                    }
                },
                14: {}
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_section4_47_tutorial_45_section4__ = function() {
    var app = angular.module("app.game.tutorial.section4", []);
    return app.run([
        "TutorialCode",
        "TutorialSteps",
        "MemoryStorage",
        "Connection",
        function(module, dataAndEvents, $templateCache, deepDataAndEvents) {
            module.section4 = {
                main: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}",
                "role.harvester": "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                    filter: (structure) => {\n                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &&\n                            structure.energy < structure.energyCapacity;\n                    }\n            });\n            if(targets.length > 0) {\n                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;",
                "role.upgrader": "var roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if(creep.memory.upgrading && creep.carry.energy == 0) {\n            creep.memory.upgrading = false;\n            creep.say('harvesting');\n\t    }\n\t    if(!creep.memory.upgrading && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.upgrading = true;\n\t        creep.say('upgrading');\n\t    }\n\n\t    if(creep.memory.upgrading) {\n            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        }\n        else {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleUpgrader;"
            };
            dataAndEvents.section4 = {
                1: {
                    /**
                     * @return {undefined}
                     */
                    init: function() {
                        var memory = $templateCache.get("users.memory");
                        /** @type {*} */
                        var generatedColumn = JSON.parse(memory[0].memory);
                        generatedColumn.creeps = {
                            Harvester1: {
                                role: "harvester"
                            },
                            Harvester2: {
                                role: "harvester"
                            },
                            Upgrader1: {
                                role: "upgrader"
                            }
                        };
                        /** @type {string} */
                        memory[0].memory = JSON.stringify(generatedColumn);
                    }
                },
                2: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && (/console\.log/.test(opt_attributes.modules.main) && /filter/.test(opt_attributes.modules.main));
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    var harvesters = _.filter(Game.creeps, (creep) => creep.memory.role == 'harvester');\n    console.log('Harvesters: ' + harvesters.length);\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}"
                },
                3: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "submitScript" == target && /createCreep/.test(opt_attributes.modules.main);
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    var harvesters = _.filter(Game.creeps, (creep) => creep.memory.role == 'harvester');\n    console.log('Harvesters: ' + harvesters.length);\n\n    if(harvesters.length < 2) {\n        var newName = Game.spawns['Spawn1'].createCreep([WORK,CARRY,MOVE], undefined, {role: 'harvester'});\n        console.log('Spawning new harvester: ' + newName);\n    }\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}"
                },
                4: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target
                            ? _.filter(opt_attributes.objects, function(a) {
                                return /Harvester/.test(a.name);
                            }).length < 2
                            : void 0;
                    },
                    codeHint: "Game.creeps['Harvester1'].suicide()"
                },
                5: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        if ("objectsEnd" == target) {
                            var memory = $templateCache.get("users.memory");
                            /** @type {*} */
                            var object = JSON.parse(memory[0].memory);
                            return _.isObject(object.creeps) && (!object.creeps.Harvester1 || !object.creeps.Harvester2);
                        }
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    for(var name in Memory.creeps) {\n        if(!Game.creeps[name]) {\n            delete Memory.creeps[name];\n            console.log('Clearing non-existing creep memory:', name);\n        }\n    }\n\n    var harvesters = _.filter(Game.creeps, (creep) => creep.memory.role == 'harvester');\n    console.log('Harvesters: ' + harvesters.length);\n\n    if(harvesters.length < 2) {\n        var newName = Game.spawns['Spawn1'].createCreep([WORK,CARRY,MOVE], undefined, {role: 'harvester'});\n        console.log('Spawning new harvester: ' + newName);\n    }\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}"
                },
                6: {}
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_section5_47_tutorial_45_section5__ = function() {
    var app = angular.module("app.game.tutorial.section5", []);
    return app.run([
        "TutorialCode",
        "TutorialSteps",
        "MemoryStorage",
        "Connection",
        function(module, dataAndEvents, $templateCache, deepDataAndEvents) {
            module.section5 = {
                main: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\nvar roleBuilder = require('role.builder');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n        if(creep.memory.role == 'builder') {\n            roleBuilder.run(creep);\n        }\n    }\n}",
                "role.harvester": "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                    filter: (structure) => {\n                        return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &&\n                            structure.energy < structure.energyCapacity;\n                    }\n            });\n            if(targets.length > 0) {\n                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;",
                "role.upgrader": "var roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if(creep.memory.upgrading && creep.carry.energy == 0) {\n            creep.memory.upgrading = false;\n            creep.say('harvesting');\n\t    }\n\t    if(!creep.memory.upgrading && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.upgrading = true;\n\t        creep.say('upgrading');\n\t    }\n\n\t    if(creep.memory.upgrading) {\n            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        }\n        else {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleUpgrader;",
                "role.builder": "var roleBuilder = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n\t    if(creep.memory.building && creep.carry.energy == 0) {\n            creep.memory.building = false;\n            creep.say('harvesting');\n\t    }\n\t    if(!creep.memory.building && creep.carry.energy == creep.carryCapacity) {\n\t        creep.memory.building = true;\n\t        creep.say('building');\n\t    }\n\n\t    if(creep.memory.building) {\n\t        var targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n            if(targets.length) {\n                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n\t    }\n\t    else {\n\t        var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n\t    }\n\t}\n};\n\nmodule.exports = roleBuilder;"
            };
            dataAndEvents.section5 = {
                1: {
                    /**
                     * @return {undefined}
                     */
                    init: function() {
                        var memory = $templateCache.get("users.memory");
                        /** @type {*} */
                        var generatedColumn = JSON.parse(memory[0].memory);
                        generatedColumn.creeps = {
                            Harvester1: {
                                role: "harvester"
                            },
                            Builder1: {
                                role: "builder"
                            },
                            Upgrader1: {
                                role: "upgrader"
                            }
                        };
                        /** @type {string} */
                        memory[0].memory = JSON.stringify(generatedColumn);
                    }
                },
                2: {
                    selector: ".game-field .creep",
                    snap: {
                        center: true,
                        top: true
                    }
                },
                3: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target && !!_.find(opt_attributes.objects, {type: "controller"}).safeMode;
                    },
                    codeHint: "Game.spawns['Spawn1'].room.controller.activateSafeMode();"
                },
                4: {
                    selector: ".game-field .creep",
                    snap: {
                        center: true,
                        top: true
                    }
                },
                5: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target && _.any(opt_attributes.objects, {
                            type: "constructionSite",
                            structureType: "tower"
                        })
                            ? (dataAndEvents.section5[6].selector = ".game-field .creep#" + _.find(opt_attributes.objects, {
                                type: "creep",
                                name: "Builder1"
                            })._id, true)
                            : void 0;
                    },
                    selector: ".room-controls button:nth-child(3)",
                    snap: {
                        top: true,
                        center: true
                    },
                    codeHint: "Game.spawns['Spawn1'].room.createConstructionSite( 23, 22, STRUCTURE_TOWER );"
                },
                6: {
                    selector: "",
                    snap: {
                        top: true,
                        center: true
                    },
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target && _.any(opt_attributes.objects, {type: "tower"});
                    }
                },
                7: {
                    selector: ".game-field svg.tower",
                    snap: {
                        top: true,
                        center: true
                    },
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target && _.any(opt_attributes.objects, function(other) {
                            return "tower" == other.type && other.energy > 0;
                        });
                    },
                    codeHint: "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.carry.energy < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                    filter: (structure) => {\n                        return (structure.structureType == STRUCTURE_EXTENSION ||\n                                structure.structureType == STRUCTURE_SPAWN ||\n                                structure.structureType == STRUCTURE_TOWER) && structure.energy < structure.energyCapacity;\n                    }\n            });\n            if(targets.length > 0) {\n                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;"
                },
                8: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        if ("objectsEnd" == target && !_.any(opt_attributes.objects, {
                            type: "creep",
                            name: "invader1"
                        })) {
                            var found = _.find(opt_attributes.objects, function(t) {
                                return "constructedWall" == t.type && t.hits < 3E8;
                            });
                            return found && (dataAndEvents.section5[9].selector = ".game-field #" + found._id),
                            true;
                        }
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\nvar roleBuilder = require('role.builder');\n\nmodule.exports.loop = function () {\n\n    var tower = Game.getObjectById('{{TOWER_ID}}');\n    if(tower) {\n        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n        if(closestHostile) {\n            tower.attack(closestHostile);\n        }\n    }\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n        if(creep.memory.role == 'builder') {\n            roleBuilder.run(creep);\n        }\n    }\n}"
                },
                9: {
                    selector: "",
                    snap: {
                        top: true,
                        center: true
                    }
                },
                10: {
                    /**
                     * @param {string} target
                     * @param {?} opt_attributes
                     * @return {?}
                     */
                    trigger: function(target, opt_attributes) {
                        return "objectsEnd" == target && !_.any(opt_attributes.objects, function(t) {
                            return "constructedWall" == t.type && t.hits < 3E8;
                        });
                    },
                    codeHint: "var roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\nvar roleBuilder = require('role.builder');\n\nmodule.exports.loop = function () {\n\n    var tower = Game.getObjectById('{{TOWER_ID}}');\n    if(tower) {\n        var closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n            filter: (structure) => structure.hits < structure.hitsMax\n        });\n        if(closestDamagedStructure) {\n            tower.repair(closestDamagedStructure);\n        }\n\n        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n        if(closestHostile) {\n            tower.attack(closestHostile);\n        }\n    }\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n        if(creep.memory.role == 'builder') {\n            roleBuilder.run(creep);\n        }\n    }\n}"
                },
                11: {}
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_tutorial_47_tutorial__ = function() {
    var module = angular.module("app.game.tutorial", []);
    return module.value("TutorialCode", {}),
    module.value("TutorialSteps", {}),
    module.factory("Tutorial", [
        "$rootScope",
        "$timeout",
        "MemoryStorage",
        "Connection",
        "Constants",
        "LocalStorage",
        "Auth",
        "$http",
        "$templateCache",
        "Dialogs",
        "$modal",
        "TutorialSteps",
        "$routeSegment",
        "Api",
        function(child, proceed, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, $templateCache, dataAndEvents, $http, themeCache, $controllerProvider, $modal, docs, $scope, elem) {
            var node;
            /** @type {number} */
            var id = 0;
            /** @type {boolean} */
            var secure = false;
            var _cache = {
                tipFacebookLike: {},
                tipChangelog: {
                    selector: ".navbar-header .navbar-brand",
                    snap: {
                        top: true,
                        left: true
                    },
                    className: "color-primary width-auto no-controls"
                },
                tipUpgradeCtrl: {
                    selector: ".game-field svg.controller",
                    snap: {
                        bottom: true,
                        center: true
                    },
                    className: "color-primary width-auto no-controls"
                },
                tipTipOfTheDay: {
                    selector: ".editor-panel .script-tab",
                    snap: {
                        bottom: true,
                        left: true
                    },
                    className: "width-auto no-controls no-arrow"
                }
            };
            var iterable = {
                /**
                     * @param {?} value
                     * @param {?} dataAndEvents
                     * @return {?}
                     */
                tipSteamMarket: function(value, dataAndEvents) {
                    /** @type {number} */
                    var b = +$templateCache.get("firstVisit", 0);
                    /** @type {number} */
                    var a = 1475045072549;
                    return a > b && (+ $templateCache.get("tipSteamMarket", 0) < a && _.contains([
                        "roomEntered", "worldMapEntered"
                    ], value));
                },
                /**
                     * @param {?} value
                     * @param {?} dataAndEvents
                     * @return {?}
                     */
                tipFacebookLike: function(value, dataAndEvents) {
                    var ffversion = $templateCache.get("firstVisit", 0);
                    return !window.nw && (!$templateCache.get("tipFacebookLike", false) && (_.contains([
                        "worldMapEntered", "simulationMainMenu"
                    ], value) && (ffversion && ffversion < (new Date).getTime() - 6048E5)));
                },
                /**
                     * @param {string} dataAndEvents
                     * @param {Object} res
                     * @return {?}
                     */
                tipUpgradeCtrl: function(dataAndEvents, res) {
                    return 0 == + $templateCache.get("tipUpgradeCtrl", 0) && ("controllerDowngrade" == dataAndEvents && (res.controller && "sim" != res.controller.room));
                },
                /**
                     * @param {?} value
                     * @param {?} dataAndEvents
                     * @return {?}
                     */
                tipTipOfTheDay: function(value, dataAndEvents) {
                    /** @type {number} */
                    var c = +$templateCache.get("tipTipOfTheDay", 0);
                    return 0 == c
                        ? true
                        : -1 == c
                            ? false
                            : _.contains(["roomEntered"], value) && Date.now() - 864E5 > c;
                },
                /**
                     * @param {?} value
                     * @param {?} dataAndEvents
                     * @return {?}
                     */
                tipChangelog: function(value, dataAndEvents) {
                    /** @type {number} */
                    var b = +$templateCache.get("firstVisit", 0);
                    /** @type {number} */
                    var a = 1479107291664;
                    return !child.ptr && (a > b && (+ $templateCache.get("tipChangelog", 0) < a && _.contains([
                        "worldMapEntered", "roomEntered", "gameLobby", "simulationMainMenu"
                    ], value)));
                }
            };
            return node = {
                visible: false,
                /**
                     * @return {undefined}
                     */
                start: function() {
                    if ("top.sim-tutorial" == $scope.name) {
                        /** @type {number} */
                        var fudge_expand = 1;
                        for (; fudge_expand <= _.size(docs["section" + $scope.$routeParams.section]); fudge_expand++) {
                            $http.get("components/game/tutorial/section" + $scope.$routeParams.section + "/step" + fudge_expand + ".html?bust=1479290327467", {
                                /** @type {Function} */
                                cache: themeCache
                            });
                        }
                    }
                    /** @type {number} */
                    id = 1;
                    var proto = this.getStepInfo();
                    if (proto) {
                        if (proto.init) {
                            proto.init();
                        }
                    }
                    this.show();
                },
                /**
                     * @return {undefined}
                     */
                next: function() {
                    var activeItem = this;
                    if ("top.sim-tutorial" == $scope.name) {
                        if (!child.debug) {
                            mixpanel.track("Tutorial: " + $scope.$routeParams.section + "/" + id);
                            ga("send", "event", "Tutorial", "Step " + $scope.$routeParams.section + "/" + id);
                        }
                        if (dataAndEvents.Me) {
                            if (1 == $scope.$routeParams.section) {
                                if (21 == id) {
                                    elem.post("user/tutorial-done");
                                }
                            }
                        }
                    }
                    /** @type {boolean} */
                    node.visible = false;
                    proceed(function() {
                        /** @type {boolean} */
                        secure = false;
                        id++;
                        activeItem.show();
                    }, 300);
                },
                /**
                     * @param {string} basePrototype
                     * @param {?} attributes
                     * @return {undefined}
                     */
                trigger: function(basePrototype, attributes) {
                    var opts = this.getStepInfo();
                    if (!secure && (opts && (opts.trigger && (opts.trigger(basePrototype, attributes) && (secure = true, this.next())))), !id && elem.options.official) {
                        var key;
                        for (key in iterable) {
                            if (iterable[key](basePrototype, attributes)) {
                                if (_cache[key]) {
                                    /** @type {boolean} */
                                    node.visible = true;
                                    /** @type {string} */
                                    id = key;
                                    this.show();
                                }
                                $templateCache.put(key, (new Date).getTime());
                                if ("tipFacebookLike" == key) {
                                    mixpanel.track("Facebook Like Asked");
                                    ga("send", "event", "Facebook", "Like Asked");
                                }
                                if ("tipSteamMarket" == key) {
                                    $modal.open({templateUrl: "components/game/tutorial/tipSteamMarket.html?bust=1479290327467", controller: $controllerProvider.Ctrl, windowClass: "tutorial-window-huge"});
                                }
                                break;
                            }
                        }
                    }
                },
                /**
                     * @return {undefined}
                     */
                show: function() {
                    child.$broadcast("tutorialShow");
                },
                /**
                     * @return {?}
                     */
                getStep: function() {
                    return id;
                },
                /**
                     * @return {?}
                     */
                getStepInfo: function() {
                    return "top.sim-tutorial" == $scope.name
                        ? docs["section" + $scope.$routeParams.section][id]
                        : _cache[id];
                },
                /**
                     * @return {?}
                     */
                getStepTemplate: function() {
                    return "top.sim-tutorial" == $scope.name
                        ? "section" + $scope.$routeParams.section + "/step" + this.getStep()
                        : this.getStep();
                },
                /**
                     * @return {?}
                     */
                getStepCodeHint: function() {
                    return docs["section" + $scope.$routeParams.section][this.getStep()].codeHint;
                },
                /**
                     * @return {undefined}
                     */
                resetStep: function() {
                    /** @type {number} */
                    id = 0;
                    /** @type {boolean} */
                    this.visible = false;
                }
            };
        }
    ]),
    module.directive("appTutorial", [
        "Tutorial",
        "$document",
        "$window",
        "$timeout",
        "$location",
        "$routeSegment",
        "Connection",
        "LocalStorage",
        function(self, sourceContainer, target, dataAndEvents, body, $rootScope, Push, $templateCache) {
            return {
                controller: [
                    "$scope",
                    "$element",
                    "$rootScope",
                    function($scope, el, subscriber) {
                        var scrollIntervalId;
                        var settings = this;
                        /** @type {Object} */
                        $scope.TutorialService = self;
                        /**
                             * @return {undefined}
                             */
                        this.quit = function() {
                            subscriber.$broadcast("gameSimulationReset");
                            /** @type {boolean} */
                            self.visible = false;
                            self.resetStep();
                            var rvar = $rootScope.getSegmentUrl("top.sim");
                            Push.allowChangeUrl(rvar);
                            body.url(rvar);
                        };
                        /**
                             * @return {undefined}
                             */
                        this.next = function() {
                            self.next();
                        };
                        /**
                             * @return {undefined}
                             */
                        this.close = function() {
                            /** @type {boolean} */
                            self.visible = false;
                        };
                        /**
                             * @return {undefined}
                             */
                        this.finish = function() {
                            var udataCur = $templateCache.get("tutorialSectionsDone", {});
                            /** @type {boolean} */
                            udataCur[$rootScope.$routeParams.section] = true;
                            $templateCache.put("tutorialSectionsDone", udataCur);
                            subscriber.$broadcast("gameSimulationReset");
                            /** @type {boolean} */
                            self.visible = false;
                            self.resetStep();
                            var rvar = $rootScope.getSegmentUrl("top.sim-tutorial-index");
                            Push.allowChangeUrl(rvar);
                            body.url(rvar);
                        };
                        /**
                             * @return {?}
                             */
                        this.getClassName = function() {
                            var tutorial_ = "tutorial-" + self.getStepTemplate();
                            var elem = self.getStepInfo();
                            return elem && (elem.className && (tutorial_ += " " + elem.className)),
                            tutorial_;
                        };
                        /**
                             * @return {?}
                             */
                        var position = function() {
                            if (!self.visible) {
                                return void clearInterval(scrollIntervalId);
                            }
                            var options = self.getStepInfo();
                            if (options) {
                                if (options.selector) {
                                    var $slide = $(sourceContainer).find(options.selector);
                                    var position = {
                                        top: "auto",
                                        left: "auto",
                                        bottom: "auto",
                                        right: "auto"
                                    };
                                    if (!$slide.length) {
                                        return void(settings.anchorFound = false);
                                    }
                                    settings.snap = _.clone(options.snap);
                                    /** @type {boolean} */
                                    settings.anchorFound = true;
                                    if (options.snap.top) {
                                        position.top = $slide.offset().top + $slide.height();
                                    }
                                    if (options.snap.bottom) {
                                        /** @type {number} */
                                        position.bottom = target.innerHeight - $slide.offset().top;
                                    }
                                    if (options.snap.left) {
                                        /** @type {number} */
                                        position.left = $slide.offset().left - 32;
                                    }
                                    if (options.snap.center) {
                                        /** @type {number} */
                                        position.left = $slide.offset().left - el.width() / 2;
                                    }
                                    if (options.snap.right) {
                                        /** @type {number} */
                                        position.right = target.innerWidth - $slide.offset().left - 32;
                                    }
                                    if (!(options.anchor && options.anchor.left)) {
                                        if (options.snap.left || options.snap.center) {
                                            position.left += $slide.width() / 2;
                                        } else {
                                            position.right -= $slide.width() / 2;
                                        }
                                    }
                                    if (options.anchor) {
                                        if (options.anchor.offset) {
                                            if (options.snap.left || options.snap.center) {
                                                position.left += options.anchor.offset;
                                            } else {
                                                position.right -= options.anchor.offset;
                                            }
                                        }
                                    }
                                    if ("auto" != position.left) {
                                        /** @type {string} */
                                        position.left = Math.round(position.left) + "px";
                                    }
                                    if ("auto" != position.right) {
                                        /** @type {string} */
                                        position.right = Math.round(position.right) + "px";
                                    }
                                    if ("auto" != position.top) {
                                        /** @type {string} */
                                        position.top = Math.round(position.top) + "px";
                                    }
                                    if ("auto" != position.bottom) {
                                        /** @type {string} */
                                        position.bottom = Math.round(position.bottom) + "px";
                                    }
                                    el.css(position);
                                    var otherElementRect = el.position();
                                    var itemCenterY = el.width();
                                    var top = el.height();
                                    if (otherElementRect.left < 0) {
                                        el.css({left: 0, right: "auto"});
                                        /** @type {null} */
                                        settings.snap = null;
                                    }
                                    if (otherElementRect.left > target.innerWidth - itemCenterY) {
                                        el.css({left: "auto", right: 0});
                                        /** @type {null} */
                                        settings.snap = null;
                                    }
                                    if (otherElementRect.top < 0) {
                                        el.css({top: 0, bottom: "auto"});
                                        /** @type {null} */
                                        settings.snap = null;
                                    }
                                    if (otherElementRect.top > target.innerHeight - top) {
                                        el.css({top: "auto", bottom: 0});
                                        /** @type {null} */
                                        settings.snap = null;
                                    }
                                } else {
                                    /** @type {boolean} */
                                    settings.anchorFound = true;
                                    el.css({
                                        left: "calc(50% - " + el.width() / 2 + "px)",
                                        top: "50px"
                                    });
                                }
                            }
                        };
                        /**
                             * @return {undefined}
                             */
                        var init = function() {
                            if (self.getStepInfo()) {
                                /** @type {boolean} */
                                self.visible = true;
                                if (scrollIntervalId) {
                                    clearInterval(scrollIntervalId);
                                }
                                /** @type {number} */
                                scrollIntervalId = setInterval(position, 100);
                                position();
                            }
                        };
                        init();
                        $scope.$on("tutorialShow", init);
                        $scope.$watch(function() {
                            return self.step;
                        }, this.contentLoaded = false);
                        $scope.$on("tutorialContentLinked", function() {
                            position();
                            /** @type {boolean} */
                            settings.contentLoaded = true;
                        });
                    }
                ],
                controllerAs: "Tutorial"
            };
        }
    ]),
    module.directive("appTutorialCode", [
        "Tutorial",
        "MemoryStorage",
        function(dataAndEvents, $templateCache) {
            return {
                templateUrl: "components/game/tutorial/code.html?bust=1479290327467",
                bindToController: {
                    title: "@"
                },
                scope: {},
                /**
                     * @return {undefined}
                     */
                controller: function() {
                    if (this.code = dataAndEvents.getStepCodeHint(), this.visible = true, -1 != this.code.indexOf("{{TOWER_ID}}")) {
                        var element = $templateCache.get("rooms.objects");
                        var doc = _.find(element, {type: "tower"});
                        if (doc) {
                            this.code = this.code.replace(/\{\{TOWER_ID\}\}/, doc._id);
                        }
                    }
                },
                controllerAs: "TutorialCode"
            };
        }
    ]),
    module.directive("appTutorialContent", function() {
        return {
            /**
                 * @param {?} scope
                 * @param {?} tabCtrl
                 * @param {?} attrs
                 * @return {undefined}
                 */
            link: function(scope, tabCtrl, attrs) {
                scope.$emit("tutorialContentLinked");
            }
        };
    }),
    module.controller("Top.Tutorial.TipOfTheDay", [
        "$scope",
        "Dialogs",
        "LocalStorage",
        function(io, child, $templateCache) {
            var self = this;
            /** @type {Array} */
            var _tasks = [
                "To save your CPU, use less creeps of a larger size.",
                "A good way to save CPU is caching often-used paths.",
                "The more body parts of one type a creep has, the greater its productivity.",
                "Use storage to not lose surplus of mined resources.",
                "A resource abandoned on the ground eventually vanishes.",
                "Use towers to set up automatic defense of your room.",
                "The more small objects in the Memory, the more CPU spent on its parsing.",
                "Inscreasing the <code>reusePath</code> option in the <code>Creep.moveTo</code> method helps saving CPU.",
                "The <code>RANGED_ATTACK</code> body part is 2 times weaker than <code>ATTACK</code> and 2 times costlier at that.",
                "You can have as many rooms under your control as your Global Control Level.",
                "You can address from your script only those rooms that contain your creeps or structures.",
                "Observers allow to get the <code>Room</code> object for the rooms that have no objects of yours.",
                "Build roads to save on <code>MOVE</code> body parts of your creeps.",
                "Roads wear out as they are used, so don\u2019t forget to repair them.",
                "Walls and roads don\u2019t belong to any player, so they should be searched with the help of <code>FIND_STRUCTURES</code>, not <code>FIND_MY_STRUCTURES</code>.",
                "Use try/catch blocks in right places to avoid a complete halt of your script due to errors.",
                "Use branches to test and debug your temporary code and also do backups.",
                "Set up a grunt task to write scripts on your local machine and commit them to Screeps.",
                "More spawns in a room allows building more creeps at a time.",
                "The more spawn extensions in a room, the more energy you can spend on building one creep.",
                "Spawn extensions capacity increases on room levels 7 and 8.",
                "Spawn extensions do not have to be placed near spawns, their range is the whole room.",
                "Towers can aim at any object in a room even through walls and obstacles.",
                "A tower\u2019s effectiveness depends on the distance to the target.",
                "Power banks appear only in neutral rooms that divide living sectors on the map.",
                "Ramparts can be built not just on empty squares but on existing structures too.",
                "While not destroyed, a rampart protects a creep or building on its square from any type of attack.",
                "Creeps cannot move faster than 1 square per tick.",
                "Use links to save on creep building and CPU.",
                "Links can pass energy to other links at any point inside the same room.",
                "You can build and repair roads in any rooms, even neutral ones.",
                "Leaderboards reset to zero each month, while your game process continues.",
                "Modular architecture of a script will allow easy testing of individual functions in the simulator.",
                "You can create any objects in the simulator to test your script.",
                "The <code>console.log</code> function of the simulator displays a live expandable object in the browser console.",
                "Walking over swamps is 5 times slower compared to plain land.",
                "Ramparts and walls initially have 1 hit point. Repair them after construction.",
                "You cannot have more than 3 rooms in the Novice Area.",
                "If you want to play from scratch, you can always Respawn in a new room.",
                "Every creep dies after 1500 ticks, however you can prolong its life using the <code>Spawn.renewCreep</code> method.",
                "To control a room continuously, you need to upgrade your controller from time to time.",
                "A spawn automatically replenishes itself with power until the energy in the room reaches 300 units.",
                "Test various game scenarios in the simulator in order to be prepared for surprises.",
                "Always try to control as many rooms as your GCL allows. It will allow your colony to develop at the maximum speed.",
                "You can use more CPU than your CPU limit allows in short bursts.",
                "Unless you use up your CPU limit each tick, it is stored for future use.",
                "There is a keyword <code>debugger</code> in the simulator that stops your script in the browser.",
                "Your CPU Limit depends on your Global Control Level.",
                "Send emails to yourself with the function <code>Game.notify</code> to be aware of everything happening in the game.",
                "The <code>Game.notify</code> function automatically groups identical messages using the specified interval.",
                "It is too costly and senseless to maintain an army of military creeps in the peacetime.",
                "The creep memory is saved upon death, so clear <code>Memory.creeps.*</code> to prevent overflowing.",
                "You can output HTML content to the console, like links to rooms.",
                "Each game action has a constant cost of 0.2 CPU.",
                "Creeps can miss each other if they walk towards each other simultaneously or follow step by step.",
                "A creep can execute some commands simultaneously in one tick, for example <code>move</code>+<code>build</code>+<code>dropEnergy</code>.",
                "<code>require</code> spends CPU depending on the size and complexity of the module loaded.",
                "Use loop architecture to save CPU on the logic you do not have to run each tick.",
                "The game is fully recorded, so you can see replay of any room for the past several days.",
                "If CPU limit raises, your script will execute only partially.",
                "To output an object content into the console, use <code>JSON.stringify</code>.",
                "A creep with an <code>ATTACK</code> part automatically strikes back at every attacker by <code>ATTACK</code>.",
                "Respawning in a chosen room would automatically destroy all structures except walls and roads.",
                "You can apply <code>transfer</code> and <code>heal</code> to another player\u2019s creep, and <code>transfer,</code> <code>build</code> and <code>repair</code> to others\u2019 structures.",
                "To prevent other players from seizing a neutral room you want, use <code>Creep.reserveController</code>.",
                "Energy in a storage can not be used to spawn creeps. Transfer it to a spawn or extensions instead.",
                "You can speed up downgrading of hostile room controller by using <code>Creep.claimController</code> on it.",
                "Sources in neutral rooms have reduced capacity. Reserve or claim the room to restore it to full capacity.",
                "Use <code>Room.energyAvailable</code> and <code>Room.energyCapacityAvailable</code> to determine how much energy all the spawns and extensions in the room contain.",
                "Dead body parts have weight and generate fatigue as well."
            ];
            /**
                 * @return {?}
                 */
            this.nextTip = function() {
                return self.tip = _tasks[Math.floor(Math.random() * _tasks.length)];
            };
            this.nextTip();
            /**
                 * @return {undefined}
                 */
            this.block = function() {
                child.ask("", "Do you want to turn off tips of the day?").result.then(function() {
                    io.Tutorial.close();
                    $templateCache.put("tipTipOfTheDay", -1);
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_game_47_world_45_map_47_world_45_map__ = function() {
    /**
     * @param {number} x
     * @param {number} value
     * @param {number} callback
     * @return {?}
     */
    function round(x, value, callback) {
        if (0 > x) {
            x += 360;
        }
        var data;
        var selector;
        var type;
        /** @type {number} */
        var text = (1 - window.Math.abs(2 * callback - 1)) * value;
        /** @type {number} */
        var indexX = x / 60;
        /** @type {number} */
        var _ = text * (1 - window.Math.abs(indexX % 2 - 1));
        if (void 0 === x || (isNaN(x) || null === x)) {
            /** @type {number} */
            data = selector = type = 0;
        } else {
            if (indexX >= 0 && 1 > indexX) {
                /** @type {number} */
                data = text;
                /** @type {number} */
                selector = _;
                /** @type {number} */
                type = 0;
            } else {
                if (indexX >= 1 && 2 > indexX) {
                    /** @type {number} */
                    data = _;
                    /** @type {number} */
                    selector = text;
                    /** @type {number} */
                    type = 0;
                } else {
                    if (indexX >= 2 && 3 > indexX) {
                        /** @type {number} */
                        data = 0;
                        /** @type {number} */
                        selector = text;
                        /** @type {number} */
                        type = _;
                    } else {
                        if (indexX >= 3 && 4 > indexX) {
                            /** @type {number} */
                            data = 0;
                            /** @type {number} */
                            selector = _;
                            /** @type {number} */
                            type = text;
                        } else {
                            if (indexX >= 4 && 5 > indexX) {
                                /** @type {number} */
                                data = _;
                                /** @type {number} */
                                selector = 0;
                                /** @type {number} */
                                type = text;
                            } else {
                                if (indexX >= 5) {
                                    if (6 > indexX) {
                                        /** @type {number} */
                                        data = text;
                                        /** @type {number} */
                                        selector = 0;
                                        /** @type {number} */
                                        type = _;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        var h;
        var g;
        var frac;
        /** @type {number} */
        var __ = callback - text / 2;
        return h = 255 * (data + __),
        g = 255 * (selector + __),
        frac = 255 * (type + __),
        h = Math.round(h),
        g = Math.round(g),
        frac = Math.round(frac),
        [h, g, frac];
    }
    var size;
    var cols;
    var j;
    var w;
    var windowsNum;
    var frameId;
    var height;
    var width;
    var viewportWidth;
    var off;
    var module = angular.module("app.game.world-map", []);
    var input = {};
    /** @type {Array} */
    var ret = [];
    var result = {
        left: 0,
        top: 0,
        active: false,
        hover: {}
    };
    var zoom = {
        1: 20,
        2: 50,
        3: 150
    };
    var t = {
        1: 10,
        2: 4,
        3: 1
    };
    return module.config([
        "$routeSegmentProvider",
        function($routeProvider) {
            $routeProvider.when("/map", "top.game-world-map").within("top").segment("game-world-map", {
                templateUrl: "components/game/world-map/world-map.html?bust=1479290327467",
                controller: "Top.WorldMap as WorldMap",
                resolve: {
                    startRoom: ngInject([
                        "Api",
                        function($templateCache) {
                            return $templateCache.get("user/world-start-room").then(function(a) {
                                return a.room;
                            });
                        }
                    ]),
                    worldStatus: ngInject([
                        "Api",
                        function($templateCache) {
                            return $templateCache.get("user/world-status").then(function(jqXHR) {
                                return jqXHR.status;
                            });
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("Top.WorldMap", [
        "$scope",
        "$location",
        "$routeSegment",
        "LocalStorage",
        "$q",
        "MapUtils",
        "Loader",
        "Tutorial",
        "WorldActivator",
        "Auth",
        "$interval",
        "$timeout",
        "WorldRespawnChecker",
        "startRoom",
        "Api",
        "AccountSaveRedirector",
        "worldStatus",
        "ResourceTypeNames",
        function(child, $location, res, $templateCache, $q, console, appLoading, selectedElement, options, el, lang, $sanitize, node, arr, socket, namespace, dataAndEvents, deepDataAndEvents) {
            var self = this;
            if (el.required(child)) {
                if (!el.Me.badge) {
                    return namespace.set("top.game-world-map"),
                    void $location.url(res.getSegmentUrl("top.account-badge"));
                }
                if (socket.options.official && !$templateCache.get("tutorialVisited", false)) {
                    return $templateCache.put("tutorialVisited", true),
                    void $location.url(res.getSegmentUrl("top.sim-tutorial", {section: 1}));
                }
            }
            this.startRoom = arr;
            this.worldStatus = dataAndEvents;
            this.resourceTypeNames = deepDataAndEvents;
            this.densityNames = {
                1: "Low",
                2: "Moderate",
                3: "High",
                4: "Ultra"
            };
            /** @type {number} */
            this.zoom = 3;
            /** @type {number} */
            var scale = 1;
            if (socket.options.official) {
                this.mapUrl = {
                    base: "https://d3os7yery2usni.cloudfront.net/map3/",
                    zoom1: "https://d3os7yery2usni.cloudfront.net/map3/zoom1/",
                    zoom2: "https://d3os7yery2usni.cloudfront.net/map3/zoom2/"
                };
            } else {
                /** @type {number} */
                scale = 2;
                this.mapUrl = {
                    base: "http://" + socket.options.host + ":" + socket.options.port + "/assets/map/",
                    zoom1: "http://" + socket.options.host + ":" + socket.options.port + "/assets/map/zoom1/",
                    zoom2: "http://" + socket.options.host + ":" + socket.options.port + "/assets/map/zoom2/",
                    query: "bust=" + Date.now()
                };
            }
            size = zoom[this.zoom];
            cols = t[this.zoom];
            /** @type {number} */
            var i = -1;
            if (!$location.search().pos) {
                /** @type {number} */
                i = 0;
                $location.replace();
                var m = console.roomNameToXY(arr[0]);
                var my = m[0];
                var formula = m[1];
                $location.search("pos", my + 0.5 + "," + (formula + 0.5));
            }
            input = {};
            /** @type {Array} */
            ret = [];
            this.grid = input;
            /** @type {Array} */
            this.sectors = ret;
            this.displayOptions = $templateCache.createSyncedObj("game.world-map.displayOptions2", {
                layer: "owner0",
                units: true
            });
            /** @type {string} */
            this.searchRoom = "";
            /** @type {Array} */
            this.updateRoomStats = [];
            this.roomStats = {};
            this.roomUsers = {};
            this.roomStatsMax = {};
            this.respawnProhibitedRooms = {};
            /**
                 * @return {?}
                 */
            this.now = function() {
                return Date.now();
            };
            /**
                 * @return {undefined}
                 */
            this.goToRoom = function() {
                if (result.roomName) {
                    if (self.roomStats[result.roomName]) {
                        $location.url(res.getSegmentUrl("top.game-room", {room: result.roomName}));
                    }
                }
            };
            /**
                 * @param {number} expectedNumberOfNonCommentArgs
                 * @return {?}
                 */
            this.zoomChange = function(expectedNumberOfNonCommentArgs) {
                return self.zoom += expectedNumberOfNonCommentArgs,
                self.zoom > 3
                    ? void(self.zoom = 3)
                    : self.zoom < scale
                        ? void(self.zoom = scale)
                        : (size = zoom[self.zoom], cols = t[self.zoom], ret.forEach(function(propData) {
                            if (propData.pos) {
                                delete input[propData.pos[1]][propData.pos[0]];
                                /** @type {null} */
                                propData.pos = null;
                            }
                        }), child.$broadcast("recalcMapSectors"), void resolve());
            };
            /**
                 * @return {undefined}
                 */
            this.switchNoviceArea = function() {
                i++;
                if (i >= arr.length) {
                    /** @type {number} */
                    i = 0;
                }
                $location.replace();
                var args = console.roomNameToXY(arr[i]);
                var pageY = args[0];
                var pageX = args[1];
                $location.search("pos", pageY + 0.5 + "," + (pageX + 0.5));
            };
            /**
                 * @return {?}
                 */
            this.lookForRoom = function() {
                return $q.when().then(function() {
                    return /^(W|E)\d+(N|S)\d+$/i.test(self.searchRoom)
                        ? self.searchRoom
                        : socket.get("user/find", {username: self.searchRoom}).then(function(opts) {
                            return socket.get("user/rooms", {id: opts.user._id});
                        }).then(function(fc) {
                            return fc.rooms
                                ? _.sample(fc.rooms)
                                : $q.reject();
                        });
                }).then(function(i) {
                    var bc = console.roomNameToXY(i);
                    var elseLength = bc[0];
                    var paramsLength = bc[1];
                    $location.replace();
                    $location.search("pos", elseLength + 0.5 + "," + (paramsLength + 0.5));
                });
            };
            /**
                 * @return {?}
                 */
            this.worldLaunched = function() {
                return new Date >= options.launchTime;
            };
            /**
                 * @param {?} time
                 * @return {?}
                 */
            this.getStatsCircleSize = function(time) {
                var tol;
                return tol = "owner0" == self.displayOptions.layer
                    ? 8
                    : self.roomStatsMax[self.displayOptions.layer],
                tol
                    ? 2 * Math.sqrt(Math.min(time, tol) / tol * 4071 / Math.PI) + 8
                    : 0;
            };
            /**
                 * @return {?}
                 */
            this.toggleUnits = function() {
                return self.displayOptions.units = !self.displayOptions.units;
            };
            /**
                 * @param {string} key
                 * @return {?}
                 */
            this.isRoomRespawnProhibited = function(key) {
                if (!self.roomStats[key]) {
                    return true;
                }
                if ("out of borders" == self.roomStats[key].status) {
                    return true;
                }
                if (self.roomStats[key].openTime && self.roomStats[key].openTime > Date.now()) {
                    return true;
                }
                var camelKey = console.roomNameToXY(key);
                var inc = camelKey[0];
                var delta = camelKey[1];
                return console.isCenter(inc, delta)
                    ? true
                    : console.isBus(inc) || console.isBus(delta)
                        ? true
                        : self.respawnProhibitedRooms[key]
                            ? true
                            : self.roomStats[key] && self.roomStats[key].own
                                ? true
                                : false;
            };
            /**
                 * @return {undefined}
                 */
            var timeSince = function() {
                /** @type {Date} */
                var start = new Date;
                if (start >= options.launchTime) {
                    /** @type {null} */
                    self.remainingTime = null;
                } else {
                    self.remainingTime = {
                        days: Math.floor((options.launchTime - start) / 24 / 3600 / 1E3),
                        hours: Math.floor((options.launchTime - start) / 3600 / 1E3) % 24,
                        minutes: Math.floor((options.launchTime - start) / 60 / 1E3) % 60,
                        seconds: Math.floor((options.launchTime - start) / 1E3) % 60
                    };
                }
            };
            timeSince();
            /**
                 * @return {?}
                 */
            var run = function() {
                return _.reduce(self.sectors, function(r, data) {
                    return data.name && r.push(data.name),
                    data.rooms && (r = r.concat(data.rooms.split(","))),
                    r;
                }, []);
            };
            /**
                 * @param {(number|string)} deps
                 * @return {?}
                 */
            var resolve = function(deps) {
                return _.isArray(deps) || (deps = run()),
                appLoading.loading($q.all([
                    socket.post("game/map-stats", {
                        rooms: deps,
                        statName: 3 == self.zoom
                            ? self.displayOptions.layer
                            : "owner0"
                    }).then(function(config) {
                        self.gameTime = config.gameTime;
                        _.extend(self.roomStats, config.stats);
                        _.extend(self.roomUsers, config.users);
                        self.roomStatsMax = config.statsMax;
                    }),
                    "empty" == self.worldStatus
                        ? socket.get("user/respawn-prohibited-rooms").then(function(obj) {
                            self.respawnProhibitedRooms = _.reduce(obj.rooms, function(buf, off) {
                                return buf[off] = true,
                                buf;
                            }, {});
                        })
                        : $q.when()
                ]).then(function() {
                    return child.$broadcast("mapStatsUpdated");
                }));
            };
            if (options.launchTime > new Date) {
                $sanitize(function() {
                    return window.location.reload();
                }, options.launchTime - new Date);
            }
            child.$watch(_.throttle(function() {
                return child.$applyAsync(function() {
                    _.remove(self.updateRoomStats, function(key) {
                        return key in self.roomStats;
                    });
                    if (self.updateRoomStats.length) {
                        resolve(self.updateRoomStats);
                    }
                    /** @type {Array} */
                    self.updateRoomStats = [];
                });
            }, 200));
            child.$watch(function() {
                return self.displayOptions.layer;
            }, function() {
                self.roomStats = {};
                self.updateRoomStats = run();
                _.remove(self.updateRoomStats, function(dataAndEvents) {
                    return !dataAndEvents;
                });
            });
            lang.bindToScope(child, resolve, 6E4);
            child.$on("respawned", function() {
                /** @type {string} */
                self.worldStatus = "empty";
                /** @type {number} */
                self.curNoviceArea = -1;
                socket.get("user/world-start-room").then(function(options) {
                    return arr = options.room;
                });
                resolve().then(function() {
                    return options.run();
                });
            });
            if (el.Me) {
                if (el.Me.badge) {
                    options.run();
                }
            }
            node.bind(child);
            selectedElement.trigger("worldMapEntered");
        }
    ]),
    module.directive("appGameMapContainer", [
        "$location",
        "MapUtils",
        "$document",
        "$timeout",
        function(string, assert, dataAndEvents, success) {
            return {
                /**
                     * @param {?} scope
                     * @param {Object} element
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function(scope, element, tabCtrl) {
                    /**
                         * @return {undefined}
                         */
                    function update() {
                        if (string.search().pos) {
                            var range = string.search().pos.split(/,/);
                            var number = range[0];
                            var x = range[1];
                            /** @type {number} */
                            number = parseFloat(number);
                            /** @type {number} */
                            x = parseFloat(x);
                            j = element.width();
                            w = element.height();
                            /** @type {number} */
                            windowsNum = Math.ceil(j / size) + 1;
                            /** @type {number} */
                            frameId = Math.ceil(w / size) + 1;
                            /** @type {number} */
                            height = x * size - w / 2;
                            /** @type {number} */
                            width = number * size - j / 2;
                            /** @type {number} */
                            viewportWidth = number * size + j / 2;
                            /** @type {number} */
                            off = x * size + w / 2;
                            /** @type {number} */
                            var length = Math.ceil(windowsNum / cols + 1) * Math.ceil(frameId / cols + 1);
                            if (ret.length < length) {
                                var i = ret.length;
                                for (; length > i; i++) {
                                    ret.push({
                                        id: Math.floor(1E7 * Math.random())
                                    });
                                }
                            }
                            if (ret.length > length) {
                                /** @type {number} */
                                i = length;
                                for (; i < ret.length; i++) {
                                    if (ret[i].pos) {
                                        delete input[ret[i].pos[1]][ret[i].pos[0]];
                                    }
                                }
                                ret.splice(length, ret.length - length);
                            }
                            var name;
                            for (name in input) {
                                var key;
                                for (key in input[name]) {
                                    if (key < Math.floor(width / size) || (key > Math.floor(viewportWidth / size) || (name < Math.floor(height / size) || (name > Math.floor(off / size) || (key % cols || name % cols))))) {
                                        /** @type {null} */
                                        ret[input[name][key]].pos = null;
                                        delete input[name][key];
                                    }
                                }
                            }
                            /** @type {number} */
                            name = Math.floor(height / size / cols) * cols;
                            for (; name <= Math.floor(off / size / cols) * cols; name += cols) {
                                if (!input[name]) {
                                    input[name] = {};
                                }
                                /** @type {number} */
                                key = Math.floor(width / size / cols) * cols;
                                for (; key <= Math.floor(viewportWidth / size / cols) * cols; key += cols) {
                                    if (_.isUndefined(input[name][key])) {
                                        /** @type {number} */
                                        i = 0;
                                        for (; i < ret.length; i++) {
                                            if (!ret[i].pos) {
                                                if (ret[i].pos = [
                                                    key, name
                                                ], input[name][key] = i,
                                                3 == scope.WorldMap.zoom) {
                                                    ret[i].name = assert.getRoomNameFromXY(key, name);
                                                    scope.WorldMap.updateRoomStats.push(ret[i].name);
                                                } else {
                                                    /** @type {Array} */
                                                    var assigns = [];
                                                    /** @type {number} */
                                                    var separator2 = 0;
                                                    for (; cols > separator2; separator2++) {
                                                        /** @type {number} */
                                                        var direction = 0;
                                                        for (; cols > direction; direction++) {
                                                            var vvar = assert.getRoomNameFromXY(key + separator2, name + direction);
                                                            assigns.push(vvar);
                                                            scope.WorldMap.updateRoomStats.push(vvar);
                                                        }
                                                    }
                                                    /** @type {string} */
                                                    ret[i].rooms = assigns.join(",");
                                                    ret[i].firstRoomName = assigns[0];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            /** @type {number} */
                            i = 0;
                            for (; i < ret.length; i++) {
                                if (ret[i].pos) {
                                    /** @type {number} */
                                    ret[i].left = ret[i].pos[0] * size + j / 2 - number * size;
                                    /** @type {number} */
                                    ret[i].top = ret[i].pos[1] * size + w / 2 - x * size;
                                }
                            }
                            scope.$broadcast("mapSectorsRecalced");
                        }
                    }
                    /**
                         * @param {Object} event
                         * @return {undefined}
                         */
                    function start(event) {
                        var nodeOfs = element.offset();
                        /** @type {number} */
                        var y = Math.floor((event.pageX - nodeOfs.left + width) / size);
                        /** @type {number} */
                        var index = Math.floor((event.pageY - nodeOfs.top + height) / size);
                        /** @type {number} */
                        result.left = event.pageX - nodeOfs.left + 10;
                        /** @type {number} */
                        result.top = event.pageY - nodeOfs.top + 10;
                        result.roomName = assert.getRoomNameFromXY(y, index);
                        /** @type {number} */
                        result.hover.left = y * size - width;
                        /** @type {number} */
                        result.hover.top = index * size - height;
                        result.hover.size = size;
                        /** @type {boolean} */
                        result.active = true;
                    }
                    /** @type {boolean} */
                    var startX = false;
                    /** @type {boolean} */
                    var startY = false;
                    /** @type {boolean} */
                    scope.locked = true;
                    element.mousedown(function(t) {
                        return scope.$applyAsync(function() {
                            startX = t.pageX;
                            startY = t.pageY;
                        }),
                        false;
                    });
                    /**
                         * @param {?} positions
                         * @return {undefined}
                         */
                    var show = function(positions) {
                        scope.$applyAsync(function() {
                            /** @type {boolean} */
                            startX = false;
                            /** @type {boolean} */
                            startY = false;
                            success(function() {
                                return scope.locked = true;
                            }, 50);
                        });
                    };
                    /**
                         * @param {Object} e
                         * @return {undefined}
                         */
                    var init = function(e) {
                        e.preventDefault();
                        scope.$apply(function() {
                            if (start(e), startX !== false && (startY !== false && !(scope.locked && (window.Math.abs(e.pageX - startX) < 5 && window.Math.abs(e.pageY - startY) < 5)))) {
                                /** @type {boolean} */
                                scope.locked = false;
                                var rectData = string.search().pos.split(/,/);
                                var width = rectData[0];
                                var height = rectData[1];
                                /** @type {number} */
                                width = parseFloat(width);
                                /** @type {number} */
                                height = parseFloat(height);
                                width -= (e.pageX - startX) / size;
                                height -= (e.pageY - startY) / size;
                                /** @type {number} */
                                width = Math.round(1E3 * width) / 1E3;
                                /** @type {number} */
                                height = Math.round(1E3 * height) / 1E3;
                                string.replace();
                                string.search("pos", width + "," + height);
                                startX = e.pageX;
                                startY = e.pageY;
                            }
                        });
                    };
                    /**
                         * @param {Object} e
                         * @return {undefined}
                         */
                    var toggle = function(e) {
                        start(e);
                    };
                    /**
                         * @param {?} extra
                         * @return {undefined}
                         */
                    var trigger = function(extra) {
                        scope.$applyAsync(function() {
                            /** @type {boolean} */
                            result.active = false;
                            /** @type {boolean} */
                            startX = false;
                            /** @type {boolean} */
                            startY = false;
                        });
                    };
                    element.bind("mousemove", init);
                    element.bind("mouseup", show);
                    element.bind("mouseover", toggle);
                    element.bind("mouseout", trigger);
                    element.bind("wheel", function(e) {
                        if (!(window.Math.abs(e.originalEvent.deltaY) < 4)) {
                            scope.$applyAsync(function() {
                                var s = size;
                                var SCALE_RATIO = element.width();
                                var y = element.height();
                                /** @type {number} */
                                var k = e.originalEvent.pageX - element.offset().left;
                                /** @type {number} */
                                var l = e.originalEvent.pageY - element.offset().top;
                                if (e.originalEvent.deltaY < 0) {
                                    scope.WorldMap.zoomChange(1);
                                } else {
                                    scope.WorldMap.zoomChange(-1);
                                }
                                /** @type {number} */
                                var cotangent = SCALE_RATIO * size / s;
                                /** @type {number} */
                                var h = y * size / s;
                                /** @type {number} */
                                var n = k * (1 - size / s) + (cotangent - SCALE_RATIO) / 2;
                                /** @type {number} */
                                var height_mod = l * (1 - size / s) + (h - y) / 2;
                                update();
                                /** @type {number} */
                                var i = width - n;
                                /** @type {number} */
                                var $1 = Math.round((i + j / 2) / size * 1E3) / 1E3;
                                /** @type {number} */
                                var top = height - height_mod;
                                /** @type {number} */
                                var $2 = Math.round((top + w / 2) / size * 1E3) / 1E3;
                                string.search("pos", $1 + "," + $2);
                            });
                        }
                    });
                    $(window).resize(update);
                    update();
                    scope.$on("recalcMapSectors", update);
                    scope.$watch(function() {
                        return string.search().pos;
                    }, update);
                }
            };
        }
    ]),
    module.factory("MapUtils", function() {
        var isCenter = {
            /**
                 * @param {(number|string)} j
                 * @param {(number|string)} i
                 * @return {?}
                 */
            getRoomNameFromXY: function(j, i) {
                return j = 0 > j
                    ? "W" + (-j - 1)
                    : "E" + j,
                i = 0 > i
                    ? "N" + (-i - 1)
                    : "S" + i,
                "" + j + i;
            },
            /**
                 * @param {string} method
                 * @return {?}
                 */
            roomNameToXY: function(method) {
                method = method.toUpperCase();
                var m = method.match(/^(\w)(\d+)(\w)(\d+)$/);
                var W = (m[0], m[1]);
                var my = m[2];
                var how = m[3];
                var formula = m[4];
                return my = "W" == W
                    ? -my - 1
                    : + my,
                formula = "N" == how
                    ? -formula - 1
                    : + formula,
                [my, formula];
            },
            /**
                 * @param {number} exp
                 * @return {?}
                 */
            isBus: function(exp) {
                return 0 > exp && (exp + 1) % 10 == 0 || (exp > 0 && exp % 10 == 0 || 0 == exp);
            },
            /**
                 * @param {number} exp
                 * @param {number} delta
                 * @return {?}
                 */
            isCenter: function(exp, delta) {
                return (0 > exp && (window.Math.abs(exp + 1) % 10 >= 4 && window.Math.abs(exp + 1) % 10 <= 6) || exp >= 0 && (window.Math.abs(exp) % 10 >= 4 && window.Math.abs(exp) % 10 <= 6)) && (0 > delta && (window.Math.abs(delta + 1) % 10 >= 4 && window.Math.abs(delta + 1) % 10 <= 6) || delta >= 0 && (window.Math.abs(delta) % 10 >= 4 && window.Math.abs(delta) % 10 <= 6));
            }
        };
        return isCenter;
    }),
    module.controller("Top.WorldMap.MapFloatInfo", [
        "$scope",
        "$location",
        "$routeSegment",
        function(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            this["float"] = result;
        }
    ]),
    module.directive("appGameMapRoomObjects", [
        "Socket",
        "$timeout",
        "$interval",
        "Auth",
        function(fn, $timeout, dataAndEvents, opts) {
            /**
                 * @param {MessageEvent} stream
                 * @param {?} files
                 * @param {Array} debug
                 * @param {number} a
                 * @return {undefined}
                 */
            function upload(stream, files, debug, a) {
                if (files && files.length) {
                    /** @type {number} */
                    var b = 0;
                    for (; a > b; b++) {
                        /** @type {number} */
                        var max = 0;
                        for (; a > max; max++) {
                            files.forEach(function(sp) {
                                stream.data[50 * a * (a * sp[1] + max) * 4 + 4 * (a * sp[0] + b) + 0] = debug[0];
                                stream.data[50 * a * (a * sp[1] + max) * 4 + 4 * (a * sp[0] + b) + 1] = debug[1];
                                stream.data[50 * a * (a * sp[1] + max) * 4 + 4 * (a * sp[0] + b) + 2] = debug[2];
                                /** @type {number} */
                                stream.data[50 * a * (a * sp[1] + max) * 4 + 4 * (a * sp[0] + b) + 3] = 255;
                            });
                        }
                    }
                }
            }
            /**
                 * @return {?}
                 */
            function guid() {
                var output;
                var camelKey;
                var restoreScript;
                var data;
                /** @type {number} */
                var f = 0;
                do {
                    f++;
                    /** @type {number} */
                    output = 5 * Math.round(30 * Math.random() / 5) - 15;
                    /** @type {number} */
                    camelKey = 0.1 * Math.round(0.2 * Math.random() / 0.1) + 0.8;
                    /** @type {number} */
                    restoreScript = 0.1 * Math.round(0.2 * Math.random() / 0.1) + 0.4;
                    data = round(output, camelKey, restoreScript);
                } while (100 > f && _.any(obj, function(p) {
                    return _.isEqual(data, p);
                }));
                return data;
            }
            var obj = {
                2: [
                    255, 150, 0
                ],
                3: [
                    255, 150, 0
                ],
                w: [
                    0, 0, 0
                ],
                r: [
                    60, 60, 60
                ],
                pb: [
                    255, 255, 255
                ],
                m: [
                    170, 170, 170
                ],
                p: [
                    0, 200, 255
                ],
                k: [
                    100, 0, 0
                ],
                c: [
                    80, 80, 80
                ],
                s: [255, 242, 70]
            };
            return {
                /**
                     * @param {Object} scope
                     * @param {Array} elem
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(scope, elem, attrs) {
                    var element;
                    var scrollIntervalId;
                    var promise;
                    var uncaughtException;
                    var ctx = elem[0].getContext("2d");
                    /** @type {number} */
                    var r = parseInt(attrs.mapScale);
                    if (opts.Me) {
                        /** @type {Array} */
                        obj[opts.Me._id] = [0, 255, 0];
                    }
                    /**
                         * @param {string} e
                         * @return {?}
                         */
                    var blur = function(e) {
                        return scope.$applyAsync(function() {
                            element = fn.bindEventToScope(scope, "roomMap2:" + e, function(other) {
                                if (uncaughtException == e) {
                                    var data = ctx.createImageData(50 * r, 50 * r);
                                    if (other) {
                                        if (other.roads) {
                                            upload(data, other.roads, obj.roads, r);
                                        }
                                        _.forEach(other, function(srcFiles, implementation) {
                                            if ("roads" != implementation) {
                                                if (!obj[implementation]) {
                                                    obj[implementation] = guid();
                                                }
                                                upload(data, srcFiles, obj[implementation], r);
                                            }
                                        });
                                    }
                                    ctx.putImageData(data, 0, 0);
                                    if (scrollIntervalId) {
                                        clearInterval(scrollIntervalId);
                                    }
                                }
                            });
                        });
                    };
                    attrs.$observe("appGameMapRoomObjects", function(e) {
                        if (element) {
                            element.remove();
                            ctx.putImageData(ctx.createImageData(50 * r, 50 * r), 0, 0);
                            /** @type {null} */
                            element = null;
                        }
                        if (scrollIntervalId) {
                            clearInterval(scrollIntervalId);
                            /** @type {null} */
                            scrollIntervalId = null;
                        }
                        if (promise) {
                            $timeout.cancel(promise);
                            /** @type {null} */
                            promise = null;
                        }
                        if (e) {
                            uncaughtException = e;
                            promise = $timeout(500).then(function() {
                                blur(e);
                                /** @type {null} */
                                promise = null;
                            });
                        }
                    });
                }
            };
        }
    ]),
    module.directive("appGameMapSector", [
        "BadgeGenerator",
        "$timeout",
        "$q",
        function(c, dataAndEvents, done) {
            /** @type {number} */
            var f = 0;
            return setInterval(function() {
                f += 10;
                if (f > 255) {
                    /** @type {number} */
                    f = 0;
                }
            }, 1E3), {
                /**
                     * @param {Array} $scope
                     * @param {Array} elem
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function($scope, elem, tabCtrl) {
                    /**
                         * @param {Object} deepDataAndEvents
                         * @param {number} x
                         * @param {number} y
                         * @param {number} size
                         * @param {Blob} alpha
                         * @param {Function} ready
                         * @return {?}
                         */
                    function init(deepDataAndEvents, x, y, size, alpha, ready) {
                        return done(function(proceed) {
                            /** @type {Image} */
                            var background = new Image;
                            /**
                                 * @return {undefined}
                                 */
                            background.onload = function() {
                                if (ready()) {
                                    /** @type {Blob} */
                                    ctx.globalAlpha = alpha;
                                    ctx.drawImage(background, x - size / 2, y - size / 2);
                                    if (alpha) {
                                        /** @type {string} */
                                        ctx.strokeStyle = "#000";
                                        /** @type {number} */
                                        ctx.lineWidth = size / 10;
                                        ctx.beginPath();
                                        ctx.arc(x, y, size / 2 + ctx.lineWidth / 2, 0, 2 * Math.PI, false);
                                        ctx.closePath();
                                        ctx.stroke();
                                    }
                                    proceed();
                                }
                            };
                            /** @type {Object} */
                            background.src = deepDataAndEvents;
                        });
                    }
                    /**
                         * @return {undefined}
                         */
                    function render() {
                        var users = $scope.WorldMap.roomUsers;
                        var old = $scope.WorldMap.roomStats;
                        ctx.clearRect(0, 0, 200, 200);
                        /** @type {number} */
                        var fx = Date.now();
                        if (type = fx, $scope.sector.rooms) {
                            var m = $scope.sector.rooms.split(",");
                            /** @type {number} */
                            var i = 0;
                            for (; cols > i; i++) {
                                /** @type {number} */
                                var j = 0;
                                for (; cols > j; j++) {
                                    var name = m[i * cols + j];
                                    if (name && old[name]) {
                                        if ("empty" == $scope.WorldMap.worldStatus && $scope.WorldMap.isRoomRespawnProhibited(name)) {
                                            /** @type {string} */
                                            ctx.fillStyle = "rgb(255, 50, 50)";
                                            /** @type {number} */
                                            ctx.globalAlpha = 0.2;
                                            ctx.fillRect(i * size, j * size, size, size);
                                        } else {
                                            if (old[name].novice) {
                                                if (old[name].novice > Date.now()) {
                                                    /** @type {string} */
                                                    ctx.fillStyle = "#57FF59";
                                                    /** @type {number} */
                                                    ctx.globalAlpha = 0.1;
                                                    ctx.fillRect(i * size, j * size, size, size);
                                                }
                                            }
                                        }
                                        if ("normal" != old[name].status && !old[name].safeMode || old[name].openTime > Date.now()) {
                                            /** @type {string} */
                                            ctx.fillStyle = "#000";
                                            /** @type {number} */
                                            ctx.globalAlpha = 0.4;
                                            ctx.fillRect(i * size, j * size, size, size);
                                        }
                                        if (old[name].safeMode) {
                                            /** @type {string} */
                                            ctx.strokeStyle = "rgb(255, 232, 0)";
                                            /** @type {number} */
                                            ctx.globalAlpha = 0.22;
                                            /** @type {number} */
                                            ctx.lineWidth = 1;
                                            ctx.strokeRect(i * size + 1, j * size + 1, size - 2, size - 2);
                                        }
                                        if (old[name].own) {
                                            if (users[old[name].own.user]) {
                                                !function(index, y, name) {
                                                    /** @type {number} */
                                                    var width = (20 + 20 * old[name].own.level / 8) * size / 100;
                                                    c.getImageData(users[old[name].own.user].badge, width, width).then(function(deepDataAndEvents) {
                                                        init(deepDataAndEvents, index * size + size / 2, y * size + size / 2, width, old[name].own.level
                                                            ? 1
                                                            : 0.5, function() {
                                                            return type == fx;
                                                        });
                                                    });
                                                }(i, j, name);
                                            }
                                        }
                                    } else {
                                        /** @type {string} */
                                        ctx.fillStyle = "#000";
                                        /** @type {number} */
                                        ctx.globalAlpha = 0.4;
                                        ctx.fillRect(i * size, j * size, size, size);
                                    }
                                }
                            }
                        }
                    }
                    var type;
                    var ctx = elem[0].getContext("2d");
                    ctx.canvas.width;
                    ctx.canvas.height;
                    $scope.$watch("sector.rooms", render);
                    $scope.$on("mapStatsUpdated", render);
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_login_47_login__ = function() {
    var module = angular.module("app.login", []);
    return module.factory("Login", [
        "$injector",
        function($injector) {
            var methods = {
                visible: false,
                /**
                     * @return {?}
                     */
                show: function() {
                    return window.nw
                        ? $injector.get("Auth").signInSteamByTicket()
                        : void(this.visible = true);
                },
                /**
                     * @return {undefined}
                     */
                hide: function() {
                    /** @type {boolean} */
                    this.visible = false;
                },
                /**
                     * @return {undefined}
                     */
                nwShow: function() {
                    if (window.nw) {
                        /** @type {boolean} */
                        this.visible = true;
                    }
                }
            };
            return methods;
        }
    ]),
    module.directive("appLogin", function() {
        return {templateUrl: "components/login/login.html?bust=1479290327467", controller: "Login as Login"};
    }),
    module.controller("Login", [
        "$scope",
        "Login",
        "Api",
        "Auth",
        "$window",
        "$location",
        "$routeSegment",
        "LocalStorage",
        "$q",
        "ZendeskSso",
        function(dataAndEvents, poster, deepDataAndEvents, auth, wnd, $location, header, ignoreMethodDoesntExist, $q, d) {
            var $scope = this;
            this.svc = poster;
            /** @type {string} */
            this.email = "";
            /** @type {string} */
            this.password = "";
            /**
                 * @return {?}
                 */
            this.signIn = function() {
                return $scope.email && $scope.password
                    ? init(auth.signIn($scope.email, $scope.password))
                    : void 0;
            };
            /**
                 * @return {?}
                 */
            this.signInGithub = function() {
                return init(auth.signInGithub());
            };
            /**
                 * @return {?}
                 */
            this.signInSteam = function() {
                return init(auth.signInSteam());
            };
            /**
                 * @param {?} p
                 * @return {?}
                 */
            var init = function(p) {
                return p.then(function() {
                    if (window.nw) {
                        return wnd.location.reload(),
                        $q.defer().promise;
                    }
                    if (auth.Me && !auth.Me.username) {
                        poster.hide();
                        $location.url("/register");
                    } else {
                        if (header.startsWith("top.register")) {
                            poster.hide();
                            $location.url("/");
                        } else {
                            if ("top.sso" != header.name) {
                                return wnd.location.reload(),
                                $q.defer().promise;
                            }
                            d.run();
                        }
                    }
                })["catch"](function() {
                    return $scope.error = true,
                    $q.reject();
                });
            };
        }
    ]),
    module.factory("ZendeskSso", [
        "Api",
        "$location",
        "Dialogs",
        function($templateCache, m3, o) {
            var _self = {
                /**
                     * @return {undefined}
                     */
                run: function() {
                    $templateCache.get("sso/jwt").then(function(_arg) {
                        /** @type {string} */
                        document.location.href = "https://screeps.zendesk.com/access/jwt?jwt=" + _arg.token + "&redirect_to=" + m3.search().redirect_to;
                    })["catch"](function(dataAndEvents) {
                        if ("no subscription" == dataAndEvents) {
                            o.alert("", "Posting on the forums is only allowed for users with an active subscription due to a large amount of spam. We are very sorry.");
                        }
                        if ("invalid email" == dataAndEvents) {
                            o.alert("", "You must set an email in your account settings to post on the forums.");
                        }
                    });
                }
            };
            return _self;
        }
    ]), {};
}();
var $__app_95_components_47_login_47_register__ = function() {
    var module = angular.module("app.register", []);
    return module.config([
        "$routeSegmentProvider",
        function($routeProvider) {
            $routeProvider.when("/register", "top.register").when("/sso", "top.sso").when("/register/confirm", "top.register-confirm").when("/register/recover", "top.register-recover").when("/register/ask-recover", "top.register-ask-recover").within("top").segment("register", {
                templateUrl: "components/login/register.html?bust=1479290327467",
                controller: "Top.Register as Register"
            }).segment("sso", {
                templateUrl: "components/login/register.html?bust=1479290327467",
                controller: "Top.Register as Register"
            }).segment("register-confirm", {
                templateUrl: "components/login/register-confirm.html?bust=1479290327467",
                controller: "Top.RegisterConfirm as RegisterConfirm",
                dependencies: ["id"]
            }).segment("register-recover", {
                templateUrl: "components/login/register-recover.html?bust=1479290327467",
                controller: "Top.RegisterRecover as RegisterRecover",
                resolve: {
                    data: ngInject([
                        "RegisterRecoverLoader",
                        "$routeParams",
                        function(t, msg) {
                            return t.load(msg.t);
                        }
                    ])
                },
                resolveFailed: {
                    templateUrl: "components/login/register-recover-error.html?bust=1479290327467"
                }
            }).segment("register-ask-recover", {
                templateUrl: "components/login/register-ask-recover.html?bust=1479290327467",
                controller: "Top.RegisterAskRecover as RegisterAskRecover"
            });
        }
    ]),
    module.controller("Top.Register", [
        "$scope",
        "Api",
        "$location",
        "Auth",
        "LocalStorage",
        "$routeSegment",
        "ZendeskSso",
        "Login",
        "$q",
        "NwLocalFileSync",
        "$timeout",
        "CodeBranches",
        function(dataAndEvents, $http, $location, req, engine, unused, d, a, Q, self, deepDataAndEvents, callback) {
            var result = this;
            /** @type {string} */
            this.email = "";
            /** @type {string} */
            this.password = "";
            /** @type {string} */
            this.username = "";
            this.emailValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[\w\d-\.\+&]+\@[\w\d\-\.&]+\.[\w\d\-\.&]{2,}$/.test(qualifier);
                },
                /**
                     * @param {string} isSorted
                     * @return {?}
                     */
                unique: function(isSorted) {
                    return $http.get("register/check-email", {email: isSorted});
                }
            };
            this.usernameValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[a-zA-Z0-9_-]+$/.test(qualifier);
                },
                /**
                     * @param {string} isSorted
                     * @return {?}
                     */
                unique: function(isSorted) {
                    return $http.get("register/check-username", {username: isSorted});
                }
            };
            this.passwordValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[a-z0-9!@\#$%^&\*\(\),\.\\\/\[\]{}\'\";=\+|_\-\?\~\`\:\<\>]*$/i.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                number: function(qualifier) {
                    return /[0-9]/.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                non_number: function(qualifier) {
                    return /[^0-9]/.test(qualifier);
                }
            };
            this.passwordConfirmValidators = {
                /**
                     * @param {(Object|string)} consume
                     * @return {?}
                     */
                match: function(consume) {
                    return consume == result.password;
                }
            };
            /**
                 * @return {?}
                 */
            this.signInGithub = function() {
                return req.signInGithub();
            };
            /**
                 * @return {?}
                 */
            this.signInSteam = function() {
                return req.signInSteam();
            };
            dataAndEvents.$watchGroup([
                function() {
                    return req.Me && req.Me._id;
                },
                function() {
                    return req.Me && req.Me.username;
                }
            ], function(mat0, mat1) {
                if (mat0[0] == mat1[0]) {
                    if (mat0[1]) {
                        if (req.Me.email || req.Me.steam) {
                            if ("top.sso" == unused.name) {
                                d.run();
                            } else {
                                $location.url("/");
                            }
                        } else {
                            $location.url(unused.getSegmentUrl("top.register-confirm"));
                        }
                    }
                }
            });
            /**
                 * @return {?}
                 */
            this.submit = function() {
                var files = engine.get("users.code.activeSim", []);
                files[0] = files[0] || {};
                files[0].modules = files[0].modules || {};
                var modules = files[0].modules;
                var cells = _.filter(engine.get("branches", []), function(item) {
                    return 0 == item.userId || req.Me && item.userId == req.Me._id;
                });
                return req.Me
                    ? $http.post("register/set-username", {
                        username: result.username,
                        recaptcha: result.recaptcha,
                        email: result.noEmail
                            ? void 0
                            : result.email,
                        tutorialDone: !!engine.get("tutorialSectionsDone", {1: false})[1]
                    }).then(function() {
                        mixpanel.track("Register set username", {username: result.username});
                        fbq("track", "CompleteRegistration");
                        ga("send", "event", "Register", "Set username");
                        req.check();
                        $location.url("/rooms");
                    }).then(function() {
                        return callback.submitCode(void 0, modules);
                    }).then(function() {
                        return Q.all(_.map(cells, function(data) {
                            return callback.cloneBranch(void 0, data.branch).then(function() {
                                return callback.submitCode(data.branch, data.modules);
                            }).then(function(p) {
                                return self.writeBranch(data.branch, data.modules, p.timestamp);
                            });
                        }));
                    })
                    : $http.post("register/submit", {
                        email: result.email,
                        password: result.password,
                        username: result.username,
                        recaptcha: result.recaptcha,
                        tutorialDone: !!engine.get("tutorialSectionsDone", {1: false})[1],
                        modules: modules,
                        branches: cells
                    }).then(function() {
                        mixpanel.track("Register submit", {
                            email: result.email,
                            username: result.username
                        });
                        ga("send", "event", "Register", "Register submit");
                        $location.url("/register/confirm");
                    });
            };
            /**
                 * @return {undefined}
                 */
            this.loginExisting = function() {
                a.nwShow();
            };
            if (!("top.sso" != unused.name)) {
                if (!req.Me) {
                    a.show();
                }
            }
        }
    ]),
    module.controller("Top.RegisterConfirm", [
        "Loader",
        "Login",
        "$routeSegment",
        "Api",
        "Auth",
        "$location",
        function(appLoading, a, mod, _, req, $location) {
            var r = this;
            return req.Me && ((req.Me.email || (req.Me.steam || req.Me.github)) && !req.Me.emailDirty)
                ? void $location.url("/")
                : (mod.$routeParams.id && appLoading.loading(_.post("register/confirm", {
                    id: mod.$routeParams.id,
                    s: mod.$routeParams.s
                }).then(function(result) {
                    /** @type {string} */
                    r.result = "ok";
                    mixpanel.track("Register email confirm", {email: result.email});
                    mixpanel.alias(result.email);
                    ga("send", "event", "Register", "Register Success", "Register Email");
                    fbq("track", "CompleteRegistration");
                })["catch"](function() {
                    /** @type {string} */
                    r.result = "error";
                })), void(this.signIn = function() {
                    return a.show();
                }));
        }
    ]),
    module.controller("Top.RegisterAskRecover", [
        "Api",
        function($http) {
            var response = this;
            /** @type {string} */
            this.email = "";
            /**
                 * @return {?}
                 */
            this.submit = function() {
                return response.result = void 0,
                $http.post("register/recover", {email: response.email}).then(function() {
                    return response.result = true;
                })["catch"](function(result) {
                    return response.result = result;
                });
            };
        }
    ]),
    module.factory("RegisterRecoverLoader", [
        "Loader",
        "Api",
        "$q",
        function($provide, res, $q) {
            return $provide.factory(function(oauth_token) {
                return res.post("register/change-password", {token: oauth_token})["catch"](function(r) {
                    return "invalid password" == r
                        ? {}
                        : $q.reject(r);
                });
            });
        }
    ]),
    module.controller("Top.RegisterRecover", [
        "Login",
        "$routeSegment",
        "Api",
        function(dataAndEvents, $rootScope, res) {
            var response = this;
            /** @type {string} */
            this.password = "";
            /** @type {string} */
            this.passwordConfirm = "";
            this.result = void 0;
            this.passwordValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[a-z0-9!@\#$%^&\*\(\),\.\\\/\[\]{}\'\";=\+|_\-\?\~\`\:\<\>]*$/i.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                number: function(qualifier) {
                    return /[0-9]/.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                non_number: function(qualifier) {
                    return /[^0-9]/.test(qualifier);
                }
            };
            this.passwordConfirmValidators = {
                /**
                     * @param {(Object|string)} error
                     * @return {?}
                     */
                match: function(error) {
                    return error == response.password;
                }
            };
            /**
                 * @return {undefined}
                 */
            this.submit = function() {
                response.result = void 0;
                res.post("register/change-password", {
                    token: $rootScope.$routeParams.t,
                    password: response.password
                }).then(function() {
                    return response.result = true;
                })["catch"](function() {
                    return response.result = false;
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_nw_45_menu_47_nw_45_menu__ = function() {
    var module = angular.module("app.nw-menu", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/nw-menu", "nw-menu").segment("nw-menu", {
                templateUrl: "components/nw-menu/nw-menu.html?bust=1479290327467",
                controller: "NwMenu as NwMenu"
            });
        }
    ]),
    module.controller("NwMenu", [
        "$scope",
        "Dialogs",
        "$q",
        "Api",
        "$location",
        "$routeSegment",
        "Auth",
        "LocalStorage",
        "Socket",
        "WorldActivator",
        function(ignoreMethodDoesntExist, editor, request, module, $location, dataAndEvents, node, self, elem, deepDataAndEvents) {
            var that = this;
            /** @type {number} */
            this.backNum = Math.floor(8 * Math.random()) + 1;
            /** @type {string} */
            self.prefix = "";
            this.options = self.createSyncedObj("nwmenu", {
                official: true,
                host: "127.0.0.1",
                port: 21025,
                password: ""
            });
            /**
                 * @param {string} dataAndEvents
                 * @return {undefined}
                 */
            this.changeOfficial = function(dataAndEvents) {
                /** @type {string} */
                that.options.official = dataAndEvents;
            };
            var fs = require("fs");
            var path = require("path");
            var root = path.resolve(path.dirname(process.execPath).replace(/\/nwjs\.app.*$/, ""), "server");
            try {
                fs.statSync(root);
                /** @type {boolean} */
                this.hasServer = true;
            } catch (o) {}
            /**
                 * @return {?}
                 */
            this.connect = function() {
                return deepDataAndEvents.welcomeDialogDisplayed = false,
                _.extend(module.options, that.options),
                that.options.official
                    ? (module.options.apiUrl = "https://screeps.com/api/", elem.options.websocketUrl = "https://screeps.com/socket/", self.prefix = "")
                    : (module.options.apiUrl = "http://" + that.options.host + ":" + that.options.port + "/api/", elem.options.websocketUrl = "http://" + that.options.host + ":" + that.options.port + "/socket/", self.prefix = "local"),
                module.get("version").then(function(o) {
                    return o.protocol != nw.App.manifest.protocolVersion
                        ? request.reject("protocol")
                        : (node.useNativeAuth = o.useNativeAuth, module.options.serverData = o.serverData || {}, node.signInSteamByTicket());
                })["catch"](function(response) {
                    return _.isObject(response) && -1 == response.status
                        ? editor.alert("", {html: "Connection cannot be established. Please check your network settings and try again."})
                        : "protocol" == response
                            ? editor.alert("", {html: "Your client version is incompatible. Please update your game client and try again."})
                            : "server down" == response
                                ? editor.ask({title: "Maintenance", message: "The server is currently under maintenance. Please try again later.", buttonCancelLabel: "Open status page"}).result["catch"](function(dataAndEvents) {
                                    if ("cancel click" == dataAndEvents) {
                                        nw.Shell.openExternal("http://status.screeps.com");
                                    }
                                })
                                : "incorrect server password" == response
                                    ? editor.alert("", {html: "The password for this server is incorrect. Access denied."})
                                    : "timeout" != response && editor.alert("", {html: "An error occured while connecting to the server. Please try again later."}),
                    request.reject(response);
                }).then(function() {
                    return $location.path(dataAndEvents.getSegmentUrl("top.game-world-map"));
                });
            };
            /**
                 * @return {undefined}
                 */
            this.startServer = function() {
                var self = require("child_process");
                if ("darwin" == process.platform) {
                    self.spawn("open", [path.resolve(root, "screeps_server.app")], {
                        cwd: root,
                        detached: true
                    });
                } else {
                    if ("win32" == process.platform) {
                        self.spawn(path.resolve(root, "screeps_server.exe"), {
                            cwd: root,
                            detached: true
                        });
                    } else {
                        if ("linux" == process.platform) {
                            self.spawn(path.resolve(root, "screeps_server"), {
                                cwd: root,
                                detached: true
                            });
                        }
                    }
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_order_47_dlg_45_coupon_47_dlg_45_coupon__ = function() {
    var ngModule = angular.module("app.order.dlg-coupon", []);
    return ngModule.controller("DlgOrderCoupon", [
        "$scope",
        "Api",
        "Dialogs",
        "$modalInstance",
        "Auth",
        "$q",
        "$location",
        "$routeSegment",
        function(deepDataAndEvents, test, self, $modalStack, engineTools, ignoreMethodDoesntExist, $location, dataAndEvents) {
            var data = this;
            /** @type {string} */
            this.code = "";
            /**
             * @param {boolean} dataAndEvents
             * @return {?}
             */
            this.submit = function(dataAndEvents) {
                return test.post("xsolla/coupon", {
                    code: data.code,
                    convert: dataAndEvents
                }).then(function(modalInstance) {
                    engineTools.check();
                    $modalStack.close(modalInstance);
                })["catch"](function(dataAndEvents) {
                    return "subscribed" == dataAndEvents
                        ? self.ask("", "You already have an active subscription. Would you like to convert this credits coupon into subscription time? The conversion will be done based on 90 credits/day rate.").result.then(function() {
                            return data.submit(true);
                        })
                        : "credits" == dataAndEvents
                            ? ($modalStack.dismiss(), self.ask({message: "You still have CPU Credits to spend. To activate your subscription under the new model, please convert your Credits into subscription days.", buttonLabel: "Proceed"}).result.then(function() {
                                return $location.url(dataAndEvents.getSegmentUrl("top.account-subscription"));
                            }))
                            : void(data.error = "invalid coupon" == dataAndEvents
                                ? "Coupon code is not valid"
                                : "Unknown error");
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_order_47_order__ = function() {
    var module = angular.module("app.order", []);
    return module.config([
        "$routeSegmentProvider",
        function(t) {
            t.when("/order", "top.order").within("top").segment("order", {
                templateUrl: "components/order/order.html?bust=1479290327467",
                controller: "Top.Order as Order"
            });
        }
    ]),
    module.controller("Top.Order", [
        "$scope",
        "$rootScope",
        "Api",
        "$timeout",
        "$q",
        "Login",
        "Auth",
        "$modal",
        "$location",
        "$routeSegment",
        "Dialogs",
        "$interval",
        "Loader",
        "Socket",
        function(next_scope, pair, res, ignoreMethodDoesntExist, $http, a, engineTools, $modal, $location, dataAndEvents, self, next_callback, appLoading, deepDataAndEvents) {
            var p = this;
            if (engineTools.Me) {
                engineTools.check();
            }
            var events = {
                30: 8.95,
                90: 23.85,
                180: 41.7
            };
            /** @type {boolean} */
            this.asGift = false;
            this.sendGift = {
                email: "",
                text: "",
                /**
                     * @param {string} data
                     * @return {?}
                     */
                send: function(data) {
                    var assert = this;
                    return res.post("user/send-gift-coupon", {
                        code: data,
                        email: this.email,
                        text: this.text
                    }).then(function(dataAndEvents) {
                        return assert.ok = true;
                    });
                }
            };
            /**
                 * @param {(number|string)} type
                 * @return {?}
                 */
            this.order = function(type) {
                return engineTools.Me
                    ? !pair.ptr && engineTools.Me.isSteamSubscriber()
                        ? self.ask({message: "You already have an active Steam subscription. Please use Steam to manage your subscriptions.", buttonCancelLabel: "View on Steam"}).result["catch"](function(dataAndEvents) {
                            if ("cancel click" == dataAndEvents) {
                                /** @type {string} */
                                window.location.href = "https://store.steampowered.com/account/subscriptions/";
                            }
                        })
                        : (p.overrideAmount && (type = p.overrideAmount), pair.ptr
                            ? appLoading.loading(res.post("user/activate-ptr").then(function() {
                                engineTools.check();
                                p.isComplete = {
                                    ptr: true
                                };
                            }))
                            : engineTools.Me.credits > 0
                                ? (self.ask({message: "You still have CPU Credits to spend. To activate your subscription under the new model, please convert your Credits into subscription days.", buttonLabel: "Proceed"}).result.then(function() {
                                    return $location.url(dataAndEvents.getSegmentUrl("top.account-subscription"));
                                }), $http.when())
                                : (ga("send", "event", "Order", "Order Started"), mixpanel.track("Order Started", {amount: type}), res.post("xsolla/token", {amount: type}).then(function(v) {
                                    return $http(function($sanitize) {
                                        XPayStationWidget.init({
                                            access_token: v.token,
                                            sandbox: !!pair.ptr
                                        });
                                        XPayStationWidget.on("open", function() {
                                            $sanitize();
                                        });
                                        XPayStationWidget.on("status-done", function(dataAndEvents) {
                                            engineTools.check();
                                            ga("send", "event", "Order", "Order Success", "", type);
                                            mixpanel.track("Order Success", {amount: type});
                                            fbq("track", "Purchase", {
                                                value: "" + events[type],
                                                currency: "USD"
                                            });
                                            appLoading.loading(res.post("xsolla/check-order").then(function() {
                                                engineTools.check();
                                                /** @type {boolean} */
                                                p.isComplete = true;
                                            })["catch"](function(dataAndEvents) {
                                                engineTools.check();
                                                self.alert("", {html: 'An error occured during the payment. Please <a href="http://support.screeps.com/hc/en-us/requests/new">contact our support</a>.'});
                                            }));
                                        });
                                        XPayStationWidget.open();
                                    });
                                })))
                    : (a.show(), $http.when());
            };
            /**
                 * @return {?}
                 */
            this.openCoupon = function() {
                return engineTools.Me
                    ? void $modal.open({templateUrl: "components/order/dlg-coupon/dlg-coupon.html?bust=1479290327467", controller: "DlgOrderCoupon as DlgOrderCoupon", windowClass: "dlg-order-coupon-window"}).result.then(function(event) {
                        p.isComplete = {
                            amount: event
                        };
                        if (event) {
                            if (event.days) {
                                fbq("track", "Purchase", {
                                    value: "" + events[event.days],
                                    currency: "USD"
                                });
                            }
                        }
                    })
                    : void a.show();
            };
            /**
                 * @return {?}
                 */
            this.goToTwitter = function() {
                return $location.url(dataAndEvents.getSegmentUrl("top.twitter-promo"));
            };
            /**
                 * @return {?}
                 */
            this.goToTokens = function() {
                return self.ask({message: "This feature is still under development.", buttonLabel: "OK", buttonCancelLabel: "Learn more"}).result["catch"](function(dataAndEvents) {
                    if ("cancel click" == dataAndEvents) {
                        if (window.nw) {
                            nw.Shell.openExternal("http://support.screeps.com/hc/en-us/articles/207783649-Market-system");
                        } else {
                            /** @type {string} */
                            window.location.href = "http://support.screeps.com/hc/en-us/articles/207783649-Market-system";
                        }
                    }
                });
            };
            /**
                 * @return {undefined}
                 */
            this.goToSteam = function() {
                self.alert("", "You are now redirected to the Steam store. Please note that an application restart is required after purchasing the subscription.");
                nw.Shell.openExternal("steam://store/464350");
            };
            /**
                 * @return {?}
                 */
            this.purchaseToken = function() {
                return window.nw
                    ? (self.alert("", "Purchasing subscription tokens using the Steam client is not implemented yet. Please consider purchasing via the website."), $http.when())
                    : engineTools.Me
                        ? res.post("xsolla/token", {subscriptionToken: true}).then(function(v) {
                            return $http(function($sanitize) {
                                XPayStationWidget.init({
                                    access_token: v.token,
                                    sandbox: !!pair.ptr
                                });
                                XPayStationWidget.on("open", function() {
                                    $sanitize();
                                });
                                XPayStationWidget.on("status-done", function(dataAndEvents) {
                                    engineTools.check();
                                });
                                XPayStationWidget.open();
                            });
                        })
                        : (a.show(), $http.when());
            };
            /**
                 * @return {undefined}
                 */
            this.activateToken = function() {
                self.ask({
                    message: "Activating a token will add 60 days to your CPU subscription. Proceed?",
                    /**
                         * @return {?}
                         */
                    callback: function() {
                        return res.post("xsolla/coupon", {code: "token"}).then(function(error) {
                            p.isComplete = {
                                amount: error
                            };
                        });
                    }
                });
            };
            /** @type {number} */
            var stop = 14544288E5;
            next_scope.$watch(function() {
                return deepDataAndEvents.timeCorrection;
            }, function() {
                stop = 14544288E5 + deepDataAndEvents.timeCorrection;
            });
            /**
                 * @return {undefined}
                 */
            var run = function() {
                /** @type {Date} */
                var start = new Date;
                if (start >= stop) {
                    /** @type {null} */
                    p.offer = null;
                } else {
                    p.offer = {
                        days: Math.floor((stop - start) / 24 / 3600 / 1E3),
                        hours: Math.floor((stop - start) / 3600 / 1E3) % 24,
                        minutes: Math.floor((stop - start) / 60 / 1E3) % 60,
                        seconds: Math.floor((stop - start) / 1E3) % 60
                    };
                }
            };
            run();
            next_callback.bindToScope(next_scope, run, 1E3);
        }
    ]),
    module.directive("appNumberAnimated", function() {
        return function(scope, ret, iAttrs) {
            /**
                 * @return {undefined}
                 */
            function tick() {
                /** @type {number} */
                var time = Math.floor(index * (Date.now() - b) / (a - b));
                ret.html(Math.min(time, index));
                if (Date.now() < a) {
                    requestAnimationFrame(tick);
                }
            }
            var index = scope.$eval(iAttrs.appNumberAnimated);
            /** @type {number} */
            var b = Date.now();
            /** @type {number} */
            var a = Date.now() + 1E3;
            tick();
        };
    }), {};
}();
var $__app_95_components_47_order_47_twitter_45_promo_47_twitter_45_promo__ = function() {
    var module = angular.module("app.order.twitter-promo", []);
    return module.config(["$routeSegmentProvider", function(dataAndEvents) {}]),
    module.factory("TwitterPromoLoader", [
        "Loader",
        "Api",
        function($provide, $templateCache) {
            return $provide.factory(function() {
                return new Object({
                    twitter_promo: $templateCache.get("user/twitter-promo").then(function(dataAndEvents) {
                        return dataAndEvents;
                    })
                });
            });
        }
    ]),
    module.controller("Top.TwitterPromo", [
        "$scope",
        "data",
        "Api",
        "Auth",
        "LocalStorage",
        "$window",
        "$q",
        "Login",
        "$timeout",
        "Dialogs",
        "TwitterPromoLoader",
        function($rootScope, data, self, c, Session, dialog, $timeout, a, dataAndEvents, child, exports) {
            var req = this;
            this.data = data;
            twttr.ready(function() {
                twttr.events.bind("tweet", function(dataAndEvents) {
                    return $rootScope.$applyAsync(function() {
                        return req.checkPost();
                    });
                });
            });
            /**
                 * @return {?}
                 */
            this.signIn = function() {
                return c.Me
                    ? $timeout(function($sanitize, Application) {
                        /** @type {string} */
                        var modalOptions = self.options.apiUrl + "auth/twitter?";
                        if (c.Me) {
                            var auth = Session.get("auth");
                            modalOptions += "token=" + auth + "&";
                        }
                        /** @type {function (MessageEvent): undefined} */
                        var completed = (dialog.open(modalOptions), function(event) {
                            dialog.removeEventListener("message", completed);
                            /** @type {*} */
                            var assert = JSON.parse(event.data);
                            if (assert.ok) {
                                $sanitize();
                            } else {
                                Application();
                            }
                        });
                        dialog.addEventListener("message", completed);
                    }).then(function() {
                        return c.check();
                    }).then(function() {
                        return exports.load();
                    }).then(function() {
                        if (c.Me.twitter && c.Me.twitter.followers_count < 10) {
                            $rootScope.$broadcast("twitterPromo:notEnoughFollowers");
                        } else {
                            mixpanel.track("Twitter Linked");
                            ga("send", "event", "Twitter Promo", "Twitter Linked");
                        }
                    })
                    : a.show();
            };
            /**
                 * @return {?}
                 */
            this.checkPost = function() {
                return self.get("xsolla/check-tweet").then(function() {
                    return c.check();
                }).then(function() {
                    return ga("send", "event", "Twitter Promo", "Twitter Success"),
                    mixpanel.track("Twitter Success"),
                    fbq("track", "Purchase", {
                        value: "0.00",
                        currency: "USD"
                    }),
                    exports.load();
                })["catch"](function(dataAndEvents) {
                    if ("no tweet" == dataAndEvents || "tweet charged" == dataAndEvents) {
                        /** @type {string} */
                        req.checkError = "No matching tweet found";
                    }
                });
            };
            /**
                 * @return {?}
                 */
            this.unlink = function() {
                return child.ask("", "Warning! If you unlink your Twitter account during the promo period (or delete the tweet itself), the credits accrued will be forfeited. Do you wish to continue?").result.then(function() {
                    return self.post("user/unlink-twitter").then(function() {
                        return exports.load();
                    }).then(function() {
                        return c.check();
                    });
                });
            };
            /**
                 * @return {?}
                 */
            this.getNextDate = function() {
                return new Date(c.Me.lastTweetTime + 2592E6);
            };
        }
    ]),
    module.directive("appTwitterLoad", function() {
        return {
            /**
                 * @param {?} tabCtrl
                 * @param {Object} attrs
                 * @param {?} scope
                 * @return {undefined}
                 */
            link: function(tabCtrl, attrs, scope) {
                twttr.widgets.load(attrs[0]).then(function() {
                    return attrs.show();
                });
            }
        };
    }),
    module.directive("appTwitterNotEnoughFollowers", [
        "$animate",
        function(ele) {
            return {
                /**
                     * @param {?} scope
                     * @param {?} el
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function(scope, el, tabCtrl) {
                    scope.$on("twitterPromo:notEnoughFollowers", function() {
                        ele.addClass(el, "anim-shake2").then(function() {
                            return ele.removeClass(el, "anim-shake2");
                        });
                    });
                }
            };
        }
    ]),
    module.directive("appTwitterSuccess", [
        "$animate",
        function(ele) {
            return {
                /**
                     * @param {?} scope
                     * @param {?} el
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function(scope, el, tabCtrl) {
                    scope.$on("twitterPromo:success", function() {
                        ele.addClass(el, "anim-shake2").then(function() {
                            return ele.removeClass(el, "anim-shake2");
                        });
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_account_47_account__ = function() {
    var module = angular.module("app.profile.account", []);
    return module.config([
        "$routeSegmentProvider",
        function($routeProvider) {
            $routeProvider.when("/account", "top.account").when("/account/password", "top.account-password").when("/account/github", "top.account-github").when("/account/email", "top.account-email").within("top").segment("account", {
                templateUrl: "components/profile/account/account.html?bust=1479290327467",
                controller: "Top.Account as Account"
            }).segment("account-password", {
                templateUrl: "components/profile/account/account-password.html?bust=1479290327467",
                controller: "Top.AccountPassword as AccountPassword"
            }).segment("account-email", {
                templateUrl: "components/profile/account/account-email.html?bust=1479290327467",
                controller: "Top.AccountEmail as AccountEmail"
            }).segment("account-github", {
                templateUrl: "components/profile/account/account-github.html?bust=1479290327467",
                controller: "Top.AccountGitHub as AccountGitHub",
                resolve: {
                    data: ngInject([
                        "AccountGitHubLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("Top.Account", [
        "Auth",
        "Dialogs",
        "Api",
        "$timeout",
        "$location",
        "$routeSegment",
        "$q",
        function(self, options, m, deepDataAndEvents, $location, dataAndEvents, $q) {
            self.required();
            /**
                 * @return {?}
                 */
            this.linkGitHub = function() {
                return self.signInGithub();
            };
            /**
                 * @return {undefined}
                 */
            this.unlinkGitHub = function() {
                options.ask("", "Do you really want to unlink your GitHub account?").result.then(function() {
                    return m.post("user/unlink-github");
                }).then(function() {
                    return self.check();
                });
            };
            /**
                 * @return {?}
                 */
            this.linkSteam = function() {
                return self.signInSteam();
            };
            /**
                 * @return {undefined}
                 */
            this.unlinkSteam = function() {
                options.ask("", "Do you really want to unlink your Steam account?").result.then(function() {
                    return m.post("user/unlink-steam");
                }).then(function() {
                    return self.check();
                });
            };
            /**
                 * @param {?} dataAndEvents
                 * @return {?}
                 */
            this.toggleNotificationsDisabled = function(dataAndEvents) {
                if (!dataAndEvents && !self.Me.email) {
                    return options.alert("", "Please specify your e-mail address first."),
                    $q.when();
                }
                var disabled = self.Me.notifyPrefs && self.Me.notifyPrefs.disabled;
                return m.post("user/notify-prefs", {
                    disabled: !disabled
                }).then(function() {
                    return self.check();
                });
            };
            /**
                 * @return {undefined}
                 */
            this.setNotificationsInterval = function() {
                options.askForSelect({
                    label: "Send interval",
                    value: self.Me.notifyPrefs && self.Me.notifyPrefs.interval || 5,
                    options: [
                        {
                            5: "5 min"
                        }, {
                            10: "10 min"
                        }, {
                            30: "30 min"
                        }, {
                            60: "1 hour"
                        }, {
                            180: "3 hours"
                        }, {
                            360: "6 hours"
                        }, {
                            720: "12 hours"
                        }, {
                            1440: "24 hours"
                        }, {
                            4320: "3 days"
                        }
                    ],
                    note: "All notifications will be grouped and mailed out periodically using this interval.",
                    /**
                         * @param {(number|string)} pageInterval
                         * @return {?}
                         */
                    callback: function(pageInterval) {
                        return m.post("user/notify-prefs", {interval: pageInterval}).then(function() {
                            return self.check();
                        });
                    }
                });
            };
            /**
                 * @return {undefined}
                 */
            this.setNotificationsErrorsInterval = function() {
                options.askForSelect({
                    label: "Notify on errors",
                    value: self.Me.notifyPrefs && void 0 !== self.Me.notifyPrefs.errorsInterval
                        ? self.Me.notifyPrefs.errorsInterval
                        : 30,
                    options: [
                        {
                            0: "Immediately"
                        }, {
                            10: "Every 10 min"
                        }, {
                            30: "Every 30 min"
                        }, {
                            60: "Every 1 hour"
                        }, {
                            180: "Every 3 hours"
                        }, {
                            360: "Every 6 hours"
                        }, {
                            720: "Every 12 hours"
                        }, {
                            1440: "Every 24 hours"
                        }, {
                            4320: "Every 3 days"
                        }, {
                            1E5: "Never"
                        }
                    ],
                    note: "Send notifications when your script throws an error.",
                    /**
                         * @param {?} __
                         * @return {?}
                         */
                    callback: function(__) {
                        return m.post("user/notify-prefs", {errorsInterval: __}).then(function() {
                            return self.check();
                        });
                    }
                });
            };
            /**
                 * @param {?} dataAndEvents
                 * @return {?}
                 */
            this.toggleNotificationsMessages = function(dataAndEvents) {
                var disabledOnMessages = self.Me.notifyPrefs && self.Me.notifyPrefs.disabledOnMessages;
                return m.post("user/notify-prefs", {
                    disabledOnMessages: !disabledOnMessages
                }).then(function() {
                    return self.check();
                });
            };
            /**
                 * @param {?} dataAndEvents
                 * @return {?}
                 */
            this.toggleNotificationsOnline = function(dataAndEvents) {
                var sendOnline = self.Me.notifyPrefs && self.Me.notifyPrefs.sendOnline;
                return m.post("user/notify-prefs", {
                    sendOnline: !sendOnline
                }).then(function() {
                    return self.check();
                });
            };
            /**
                 * @return {?}
                 */
            this.setGitHubRepo = function() {
                return m.get("auth/github/check-repo-scope")["catch"](function(r) {
                    return "no scope" == r
                        ? self.signInGithub(true)
                        : $q.reject(r);
                }).then(function() {
                    $location.url(dataAndEvents.getSegmentUrl("top.account-github"));
                });
            };
            /**
                 * @return {?}
                 */
            this.isSubscriptionActive = function() {
                return self.Me.subscription || (self.Me.promoPeriodUntil > Date.now() || self.Me.isSteamSubscriber());
            };
        }
    ]),
    module.controller("Top.AccountPassword", [
        "Auth",
        "Api",
        "$location",
        "$routeSegment",
        function(field, $http, $location, dataAndEvents) {
            var self = this;
            field.required();
            /** @type {string} */
            this.password = "";
            /** @type {string} */
            this.oldPassword = "";
            this.passwordValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[a-z0-9!@\#$%^&\*\(\),\.\\\/\[\]{}\'\";=\+|_\-\?\~\`\:\<\>]*$/i.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                number: function(qualifier) {
                    return /[0-9]/.test(qualifier);
                },
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                non_number: function(qualifier) {
                    return /[^0-9]/.test(qualifier);
                }
            };
            this.passwordConfirmValidators = {
                /**
                     * @param {(Object|string)} i
                     * @return {?}
                     */
                match: function(i) {
                    return i == self.password;
                }
            };
            /**
                 * @return {?}
                 */
            this.submit = function() {
                return $http.post("user/password", {
                    oldPassword: self.oldPassword,
                    password: self.password
                }).then(function() {
                    return field.check();
                }).then(function() {
                    return $location.url(dataAndEvents.getSegmentUrl("top.account"));
                });
            };
        }
    ]),
    module.controller("Top.AccountEmail", [
        "Auth",
        "Api",
        "$location",
        "$routeSegment",
        "Dialogs",
        function(field, db, $location, dataAndEvents, o) {
            var result = this;
            field.required();
            /** @type {string} */
            this.email = "";
            this.emailValidators = {
                /**
                     * @param {?} qualifier
                     * @return {?}
                     */
                correct: function(qualifier) {
                    return /^[\w\d-\.\+&]+\@[\w\d\-\.&]+\.[\w\d\-\.&]{2,}$/.test(qualifier);
                },
                /**
                     * @param {string} isSorted
                     * @return {?}
                     */
                unique: function(isSorted) {
                    return db.get("register/check-email", {email: isSorted});
                }
            };
            /**
                 * @return {?}
                 */
            this.submit = function() {
                return db.post("user/email", {email: result.email}).then(function() {
                    return field.check();
                }).then(function() {
                    return $location.url(dataAndEvents.getSegmentUrl("top.account"));
                }).then(function() {
                    return db.options.official && o.alert("", {html: "We have sent a confirmation e-mail to you.<br>Please check your mail and click the link there."});
                });
            };
        }
    ]),
    module.factory("AccountGitHubLoader", [
        "Loader",
        "Api",
        function($provide, $templateCache) {
            return $provide.factory(function() {
                return new Object({
                    repos: $templateCache.get("user/github-repos").then(function($scope) {
                        return $scope.repos;
                    })
                });
            });
        }
    ]),
    module.controller("Top.AccountGitHub", [
        "Auth",
        "Api",
        "$location",
        "$routeSegment",
        "data",
        "Dialogs",
        "$q",
        function(field, res, $location, dataAndEvents, options, dialog, $q) {
            var self = this;
            field.required();
            this.repo = field.Me.github && (field.Me.github.repo && field.Me.github.repo.name) || void 0;
            this.folder = field.Me.github && (field.Me.github.repo && field.Me.github.repo.folder) || "";
            options.repos = _.uniq(options.repos, function(unused) {
                return unused.name;
            });
            this.reposList = _.map(options.repos, function(definition) {
                var ctx;
                return new Object((ctx = {}, Object.defineProperty(ctx, definition.name, {
                    value: definition.name,
                    configurable: true,
                    enumerable: true,
                    writable: true
                }), ctx));
            });
            /**
                 * @return {?}
                 */
            this.submit = function() {
                return dialog.ask("Warning", "All your scripts in Screeps account will be overwritten with this action! Are you sure?").result.then(function() {
                    return res.post("user/github-repo", {
                        repo: self.repo,
                        folder: self.folder
                    });
                }).then(function() {
                    return field.check();
                }).then(function() {
                    return $location.url(dataAndEvents.getSegmentUrl("top.account"));
                })["catch"](function(response) {
                    return "no default branch" == response && (self.error = 'You have no "default" branch.'),
                    $q.reject(response);
                });
            };
            /**
                 * @return {?}
                 */
            this.reset = function() {
                return res.post("user/github-repo", {repo: false}).then(function() {
                    return field.check();
                }).then(function() {
                    return $location.url(dataAndEvents.getSegmentUrl("top.account"));
                });
            };
        }
    ]),
    module.directive("appAccountEditPage", function() {
        return {
            scope: {
                title: "@"
            },
            templateUrl: "account-edit-page",
            restrict: "E",
            transclude: true
        };
    }),
    module.factory("AccountSaveRedirector", [
        "$location",
        "$routeSegment",
        function($location, dataAndEvents) {
            var unpipedDest;
            var publicMethods = {
                /**
                     * @param {string} dest
                     * @return {undefined}
                     */
                set: function(dest) {
                    /** @type {string} */
                    unpipedDest = dest;
                },
                /**
                     * @return {undefined}
                     */
                reset: function() {
                    /** @type {null} */
                    unpipedDest = null;
                },
                /**
                     * @return {undefined}
                     */
                redirect: function() {
                    $location.url(dataAndEvents.getSegmentUrl(unpipedDest || "top.account"));
                    this.reset();
                }
            };
            return publicMethods;
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_account_47_badge_47_account_45_badge__ = function() {
    var module = angular.module("app.profile.account.badge", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/account/badge", "top.account-badge").within("top").segment("account-badge", {
                templateUrl: "components/profile/account/badge/account-badge.html?bust=1479290327467",
                controller: "Top.AccountBadge as AccountBadge"
            });
        }
    ]),
    module.controller("Top.AccountBadge", [
        "Auth",
        "Dialogs",
        "Api",
        "$interval",
        "BadgeGenerator",
        "BadgePaths",
        "$scope",
        "$location",
        "$routeSegment",
        "AccountSaveRedirector",
        function(arg, dataAndEvents, $http, next_callback, data, type, next_scope, deepDataAndEvents, ignoreMethodDoesntExist, res) {
            var node = this;
            arg.required();
            /**
                 * @return {?}
                 */
            this.pathInfo = function() {
                return type[node.data.type];
            };
            /** @type {Array} */
            this.types = [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24
            ];
            /**
                 * @param {?} originalType
                 * @return {undefined}
                 */
            this.selectSymbol = function(originalType) {
                node.data.type = originalType;
                /** @type {boolean} */
                node.data.flip = false;
                /** @type {number} */
                node.data.param = 0;
            };
            /**
                 * @return {?}
                 */
            this.resetSymbol = function() {
                return node.data.type = null;
            };
            this.data = _.clone(arg.Me.badge || {
                type: null,
                color1: "#000077",
                color2: "#5555dd",
                color3: "#9999ff",
                param: 0,
                flip: false
            });
            if (!_.isString(this.data.color1)) {
                this.data.color1 = data.colors[this.data.color1].rgb;
            }
            if (!_.isString(this.data.color2)) {
                this.data.color2 = data.colors[this.data.color2].rgb;
            }
            if (!_.isString(this.data.color3)) {
                this.data.color3 = data.colors[this.data.color3].rgb;
            }
            this.creep = {
                _id: "creep",
                x: 0,
                y: 0,
                energyCapacity: 100,
                energy: 0,
                user: 0,
                body: []
            };
            /** @type {boolean} */
            this.data._watching = true;
            /**
                 * @return {?}
                 */
            this.save = function() {
                return $http.post("user/badge", {badge: node.data}).then(function() {
                    delete node.data._watching;
                    arg.Me.badge = node.data;
                    res.redirect();
                });
            };
            /**
                 * @return {undefined}
                 */
            this.randomize = function() {
                /** @type {number} */
                node.data.type = Math.floor(24 * Math.random()) + 1;
                if (Math.random() > 0.5) {
                    node.data.color1 = data.colors[Math.floor(20 * Math.random())].rgb;
                    node.data.color2 = data.colors[Math.floor(60 * Math.random()) + 20].rgb;
                    node.data.color3 = data.colors[Math.floor(60 * Math.random()) + 20].rgb;
                } else {
                    node.data.color1 = data.colors[Math.floor(20 * Math.random()) + 60].rgb;
                    node.data.color2 = data.colors[Math.floor(60 * Math.random())].rgb;
                    node.data.color3 = data.colors[Math.floor(60 * Math.random())].rgb;
                }
                /** @type {boolean} */
                node.data.flip = Math.random() > 0.5;
                /** @type {number} */
                node.data.param = Math.floor(200 * Math.random()) - 100;
            };
            /** @type {number} */
            this.energy = 0;
            /** @type {number} */
            var txt = 1;
            next_callback.bindToScope(next_scope, function() {
                node.energy += txt;
                if (node.energy > 70) {
                    /** @type {number} */
                    node.energy = 70;
                    /** @type {number} */
                    txt = -1;
                }
                if (node.energy < 0) {
                    /** @type {number} */
                    node.energy = 0;
                    /** @type {number} */
                    txt = 1;
                }
            }, 30);
            /**
                 * @return {undefined}
                 */
            var run = function() {
                /** @type {number} */
                node.creep.energy = Math.random() > 0.6
                    ? 80 * Math.random() + 20
                    : 0;
                /** @type {number} */
                var a = Math.floor(20 * Math.random()) + 1;
                var paramType = ["work", "attack", "ranged_attack", "claim"][Math.floor(4 * Math.random())];
                /** @type {number} */
                var mt = Math.random() > 0.3
                    ? Math.floor(20 * Math.random()) + 1
                    : 0;
                /** @type {number} */
                var i = Math.random() > 0.7
                    ? Math.floor(20 * Math.random()) + 2
                    : 0;
                /** @type {Array} */
                node.creep.body = [];
                /** @type {number} */
                var b = 0;
                for (; a > b; b++) {
                    node.creep.body.push({type: "move", hits: 100});
                }
                /** @type {number} */
                b = 0;
                for (; mt > b; b++) {
                    node.creep.body.push({type: paramType, hits: 100});
                }
                /** @type {number} */
                b = 0;
                for (; i > b; b++) {
                    node.creep.body.push({type: "tough", hits: 100});
                }
                next_scope.$broadcast("roomObjectsUpdated");
            };
            run();
            next_callback.bindToScope(next_scope, run, 500);
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_account_47_subscription_47_account_45_subscription__ = function() {
    var module = angular.module("app.profile.account.subscription", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/account/subscription", "top.account-subscription").within("top").segment("account-subscription", {
                templateUrl: "components/profile/account/subscription/account-subscription.html?bust=1479290327467",
                controller: "Top.AccountSubscription as AccountSubscription",
                resolve: {
                    data: ngInject([
                        "AccountSubscriptionLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("AccountSubscriptionLoader", [
        "Loader",
        "Api",
        function($provide, $templateCache) {
            return $provide.factory(function() {
                return new Object({
                    sub: $templateCache.get("xsolla/user").then(function(dataAndEvents) {
                        return dataAndEvents;
                    })
                });
            });
        }
    ]),
    module.controller("Top.AccountSubscription", [
        "$scope",
        "Auth",
        "data",
        "Api",
        "AccountSubscriptionLoader",
        "Dialogs",
        function($scope, field, node, $http, exports, child) {
            $scope.Math = Math;
            field.required();
            field.check();
            /** @type {Array} */
            this.data = node;
            /**
                 * @return {?}
                 */
            this.getDays = function() {
                return Math.round((node.sub.active - Date.now()) / 24 / 3600 / 1E3);
            };
            /**
                 * @return {?}
                 */
            this.cancelSubscription = function() {
                return child.ask("", "Do you want to cancel your subscription?").result.then(function() {
                    return $http.post("xsolla/cancel-subscription");
                }).then(function() {
                    return exports.load();
                });
            };
            /**
                 * @return {?}
                 */
            this.convertCredits = function() {
                return $http.post("user/convert-credits-subscription").then(function() {
                    return exports.load();
                }).then(function() {
                    return field.check();
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_cpu_47_cpu__ = function() {
    var module = angular.module("app.profile.cpu", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/cpu", "top.cpu").within("top").segment("cpu", {
                templateUrl: "components/profile/cpu/cpu.html?bust=1479290327467",
                controller: "Top.ProfileCpu as ProfileCpu"
            });
        }
    ]),
    module.controller("Top.ProfileCpu", [
        "$scope",
        "Api",
        "$timeout",
        "$q",
        "Login",
        "Auth",
        "Socket",
        "Dialogs",
        "WorldActivator",
        "$rootScope",
        "$location",
        "$routeSegment",
        function(deepDataAndEvents, $http, ignoreMethodDoesntExist, $q, textAlt, self, S, o, details, pair, $location, dataAndEvents) {
            var cpu = this;
            return self.required(),
            self.check(),
            0 == self.Me.credits
                ? ($location.replace(), void $location.url(dataAndEvents.getSegmentUrl("top.account-subscription")))
                : (this.changeLimit = function() {
                    /** @type {boolean} */
                    cpu.isChangingLimit = true;
                },
                this.resetChangeLimit = function() {
                    /** @type {boolean} */
                    cpu.isChangingLimit = false;
                    cpu.changeLimitValue = self.Me.cpu;
                    if (cpu.changeLimitValue < 20) {
                        /** @type {number} */
                        cpu.changeLimitValue = 19;
                    }
                },
                this.resetChangeLimit(),
                this.isValidChange = function() {
                    if (pair.ptr) {
                        return true;
                    }
                    var credits = cpu.getChargeAmount();
                    return credits > self.Me.credits
                        ? false
                        : cpu.changeLimitValue != self.Me.cpu;
                },
                this.getChargeAmount = function() {
                    var width = cpu.changeLimitValue;
                    if (20 > width) {
                        /** @type {number} */
                        width = 0;
                    }
                    var countHidden = self.Me.lastChargeTime || S.now();
                    /** @type {number} */
                    var max = 864E5;
                    /** @type {number} */
                    var count = S.now() - countHidden;
                    if (count > max) {
                        /** @type {number} */
                        count = max;
                    }
                    /** @type {number} */
                    var df = (max - count) / max * (width - self.Me.cpu) + count / max * width;
                    return 0 > df && df++,
                    Math.round(df);
                },
                this.save = function() {
                    return Date.now() < details.launchTime
                        ? (o.alert("", "The game is not launched yet. Please try again on August 12"), $q.when())
                        : $http.post("user/cpu-limit", {cpu: cpu.changeLimitValue}).then(function() {
                            return self.check();
                        }).then(function() {
                            return cpu.resetChangeLimit();
                        });
                },
                void(this.getNextChargeDate = function() {
                    return new Date(self.Me.lastChargeTime + 864E5);
                }));
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_early_45_preview_45_request_47_early_45_preview_45_request__ = function() {
    var module = angular.module("app.profile.early-preview-request", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/early-preview-request", "top.early-preview-request").within("top").segment("early-preview-request", {
                templateUrl: "components/profile/early-preview-request/early-preview-request.html?bust=1479290327467",
                controller: "Top.EarlyPreviewRequest as EarlyPreviewRequest"
            });
        }
    ]),
    module.controller("Top.EarlyPreviewRequest", [
        "Api",
        function($http) {
            var $scope = this;
            this.data = {
                email: "",
                name: "",
                birthDate: {
                    day: "",
                    month: "",
                    year: ""
                },
                qualify: void 0
            };
            /**
                 * @return {?}
                 */
            this.submit = function() {
                return $http.post("user/request-early-preview", $scope.data).then(function() {
                    /** @type {boolean} */
                    $scope.ok = true;
                });
            };
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_messages_47_index_47_index__ = function() {
    var module = angular.module("app.profile.messages.index", []);
    return module.config([
        "$routeSegmentProvider",
        function($scope) {
            $scope.when("/messages", "top.messages-index").within("top").segment("messages-index", {
                templateUrl: "components/profile/messages/index/index.html?bust=1479290327467",
                controller: "Top.MessagesIndex as MessagesIndex",
                resolve: {
                    data: ngInject([
                        "MessagesIndexLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("MessagesIndexLoader", [
        "Loader",
        "$routeParams",
        "Api",
        "$q",
        function($provide, dataAndEvents, $templateCache, deepDataAndEvents) {
            return $provide.factory(function() {
                return {index: $templateCache.get("user/messages/index")};
            });
        }
    ]),
    module.controller("Top.MessagesIndex", [
        "$scope",
        "data",
        "Auth",
        "Api",
        "Socket",
        "$location",
        "$routeSegment",
        "MessagesIndexLoader",
        "TopLoader",
        function(next_scope, message, opts, dataAndEvents, next_callback, $location, $http, exports, UserModel) {
            opts.required();
            UserModel.load();
            /** @type {Object} */
            this.data = message;
            /**
                 * @param {Object} data
                 * @return {?}
                 */
            this.goToRespondent = function(data) {
                return $location.url($http.getSegmentUrl("top.messages-respondent", {
                    username: message.index.users[data._id].username
                }));
            };
            next_callback.bindEventToScope(next_scope, "user:" + opts.Me._id + "/newMessage", function() {
                exports.load();
            });
        }
    ]),
    module.controller("Top.MessagesIndex.Message", [
        "$scope",
        "Auth",
        "Api",
        "Socket",
        function($scope, opts, dataAndEvents, _) {
            var element;
            $scope.$watch(function() {
                return "out" == $scope.item.message.type && $scope.item.message.unread;
            }, function(dataAndEvents) {
                if (dataAndEvents) {
                    element = _.bindEventToScope($scope, "user:" + opts.Me._id + "/message:" + $scope.item._id, function(m2) {
                        if (m2.message._id == $scope.item.message._id) {
                            $scope.item.message.unread = m2.message.unread;
                        }
                    });
                } else {
                    if (element) {
                        element.remove();
                        /** @type {null} */
                        element = null;
                    }
                }
            });
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_messages_47_respondent_47_respondent__ = function() {
    var module = angular.module("app.profile.messages.respondent", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/messages/:username", "top.messages-respondent").within("top").segment("messages-respondent", {
                templateUrl: "components/profile/messages/respondent/respondent.html?bust=1479290327467",
                controller: "Top.MessagesRespondent as MessagesRespondent",
                dependencies: ["username"],
                resolve: {
                    data: ngInject([
                        "MessagesRespondentLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("MessagesRespondentLoader", [
        "Loader",
        "$routeParams",
        "Api",
        "$q",
        function($provide, user, $http, dataAndEvents) {
            return $provide.factory(function() {
                var promise = $http.get("user/find", {username: user.username}).then(function(cred2) {
                    return cred2.user;
                });
                return {
                    user: promise,
                    messages: promise.then(function(post2) {
                        return $http.get("user/messages/list", {respondent: post2._id});
                    }).then(function(result) {
                        return result.messages;
                    })
                };
            });
        }
    ]),
    module.controller("Top.MessagesRespondent", [
        "$scope",
        "data",
        "Auth",
        "Api",
        "Socket",
        function(next_scope, args, opts, $http, next_callback) {
            var $scope = this;
            opts.required();
            this.user = args.user;
            this.messages = args.messages;
            /** @type {string} */
            this.messageText = "";
            /**
                 * @return {?}
                 */
            this.sendMessage = function() {
                return $scope.messageText
                    ? $http.post("user/messages/send", {
                        respondent: $scope.user._id,
                        text: $scope.messageText
                    }).then(function() {
                        return $scope.messageText = "";
                    })
                    : void 0;
            };
            next_callback.bindEventToScope(next_scope, "user:" + opts.Me._id + "/message:" + this.user._id, function(config) {
                var deep = _.find($scope.messages, {_id: config.message._id});
                if (deep) {
                    _.extend(deep, config.message);
                } else {
                    $scope.messages.push(config.message);
                    setTimeout(function() {
                        return Prism.highlightAll();
                    }, 0);
                }
            });
            setTimeout(function() {
                return Prism.highlightAll();
            }, 0);
        }
    ]),
    module.controller("Top.MessagesRespondent.Message", [
        "$scope",
        "Socket",
        "Api",
        "$timeout",
        "LocalStorage",
        function($scope, dataAndEvents, $http, result, $templateCache) {
            if (!$templateCache.get("noReadingMessages") && ($scope.message.unread && "in" == $scope.message.type)) {
                var e = result(500).then(function() {
                    $scope.Top.data.unreadMessages--;
                    $http.post("user/messages/mark-read", {id: $scope.message._id});
                });
                $scope.$on("$destroy", result.cancel(e));
            }
        }
    ]), {};
}();
var $__app_95_components_47_profile_47_profile__ = function() {
    var module = angular.module("app.profile", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/profile/:username", "top.profile").within("top").segment("profile", {
                templateUrl: "components/profile/profile.html?bust=1479290327467",
                controller: "Top.Profile as Profile",
                dependencies: ["username"],
                resolve: {
                    data: ngInject([
                        "ProfileLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                },
                resolveFailed: {
                    templateUrl: "components/profile/profile-not-found.html?bust=1479290327467"
                }
            });
        }
    ]),
    module.factory("ProfileLoader", [
        "Loader",
        "$routeParams",
        "Api",
        "$q",
        function($provide, user, $http, $q) {
            return $provide.factory(function(dataAndEvents) {
                var promise = $http.get("user/find", {username: user.username}).then(function(cred2) {
                    return cred2.user;
                });
                return {
                    user: promise,
                    seasons: $http.get("leaderboard/seasons").then(function(r) {
                        return r.seasons;
                    }),
                    leaderboard: $q.all({
                        world: $http.get("leaderboard/find", {
                            username: user.username,
                            mode: "world"
                        }).then(function(cl) {
                            return cl.list;
                        }),
                        power: $http.get("leaderboard/find", {
                            username: user.username,
                            mode: "power"
                        }).then(function(cl) {
                            return cl.list;
                        })
                    }),
                    stats: promise.then(function(b) {
                        return $http.get("user/stats", {
                            id: b._id,
                            interval: 0 | dataAndEvents || 1440
                        });
                    }).then(function(a) {
                        return a.stats;
                    }),
                    rooms: promise.then(function(b) {
                        return $http.get("user/rooms", {id: b._id});
                    }).then(function(response) {
                        return response.rooms;
                    })
                };
            });
        }
    ]),
    module.controller("Top.Profile", [
        "data",
        "Constants",
        "ProfileLoader",
        "Api",
        function(data, dataAndEvents, provider, service) {
            var user = this;
            this.user = data.user;
            this.leaderboard = {};
            _.forEach(data.leaderboard, function(dataAndEvents, ii) {
                return user.leaderboard[ii] = _.indexBy(data.leaderboard[ii], "season");
            });
            this.seasons = _.indexBy(data.seasons, "_id");
            this.currentSeason = data.seasons[0]._id;
            this.prevSeason = data.seasons[1]._id;
            /** @type {Object} */
            this.data = data;
            /** @type {number} */
            this.statInterval = 1440;
            /** @type {string} */
            this.mapUrl = service.options.official
                ? "https://d3os7yery2usni.cloudfront.net/map3/"
                : "http://" + service.options.host + ":" + service.options.port + "/assets/map/";
            this.allSeasons = _.filter(data.seasons, function(item) {
                return item._id != user.currentSeason;
            });
            /**
                 * @return {?}
                 */
            this.getGcl = function() {
                return Math.floor(Math.pow((user.user.gcl || 0) / dataAndEvents.GCL_MULTIPLY, 1 / dataAndEvents.GCL_POW)) + 1;
            };
            _.forEach(this.leaderboard, function(other) {
                _.forEach(other, function(b) {
                    if (b) {
                        /** @type {number} */
                        b.rankPage = Math.floor(b.rank / 10) + 1;
                    }
                });
            });
            /**
                 * @return {?}
                 */
            this.statIntervalChange = function() {
                return provider.load(user.statInterval);
            };
        }
    ]), {};
}();
var $__app_95_components_47_timeline_45_stats_47_timeline_45_stats__ = function() {
    var module = angular.module("app.timeline-stats", []);
    return module.config([
        "$routeSegmentProvider",
        function($q) {
            $q.when("/timeline-stats", "top.timeline-stats").within("top").segment("timeline-stats", {
                templateUrl: "components/timeline-stats/timeline-stats.html?bust=1479290327467",
                controller: "Top.TimelineStats as TimelineStats",
                resolve: {
                    data: ngInject([
                        "Api",
                        function($templateCache) {
                            return $templateCache.get("adm/timeline-stats").then(function(a) {
                                return a.stats;
                            });
                        }
                    ])
                }
            });
        }
    ]),
    module.controller("Top.TimelineStats", [
        "$scope",
        "Api",
        "data",
        "$timeout",
        function(dataAndEvents, deepDataAndEvents, data, $sanitize) {
            /** @type {Array} */
            this.data = data;
            $sanitize(function() {
                /**
                     * @return {undefined}
                     */
                function draw() {
                    /** @type {(HTMLElement|null)} */
                    var name = document.getElementById("timeline");
                    var object = new google.visualization.Timeline(name);
                    var self = new google.visualization.DataTable;
                    self.addColumn({type: "string", id: "type"});
                    self.addColumn({type: "string", id: "name"});
                    self.addColumn({type: "date", id: "Start"});
                    self.addColumn({type: "date", id: "End"});
                    data.forEach(function(payload) {
                        /** @type {*} */
                        var peer = JSON.parse(payload);
                        self.addRow([
                            peer.type,
                            peer.name,
                            new Date(peer.start),
                            new Date(peer.end)
                        ]);
                    });
                    object.draw(self, {backgroundColor: "#ffd"});
                }
                google.load("visualization", "1", {
                    packages: ["timeline"],
                    /** @type {function (): undefined} */
                    callback: draw
                });
            }, 1E3);
        }
    ]), {};
}();
var $__app_95_components_47_top_47_top__ = function() {
    var module = angular.module("app.top", []);
    return module.config([
        "$routeSegmentProvider",
        function(query) {
            query.when("/sim", "top").segment("top", {
                templateUrl: "components/top/top.html?bust=1479290327467",
                controller: "Top as Top",
                resolve: {
                    data: ngInject([
                        "TopLoader",
                        function(exports) {
                            return exports.load();
                        }
                    ])
                }
            });
        }
    ]),
    module.factory("TopLoader", [
        "Loader",
        "$q",
        "Api",
        "Auth",
        function($provide, $q, $templateCache, dataAndEvents) {
            return $provide.factory(function() {
                return {
                    unreadMessages: dataAndEvents.Me
                        ? $templateCache.get("user/messages/unread-count").then(function(collection) {
                            return collection.count;
                        })
                        : $q.when(0)
                };
            });
        }
    ]),
    module.controller("Top", [
        "$scope",
        "data",
        "TopLoader",
        "Login",
        "Auth",
        "$window",
        "Socket",
        "$timeout",
        "WorldRespawnChecker",
        "$routeSegment",
        "$mdSidenav",
        "NwLocalFileSync",
        "CodeBranches",
        "Loader",
        "$q",
        "MemoryStorage",
        "Dialogs",
        function(child, data, deepDataAndEvents, dataAndEvents, $scope, wnd, paragraph, item, speaker, unused, $, app, jQuery, self, $q, $templateCache, ignoreMethodDoesntExist) {
            var evt = this;
            if (this.LoginSvc = dataAndEvents, this.cpuUsed = 0, this.memoryUsed = 0, this.data = data, paragraph.bindConnect(child), this.toggleMainNav = function() {
                $("main").toggle();
            },
            this.signOut = function() {
                $scope.signOut();
                wnd.location.reload();
            },
            this.respawn = function() {
                return speaker.respawn();
            },
            this.getPromoDaysLeft = function() {
                return Math.floor((($scope.Me.promoPeriodUntil || 0) - Date.now()) / 3600 / 24 / 1E3);
            },
            $scope.Me) {
                var reason;
                paragraph.bindEventToScope(child, "user:" + $scope.Me._id + "/cpu", function(result) {
                    if (reason) {
                        item.cancel(reason);
                    }
                    evt.cpuUsed = result.cpu;
                    evt.memoryUsed = result.memory;
                    reason = item(function() {
                        /** @type {number} */
                        evt.cpuUsed = 0;
                    }, 1E4);
                });
                paragraph.bindEventToScope(child, "user:" + $scope.Me._id + "/newMessage", function(dataAndEvents) {
                    evt.data.unreadMessages++;
                    if ("top.messages-respondent" != unused.name) {
                        child.$broadcast("newUnreadMail");
                    }
                });
            }
            if ($templateCache.get("users.code.activeSim") || $templateCache.put("users.code.activeSim", [
                {
                    _id: "0",
                    modules: {
                        main: "module.exports.loop = function () {\n\t// Your code goes here\n}"
                    }
                }, {
                    _id: "1",
                    modules: {
                        main: "module.exports.loop = function () {\n\t// Your code goes here\n}"
                    }
                }
            ]), $templateCache.get("users.code.activeWorld") || $templateCache.put("users.code.activeWorld", [
                {
                    _id: "0",
                    modules: {
                        main: "module.exports.loop = function () {\n\t// Your code goes here\n}"
                    }
                }, {
                    _id: "1",
                    modules: {
                        main: "module.exports.loop = function () {\n\t// Your code goes here\n}"
                    }
                }
            ]), window.nw) {
                /**
                     * @return {?}
                     */
                var next = function() {
                    return jQuery.init("activeSim").then(function() {
                        return jQuery.loadBranches(true);
                    });
                };
                /**
                     * @param {?} array
                     * @return {?}
                     */
                var all = function(array) {
                    return jQuery.loadBranches().then(function(reversed) {
                        return _.reduce(reversed, function(defer, value) {
                            return defer.then(function() {
                                return jQuery.deleteBranch(value);
                            });
                        }, $q.when());
                    }).then(function() {
                        return _.reduce(array, function(defer, deepDataAndEvents, elements) {
                            return defer.then(function(expectedNumberOfNonCommentArgs) {
                                return jQuery.submitCode(elements, deepDataAndEvents, true)["catch"](function(r) {
                                    return "branch does not exist" == r
                                        ? jQuery.cloneBranch(void 0, elements, deepDataAndEvents)
                                        : $q.reject(r);
                                }).then(function(optgroup) {
                                    return Math.max(optgroup, expectedNumberOfNonCommentArgs);
                                });
                            });
                        }, $q.when(0));
                    });
                };
                app.init().then(function() {
                    return app.sync(next, all)["catch"](function() {
                        return true;
                    });
                }).then(function() {
                    app.startSync(child, {
                        /**
                             * @param {string} resolvedPath
                             * @param {string} deepDataAndEvents
                             * @return {undefined}
                             */
                        branchCreated: function(resolvedPath, deepDataAndEvents) {
                            self.loading(jQuery.cloneBranch(void 0, resolvedPath, deepDataAndEvents));
                        },
                        /**
                             * @param {?} value
                             * @return {undefined}
                             */
                        branchRemoved: function(value) {
                            self.loading(jQuery.deleteBranch(value));
                        },
                        /**
                             * @param {?} attributes
                             * @param {Object} dataAndEvents
                             * @return {undefined}
                             */
                        branchChanged: function(attributes, dataAndEvents) {
                            self.loading(jQuery.submitCode(attributes, dataAndEvents, true));
                        }
                    });
                });
            }
        }
    ]),
    module.directive("appUnreadMailIcon", [
        "$animate",
        "$timeout",
        function(result, $sanitize) {
            return function($rootScope, input) {
                $rootScope.$on("newUnreadMail", function() {
                    $sanitize(function() {
                        result.addClass(input, "new-mail").then(function() {
                            input.removeClass("new-mail");
                        });
                    }, 10);
                });
            };
        }
    ]),
    module.directive("appLogoBlinking", [
        "Connection",
        function(_) {
            return {
                /**
                     * @param {Object} $scope
                     * @param {Object} elm
                     * @param {?} tabCtrl
                     * @return {undefined}
                     */
                link: function($scope, elm, tabCtrl) {
                    $scope.$on("routeSegmentChange", function() {
                        elm.removeClass("logo-blinking--blink");
                    });
                    _.onRoomUpdate($scope, function() {
                        if (elm.hasClass("logo-blinking--blink")) {
                            elm.removeClass("logo-blinking--blink");
                        } else {
                            elm.addClass("logo-blinking--blink");
                        }
                    });
                }
            };
        }
    ]),
    module.directive("appClickCloseSidenav", [
        "$mdSidenav",
        function($resource) {
            return {
                /**
                     * @param {?} scope
                     * @param {HTMLElement} elm
                     * @param {?} attrs
                     * @return {undefined}
                     */
                link: function(scope, elm, attrs) {
                    elm.click(function() {
                        return scope.$apply(function() {
                            $resource(attrs.appClickCloseSidenav).close();
                        });
                    });
                }
            };
        }
    ]), {};
}();
var $__app_95_config__ = function() {
    var module = angular.module("app.config", []);
    return module.config([
        "ApiProvider",
        "SocketProvider",
        function(ApiProvider, item) {
            /** @type {string} */
            ApiProvider.options.apiUrl = "https://screeps.com/api/";
            /** @type {string} */
            item.options.websocketUrl = "https://screeps.com/socket";
            if ("1" != localStorage.getItem("debug")) {
                /** @type {boolean} */
                item.options.gzip = true;
            }
        }
    ]), {};
}();
var $__app_95_utils_47_api__ = function() {
    var profile = angular.module("app.api", []);
    return profile.provider("Api", [
        "$httpProvider",
        function(dataAndEvents) {
            var options = this.options = {
                apiUrl: "",
                official: true
            };
            this.$get = ngInject([
                "$injector",
                "$q",
                function($injector, $) {
                    var config;
                    /**
                     * @param {?} status
                     * @return {?}
                     */
                    var reject = function(status) {
                        return $.reject(status);
                    };
                    return config = {
                        options: options,
                        /**
                         * @param {string} name
                         * @param {?} opt_attributes
                         * @return {?}
                         */
                        post: function(name, opt_attributes) {
                            var $http = $injector.get("$http");
                            return $http.post(options.apiUrl + name, opt_attributes, {withCredentials: true}).then(function(data) {
                                return 200 != data.status
                                    ? $.reject(data.statusText)
                                    : data.data.ok
                                        ? data.data
                                        : $.reject(data.data.error);
                            }, reject);
                        },
                        /**
                         * @param {string} key
                         * @param {Object} expectedHashCode
                         * @return {?}
                         */
                        get: function(key, expectedHashCode) {
                            var $http = $injector.get("$http");
                            return $http({
                                method: "GET",
                                url: options.apiUrl + key,
                                params: expectedHashCode,
                                withCredentials: true
                            }).then(function(results) {
                                return results.data.ok
                                    ? results.data
                                    : $.reject(results.data.error);
                            }, reject);
                        }
                    };
                }
            ]);
        }
    ]), {};
}();
var $__app_95_utils_47_auth__ = function() {
    var profile = angular.module("app.auth", []);
    return profile.provider("Auth", [
        "$httpProvider",
        function($httpProvider) {
            var $scope = {};
            $httpProvider.interceptors.push(ngInject([
                "LocalStorage",
                "Login",
                "$rootScope",
                "$injector",
                "$q",
                "Api",
                function(client, a, dataAndEvents, $injector, $q, err) {
                    return {
                        /**
                         * @param {Object} options
                         * @return {?}
                         */
                        request: function(options) {
                            var auth = client.get("auth", null);
                            return auth && (options.headers["X-Token"] = auth, options.headers["X-Username"] = auth),
                            client.get("ignoreServerDown", 0) && (options.headers["X-Ignore-Server-Down"] = 1),
                            !err.options.official && (err.options.password && (options.headers["X-Server-Password"] = err.options.password)),
                            options;
                        },
                        /**
                         * @param {Object} req
                         * @return {?}
                         */
                        response: function(req) {
                            var tag = req.headers("X-Token");
                            return tag && client.put("auth", tag),
                            req;
                        },
                        /**
                         * @param {Object} response
                         * @return {?}
                         */
                        responseError: function(response) {
                            var tag = response.headers("X-Token");
                            if (tag && client.put("auth", tag), 401 == response.status && !/signin/.test(response.config.url)) {
                                /** @type {null} */
                                $scope.Me = null;
                                client.put("auth", null);
                                var promise = a.show();
                                if (promise) {
                                    return promise.then(function() {
                                        return $injector.get("$http")(response.config);
                                    });
                                }
                            }
                            return $q.reject(response);
                        }
                    };
                }
            ]));
            this.$get = ngInject([
                "$rootScope",
                "LocalStorage",
                "$q",
                "Api",
                "Login",
                "$window",
                "$location",
                "Socket",
                "Loader",
                "Constants",
                "Dialogs",
                "$timeout",
                function($rootScope, app, done, self, ignoreMethodDoesntExist, $window, $location, $provide, deepDataAndEvents, dataAndEvents, o, $transition) {
                    var element;
                    var passes;
                    return $scope.useNativeAuth = false,
                    $scope.check = function() {
                        var names;
                        var name = app.get("auth", null);
                        return names = name
                            ? self.get("auth/me").then(function(user) {
                                /** @type {Object} */
                                $scope.Me = user;
                                /**
                                     * @return {?}
                                     */
                                $scope.Me.getGcl = function() {
                                    return Math.floor(Math.pow(($scope.Me.gcl || 0) / dataAndEvents.GCL_MULTIPLY, 1 / dataAndEvents.GCL_POW)) + 1;
                                };
                                /**
                                     * @return {?}
                                     */
                                $scope.Me.getCpu = function() {
                                    return Math.min(10 * ($scope.Me.getGcl() - 1) + 30, 300);
                                };
                                /**
                                     * @return {?}
                                     */
                                $scope.Me.isSteamOwner = function() {
                                    return $scope.Me.steam && ($scope.Me.steam.ownership && -1 !== $scope.Me.steam.ownership.indexOf(464350));
                                };
                                /**
                                     * @return {?}
                                     */
                                $scope.Me.isSteamSubscriber = function() {
                                    return $scope.Me.steam && ($scope.Me.steam.ownership && -1 !== $scope.Me.steam.ownership.indexOf(491760));
                                };
                                var firstVisit = app.get("firstVisit", false);
                                if (firstVisit !== false) {
                                    if (1422783777E3 > firstVisit) {
                                        if (app.get("mixpanelAlias", false) === false) {
                                            mixpanel.alias(user.email);
                                            app.put("mixpanelAlias", 1);
                                        }
                                    }
                                }
                                mixpanel.identify(user.email);
                                mixpanel.people.set({$email: user.email, userId: user._id});
                                mixpanel.register({email: user.email, userId: user._id});
                                if (element) {
                                    element.remove();
                                }
                                element = $provide.bindEventToScope($rootScope, "user:" + user._id + "/money", function(dataAndEvents) {
                                    $scope.Me.money = dataAndEvents;
                                });
                            })["catch"](function() {
                                /** @type {null} */
                                $scope.Me = null;
                                app.put("auth", null);
                                if (element) {
                                    element.remove();
                                }
                            })
                            : done.reject(),
                        window.nw,
                        names;
                    },
                    $scope.signIn = function(email, password) {
                        /**
                             * @param {?} var_args
                             * @return {?}
                             */
                        function create(var_args) {
                            return self.post("auth/signin", {
                                email: email,
                                password: password,
                                steamTicket: var_args
                            }).then(function(user) {
                                return app.put("auth", user.token),
                                $scope.check();
                            }).then(function(dataAndEvents) {
                                return mixpanel.track("Sign in", {email: $scope.Me.email}),
                                ga("send", "event", "Sign in", "Sign in"),
                                dataAndEvents;
                            });
                        }

                        return create();
                    },
                    $scope.signInGithub = function(dataAndEvents) {
                        return done(function(done, reject) {
                            /** @type {string} */
                            var modalOptions = self.options.apiUrl + "auth/github?";
                            if ($scope.Me) {
                                var auth = app.get("auth");
                                modalOptions += "token=" + auth + "&";
                            }
                            if (dataAndEvents) {
                                modalOptions += "repoScope=1";
                            }
                            /** @type {function (MessageEvent): ?} */
                            var completed = ($window.open(modalOptions), function(event) {
                                $window.removeEventListener("message", completed);
                                /** @type {*} */
                                var response = JSON.parse(event.data);
                                return response.username || (mixpanel.alias(response.email), mixpanel.track("Register GitHub"), ga("send", "event", "Register", "Register Success", "Register GitHub")),
                                mixpanel.track("Sign in GitHub", {email: response.email}),
                                ga("send", "event", "Sign in", "Sign in GitHub"),
                                $scope.set(response.token).then(done, reject);
                            });
                            $window.addEventListener("message", completed);
                        });
                    },
                    $scope.signInSteam = function() {
                        return done(function(done, reject) {
                            /** @type {string} */
                            var modalOptions = self.options.apiUrl + "auth/steam?";
                            if ($scope.Me) {
                                var auth = app.get("auth");
                                modalOptions += "token=" + auth + "&";
                            }
                            /** @type {function (MessageEvent): ?} */
                            var completed = ($window.open(modalOptions), function(event) {
                                $window.removeEventListener("message", completed);
                                /** @type {*} */
                                var attrs = JSON.parse(event.data);
                                return attrs.username || (mixpanel.alias(attrs.email), mixpanel.track("Register Steam"), ga("send", "event", "Register", "Register Success", "Register Steam")),
                                mixpanel.track("Sign in Steam", {
                                    email: attrs.email,
                                    steamid: attrs.steamid
                                }),
                                ga("send", "event", "Sign in", "Sign in Steam"),
                                $scope.set(attrs.token).then(done, reject);
                            });
                            $window.addEventListener("message", completed);
                        });
                    },
                    $scope.signInSteamByTicket = function() {

                        var crypto = require('crypto');
                        var os = require('os');

                        return self.post("auth/steam-ticket", {
                            steamid: crypto.createHash('md5').update(self.options.password).digest('hex')
                        }).then(function(attrs) {

                            return $scope.set(attrs.token);
                            //return data.handle;
                        });

                    },
                    $scope.signOut = function() {
                        /** @type {null} */
                        $scope.Me = null;
                        app.put("auth", null);
                    },
                    $scope.set = function(value) {
                        return app.put("auth", value),
                        $scope.check();
                    },
                    $scope.required = function() {
                        return $scope.Me
                            ? $scope.Me.username && ($scope.Me.email || ($scope.Me.steam || $scope.Me.github))
                                ? true
                                : ($location.url("/register"), false)
                            : (window.nw
                                ? $scope.signInSteamByTicket().then(function() {
                                    return $window.location.reload();
                                })
                                : $location.url("/register"), false);
                    },
                    $rootScope.$watch(function() {
                        return $scope.Me && $scope.Me._id;
                    }, function(newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $provide.reconnect();
                        }
                    }),
                    window.nw || deepDataAndEvents.registerPre($scope.check()["catch"](function() {
                        return null;
                    })),
                    $scope;
                }
            ]);
        }
    ]), {};
}();
var $__app_95_utils_47_code_45_branches__ = function() {
    var module = angular.module("app.code-branches", []);
    return module.factory("CodeBranches", [
        "Auth",
        "Api",
        "LocalStorage",
        "$q",
        "MemoryStorage",
        "Socket",
        "$timeout",
        function(opts, server, data_user, $q, object, fn, $transition) {
            var ctx;
            /** @type {Array} */
            var tests = [];
            /** @type {Array} */
            var matched = [];
            /** @type {number} */
            var hash = Math.floor(1E6 * Math.random());
            var buf = (ctx = {}, Object.defineProperty(ctx, "userId", {
                value: "0",
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "init", {
                /**
                 * @param {string} name
                 * @return {?}
                 */
                value: function(name) {
                    var data = this;
                    return this.loadBranches().then(function(key) {
                        if (!_.any(key, {branch: "default"})) {
                            var reversed = object.get("users.code." + name);
                            var APP_META = _.find(reversed, function(player) {
                                return player._id == data.userId;
                            });
                            key.push({
                                branch: "default",
                                activeWorld: true,
                                activeSim: true,
                                modules: APP_META.modules,
                                userId: data.userId,
                                timestamp: Date.now()
                            });
                            data_user.put("branches", key);
                        }
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "loadBranches", {
                /**
                 * @return {?}
                 */
                value: function() {
                    var rvar = data_user.get("branches", []);
                    return $q.when(_.filter(rvar, {userId: this.userId}));
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "loadModulesByActiveName", {
                /**
                 * @param {string} name
                 * @return {?}
                 */
                value: function(name) {
                    var data = this;
                    return this.loadBranches().then(function(data) {
                        var ctx;
                        var newState = _.find(data, (ctx = {}, Object.defineProperty(ctx, name, {
                            value: true,
                            configurable: true,
                            enumerable: true,
                            writable: true
                        }), ctx));
                        if (newState) {
                            return newState;
                        }
                        var reversed = object.get("users.code." + name);
                        var APP_META = _.find(reversed, function(player) {
                            return player._id == data.userId;
                        });
                        return {branch: "default", modules: APP_META.modules};
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "setActiveBranch", {
                /**
                 * @param {string} name
                 * @param {?} expectedNumberOfNonCommentArgs
                 * @return {?}
                 */
                value: function(name, expectedNumberOfNonCommentArgs) {
                    return this.loadBranches().then(function(key) {
                        key.forEach(function(tree) {
                            return tree[name] = tree.branch == expectedNumberOfNonCommentArgs;
                        });
                        data_user.put("branches", key);
                        data_user.put("branches." + name, expectedNumberOfNonCommentArgs);
                        $transition(10).then(function() {
                            return tests.forEach(function(e) {
                                return e.activeName == name && e.fn(expectedNumberOfNonCommentArgs);
                            });
                        });
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "deleteBranch", {
                /**
                 * @param {string} name
                 * @return {?}
                 */
                value: function(name) {
                    return this.loadBranches().then(function(key) {
                        var camelKey = _.find(key, {branch: name});
                        return !camelKey || (camelKey.activeWorld || (camelKey.activeSim || _.remove(key, {branch: name}))),
                        data_user.put("branches", key),
                        Date.now();
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "cloneBranch", {
                /**
                 * @param {string} name
                 * @param {?} expectedNumberOfNonCommentArgs
                 * @param {Object} modules
                 * @return {?}
                 */
                value: function(name, expectedNumberOfNonCommentArgs, modules) {
                    var post = this;
                    return this.loadBranches().then(function(key) {
                        _.remove(key, {branch: expectedNumberOfNonCommentArgs});
                        var data = name
                            ? _.clone(_.find(key, {branch: name}))
                            : {
                                modules: modules || {
                                    main: ""
                                },
                                userId: post.userId
                            };
                        return data.branch = expectedNumberOfNonCommentArgs,
                        data.activeWorld = false,
                        data.activeSim = false,
                        data.timestamp = Date.now(),
                        key.push(data),
                        data_user.put("branches", key),
                        data.timestamp;
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "submitCode", {
                /**
                 * @param {string} name
                 * @param {?} expectedNumberOfNonCommentArgs
                 * @param {(Node|string)} thisValue
                 * @return {?}
                 */
                value: function(name, expectedNumberOfNonCommentArgs, thisValue) {
                    return this.loadBranches().then(function(key) {
                        var child = _.find(key, {branch: name});
                        return child.modules = expectedNumberOfNonCommentArgs,
                        child.timestamp = Date.now(),
                        data_user.put("branches", key),
                        thisValue && matched.forEach(function($sanitize) {
                            return $sanitize({branch: name, modules: expectedNumberOfNonCommentArgs, timestamp: Date.now()});
                        }),
                        child.timestamp;
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "registerActiveBranchCallback", {
                /**
                 * @param {string} name
                 * @param {?} expectedNumberOfNonCommentArgs
                 * @param {(Function|string)} fn
                 * @return {undefined}
                 */
                value: function(name, expectedNumberOfNonCommentArgs, fn) {
                    var source = {
                        activeName: expectedNumberOfNonCommentArgs,
                        fn: fn
                    };
                    tests.push(source);
                    name.$on("$destroy", function() {
                        return _.pull(tests, source);
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), Object.defineProperty(ctx, "registerCodeCallback", {
                /**
                 * @param {string} name
                 * @param {?} expectedNumberOfNonCommentArgs
                 * @return {undefined}
                 */
                value: function(name, expectedNumberOfNonCommentArgs) {
                    matched.push(expectedNumberOfNonCommentArgs);
                    name.$on("$destroy", function() {
                        return _.pull(matched, expectedNumberOfNonCommentArgs);
                    });
                },
                configurable: true,
                enumerable: true,
                writable: true
            }), ctx);
            var methods = {
                /**
                 * @return {?}
                 */
                init: function() {
                    return $q.when();
                },
                /**
                 * @param {boolean} dataAndEvents
                 * @return {?}
                 */
                loadBranches: function(dataAndEvents) {
                    return server.get("user/branches", {withCode: dataAndEvents}).then(function(cl) {
                        return cl.list;
                    });
                },
                /**
                 * @param {string} type
                 * @return {?}
                 */
                loadModulesByActiveName: function(type) {
                    return server.get("user/code", {
                        branch: "$" + type
                    });
                },
                /**
                 * @param {string} dataAndEvents
                 * @param {?} opt_scope
                 * @return {?}
                 */
                setActiveBranch: function(dataAndEvents, opt_scope) {
                    return server.post("user/set-active-branch", {
                        activeName: dataAndEvents,
                        branch: opt_scope
                    });
                },
                /**
                 * @param {?} putativeSpy
                 * @return {?}
                 */
                deleteBranch: function(putativeSpy) {
                    return server.post("user/delete-branch", {branch: putativeSpy}).then(function(p) {
                        return p.timestamp;
                    });
                },
                /**
                 * @param {?} opt_attributes
                 * @param {string} resolvedPath
                 * @param {string} deepDataAndEvents
                 * @return {?}
                 */
                cloneBranch: function(opt_attributes, resolvedPath, deepDataAndEvents) {
                    return server.post("user/clone-branch", {
                        branch: opt_attributes,
                        newName: resolvedPath,
                        defaultModules: deepDataAndEvents
                    }).then(function(p) {
                        return p.timestamp;
                    });
                },
                /**
                 * @param {?} opt_attributes
                 * @param {Object} deepDataAndEvents
                 * @return {?}
                 */
                submitCode: function(opt_attributes, deepDataAndEvents) {
                    return server.post("user/code", {
                        branch: opt_attributes,
                        modules: deepDataAndEvents,
                        _hash: hash
                    }).then(function(p) {
                        return p.timestamp;
                    });
                },
                /**
                 * @param {Object} scope
                 * @param {string} a
                 * @param {Function} forOwn
                 * @return {undefined}
                 */
                registerActiveBranchCallback: function(scope, a, forOwn) {
                    fn.bindEventToScope(scope, "user:" + opts.Me._id + "/set-active-branch", function(data) {
                        if (data.activeName == a) {
                            forOwn(data.branch);
                        }
                    });
                },
                /**
                 * @param {Object} scope
                 * @param {Function} $sanitize
                 * @return {undefined}
                 */
                registerCodeCallback: function(scope, $sanitize) {
                    fn.bindEventToScope(scope, "user:" + opts.Me._id + "/code", function(value) {
                        $sanitize(value, value.hash == hash);
                    });
                }
            };
            return opts.Me
                ? methods
                : buf;
        }
    ]), {};
}();
var $__app_95_utils_47_connection__ = function() {
    var app = angular.module("app.connection", []);
    /** @type {Array} */
    var Lucas = [
        "Jackson",
        "Aiden",
        "Liam",
        "Lucas",
        "Noah",
        "Mason",
        "Jayden",
        "Ethan",
        "Jacob",
        "Jack",
        "Caden",
        "Logan",
        "Benjamin",
        "Michael",
        "Caleb",
        "Ryan",
        "Alexander",
        "Elijah",
        "James",
        "William",
        "Oliver",
        "Connor",
        "Matthew",
        "Daniel",
        "Luke",
        "Brayden",
        "Jayce",
        "Henry",
        "Carter",
        "Dylan",
        "Gabriel",
        "Joshua",
        "Nicholas",
        "Isaac",
        "Owen",
        "Nathan",
        "Grayson",
        "Eli",
        "Landon",
        "Andrew",
        "Max",
        "Samuel",
        "Gavin",
        "Wyatt",
        "Christian",
        "Hunter",
        "Cameron",
        "Evan",
        "Charlie",
        "David",
        "Sebastian",
        "Joseph",
        "Dominic",
        "Anthony",
        "Colton",
        "John",
        "Tyler",
        "Zachary",
        "Thomas",
        "Julian",
        "Levi",
        "Adam",
        "Isaiah",
        "Alex",
        "Aaron",
        "Parker",
        "Cooper",
        "Miles",
        "Chase",
        "Muhammad",
        "Christopher",
        "Blake",
        "Austin",
        "Jordan",
        "Leo",
        "Jonathan",
        "Adrian",
        "Colin",
        "Hudson",
        "Ian",
        "Xavier",
        "Camden",
        "Tristan",
        "Carson",
        "Jason",
        "Nolan",
        "Riley",
        "Lincoln",
        "Brody",
        "Bentley",
        "Nathaniel",
        "Josiah",
        "Declan",
        "Jake",
        "Asher",
        "Jeremiah",
        "Cole",
        "Mateo",
        "Micah",
        "Elliot"
    ];
    /** @type {Array} */
    var _map = [
        "Sophia",
        "Emma",
        "Olivia",
        "Isabella",
        "Mia",
        "Ava",
        "Lily",
        "Zoe",
        "Emily",
        "Chloe",
        "Layla",
        "Madison",
        "Madelyn",
        "Abigail",
        "Aubrey",
        "Charlotte",
        "Amelia",
        "Ella",
        "Kaylee",
        "Avery",
        "Aaliyah",
        "Hailey",
        "Hannah",
        "Addison",
        "Riley",
        "Harper",
        "Aria",
        "Arianna",
        "Mackenzie",
        "Lila",
        "Evelyn",
        "Adalyn",
        "Grace",
        "Brooklyn",
        "Ellie",
        "Anna",
        "Kaitlyn",
        "Isabelle",
        "Sophie",
        "Scarlett",
        "Natalie",
        "Leah",
        "Sarah",
        "Nora",
        "Mila",
        "Elizabeth",
        "Lillian",
        "Kylie",
        "Audrey",
        "Lucy",
        "Maya",
        "Annabelle",
        "Makayla",
        "Gabriella",
        "Elena",
        "Victoria",
        "Claire",
        "Savannah",
        "Peyton",
        "Maria",
        "Alaina",
        "Kennedy",
        "Stella",
        "Liliana",
        "Allison",
        "Samantha",
        "Keira",
        "Alyssa",
        "Reagan",
        "Molly",
        "Alexandra",
        "Violet",
        "Charlie",
        "Julia",
        "Sadie",
        "Ruby",
        "Eva",
        "Alice",
        "Eliana",
        "Taylor",
        "Callie",
        "Penelope",
        "Camilla",
        "Bailey",
        "Kaelyn",
        "Alexis",
        "Kayla",
        "Katherine",
        "Sydney",
        "Lauren",
        "Jasmine",
        "London",
        "Bella",
        "Adeline",
        "Caroline",
        "Vivian",
        "Juliana",
        "Gianna",
        "Skyler",
        "Jordyn"
    ];
    /** @type {string} */
    var charArray = "0123456789abcdef";
    return app.factory("Connection", [
        "MemoryStorage",
        "$rootScope",
        "$q",
        "$routeParams",
        "$http",
        "$interval",
        "Dialogs",
        "Api",
        "$routeSegment",
        "Loader",
        "Socket",
        "Constants",
        "Auth",
        "$window",
        "StaticMaps",
        "$timeout",
        "$location",
        function(html, $rootScope, $, row, storage, queue, buffer, that, unused, appLoading, assert, $scope, opts, $window, FBTest, dataAndEvents, exports) {
            /**
             * @param {string} userId
             * @return {?}
             */
            function update(userId) {
                var val;
                var isFunction;
                var value = html.get("rooms.objects");
                /** @type {number} */
                var h = 0;
                do {
                    /** @type {Array} */
                    var map = Math.random() > 0.5
                        ? Lucas
                        : _map;
                    val = map[Math.floor(Math.random() * map.length)];
                    if (h > 3) {
                        val += map[Math.floor(Math.random() * map.length)];
                    }
                    h++;
                    isFunction = _.any(value, {
                        user: userId,
                        type: "creep",
                        name: val
                    });
                } while (isFunction);
                return val;
            }
            /**
             * @param {Object} target
             * @return {undefined}
             */
            function flatten(target) {
                var key;
                for (key in target) {
                    if (_.isArray(target[key])) {
                        var copy = {};
                        /** @type {number} */
                        var m = 0;
                        for (; m < target[key].length; m++) {
                            copy[m] = target[key][m];
                        }
                        target[key] = copy;
                    }
                }
            }
            /**
             * @param {?} key
             * @param {Object} map
             * @return {undefined}
             */
            function build(key, map) {
                var letter;
                for (letter in map) {
                    var value = map[letter];
                    var query = _.find(key, {_id: letter});
                    if (query) {
                        if (null !== value) {
                            flatten(query);
                            flatten(value);
                            query = _.merge(query, value);
                        } else {
                            _.remove(key, {_id: letter});
                        }
                    } else {
                        query = _.cloneDeep(value);
                        key.push(query);
                    }
                }
            }
            /**
             * @return {undefined}
             */
            function updateRange() {
                /** @type {number} */
                var j = parseInt(row.t);
                if (j == x + 1) {
                    build(name, self.ticks[j]);
                    /** @type {number} */
                    x = j;
                } else {
                    /** @type {Array} */
                    name = [];
                    /** @type {number} */
                    x = self.base - 1;
                    do {
                        x++;
                        build(name, self.ticks[x]);
                    } while (j > x);
                }
            }
            /**
             * @param {string} all
             * @return {?}
             */
            function replace(all) {
                return all.length
                    ? _.map(all.split("|"), function(pair) {
                        var attrList = pair.split("~");
                        return attrList[0] = attrList[0].replace(/\$VLINE\$/g, "|").replace(/\$TILDE\$/g, "~"),
                        attrList;
                    })
                    : [];
            }
            /**
             * @param {Array} results
             * @return {?}
             */
            function parse(results) {
                return results = results || [],
                _.map(results, function(pair) {
                    return pair[0] = pair[0].replace(/\|/g, "$VLINE$").replace(/~/g, "$TILDE$"),
                    pair.join("~");
                }).join("|");
            }
            /**
             * @param {?} key
             * @param {(Function|string)} content
             * @return {undefined}
             */
            function done(key, content) {
                var i = html.get("users.memory") || [];
                var data = _.find(i, {_id: key});
                if (!data) {
                    data = {
                        _id: key
                    };
                    i.push(data);
                }
                /** @type {string} */
                data.memory = JSON.stringify(content);
                html.put("users.memory", i);
            }
            /**
             * @param {?} id
             * @param {string} style
             * @return {?}
             */
            function callback(id, style) {
                var option = html.get("users.memory");
                var options = _.find(option, {_id: id});
                /** @type {*} */
                var resource = JSON.parse(options.memory);
                if (style) {
                    var pathConfig = style.split(/\./);
                    for (; pathConfig.length > 0;) {
                        resource = resource[pathConfig.shift()];
                    }
                }
                return resource;
            }
            /**
             * @param {?} id
             * @param {string} data
             * @param {?} v
             * @return {undefined}
             */
            function finish(id, data, v) {
                var text = html.get("users.memory");
                var options = _.find(text, {_id: id});
                /** @type {*} */
                var name = JSON.parse(options.memory);
                if (data) {
                    /** @type {*} */
                    var child = name;
                    var stack = data.split(/\./);
                    var k = stack.pop();
                    for (; stack.length > 0;) {
                        child = child[stack.shift()];
                    }
                    child[k] = v;
                } else {
                    name = v;
                }
                /** @type {string} */
                options.memory = JSON.stringify(name);
                html.put("users.memory", text);
            }
            var worker;
            var theWorker;
            var wrk;
            var result;
            var name;
            var self;
            var data;
            var x;
            var nDigit;
            var actual;
            var textInputID;
            var lastValue;
            var doneResults;
            var ms;
            var S;
            var ws = {};
            /** @type {Array} */
            var events = [];
            /** @type {Array} */
            var type = [];
            /** @type {number} */
            var camelKey = 1E3;
            var users = {
                3: {
                    username: "Source Keeper"
                },
                2: {
                    username: "Invader"
                }
            };
            var req = {
                timeoutTransactionId: null,
                timeoutInstance: null,
                modalInstance: null,
                /**
                 * @param {Node} funcToCall
                 * @param {?} ms
                 * @param {string} millis
                 * @return {undefined}
                 */
                setTimeout: function(funcToCall, ms, millis) {
                    var self = this;
                    /** @type {Node} */
                    this.timeoutTransactionId = funcToCall;
                    /** @type {number} */
                    this.timeoutInstance = setTimeout(function() {
                        return self.timeoutTransactionId != funcToCall
                            ? void millis.postMessage({transactionId: funcToCall, reject: true})
                            : (self.modalInstance = buffer.ask({title: "Not Responding", message: "Your script is not responding. Do you want to terminate it?", buttonLabel: "Terminate", buttonCancelLabel: "Wait"}), void self.modalInstance.result.then(function() {
                                millis.postMessage({transactionId: funcToCall});
                                /** @type {null} */
                                self.timeoutTransactionId = null;
                            })["catch"](function() {
                                self.setTimeout(funcToCall, ms, millis);
                            })["finally"](function() {
                                return self.modalInstance = null;
                            }));
                    }, ms);
                },
                /**
                 * @param {Node} id
                 * @return {undefined}
                 */
                clearTimeout: function(id) {
                    if (!id) {
                        id = this.timeoutTransactionId;
                    }
                    if (this.timeoutInstance) {
                        if (id == this.timeoutTransactionId) {
                            if (this.modalInstance) {
                                this.modalInstance.close();
                            }
                            clearTimeout(this.timeoutInstance);
                        }
                    }
                }
            };
            return $rootScope.$on("$locationChangeStart", function(types, s) {
                if (S) {
                    if (ms == s) {
                        return ms = null,
                        true;
                    }
                    types.preventDefault();
                    buffer.ask("", "Your script will be saved, but your simulation progress will be lost! Are you sure?").result.then(function() {
                        /** @type {boolean} */
                        S = false;
                        /** @type {string} */
                        ms = s;
                        /** @type {string} */
                        $window.location.href = s;
                    });
                }
            }),
            ws.allowChangeUrl = function(name) {
                return ms = window.location.origin + window.location.pathname + "#!" + name;
            },
            ws.onRoomUpdate = function($scope, fn) {
                /**
                     * @return {?}
                     */
                var remove = function() {
                    return _.remove(events, function(facetName) {
                        return facetName == fn;
                    });
                };
                return events.push(fn),
                $scope.$on("$destroy", remove),
                lastValue && fn(lastValue, doneResults),
                remove;
            },
            ws.setSimLostWarning = function($scope) {
                /** @type {boolean} */
                S = true;
                /**
                     * @return {?}
                     */
                $window.onbeforeunload = function() {
                    return "Your script will be saved, but your simulation progress will be lost! Are you sure?";
                };
                $scope.$on("$destroy", function() {
                    /** @type {boolean} */
                    S = false;
                    /** @type {null} */
                    $window.onbeforeunload = null;
                });
            },
            ws.onConsoleUpdate = function(mat) {
                return type.push(mat),
                function() {
                    return _.remove(type, function(resultMat) {
                        return resultMat == mat;
                    });
                };
            },
            ws.sendConsoleCommand = function(code, id) {
                if (textInputID) {
                    if (theWorker) {
                        theWorker.postMessage({consoleCommand: code, userId: id});
                    }
                } else {
                    appLoading.loading(that.post("user/console", {expression: code}));
                }
            },
            ws.reloadRoom = function(value, data, emitter, receiver, port) {
                /** @type {Array} */
                lastValue = value;
                if (!data) {
                    if (self) {
                        data = users;
                    }
                }
                /** @type {Object} */
                doneResults = data;
                if (textInputID) {
                    value = value || (html.get("rooms.objects") || []);
                    data = data || {
                        0: {
                            username: "Player 1"
                        },
                        1: {
                            username: "Player 2"
                        },
                        2: {
                            username: "Invader"
                        },
                        3: {
                            username: "Source Keeper"
                        }
                    };
                    emitter = emitter || html.get("gameinfo");
                    receiver = receiver || html.get("gametime");
                    if (opts.Me) {
                        data[opts.Me._id] = opts.Me;
                    }
                    port = port || html.get("rooms.flags");
                    events.forEach(function(register) {
                        return register(value, data, emitter, receiver, port);
                    });
                } else {
                    if (value) {
                        events.forEach(function(register) {
                            return register(value, data, emitter, receiver, port);
                        });
                    }
                }
            },
            ws.runWave = function() {
                var text = html.get("gameinfo") || {};
                /** @type {number} */
                text.timeToWave = 0;
                html.put("gameinfo", text);
            },
            ws.survivalEnabled = function(recurring) {
                var text = html.get("gameinfo") || {};
                /** @type {boolean} */
                text.survivalEnabled = recurring;
                html.put("gameinfo", text);
            },
            ws.setRunningLocal = function(recurring) {
                /** @type {boolean} */
                textInputID = recurring;
                /** @type {null} */
                lastValue = null;
                /** @type {null} */
                doneResults = null;
            },
            ws.setTickPeriod = function(dataAndEvents) {
                /** @type {number} */
                camelKey = dataAndEvents;
            },
            ws.initReplay = function(parent, pane) {
                if (self = parent, name = [], nDigit = 0, x = 0, self) {
                    if (self.ticks && self.ticks[row.t]) {
                        if (parent.base != 20 * Math.floor(parseInt(row.t) / 20)) {
                            return;
                        }
                        updateRange();
                        html.put("rooms.objects", name);
                        html.put("gameinfo", {mode: "world"});
                        _.forEach(parent.ticks, function(dataAndEvents, cDigit) {
                            if (parseInt(cDigit) > nDigit) {
                                /** @type {number} */
                                nDigit = parseInt(cDigit);
                            }
                        });
                        var i = html.get("gameinfo");
                        i.historyTimestamp = self.timestamp;
                        html.put("gametime", x);
                        ws.reloadRoom();
                    } else {
                        /** @type {number} */
                        x = +row.t;
                        html.put("rooms.objects", name);
                        i = html.get("gameinfo") || {
                            mode: "world"
                        };
                        i.historyTimestamp = void 0;
                        html.put("gameinfo", i);
                        html.put("gametime", x);
                        ws.reloadRoom();
                    }
                }
                if (pane) {
                    pane.$watchGroup([
                        function() {
                            return row.t;
                        },
                        function() {
                            return row.room;
                        },
                        function() {
                            return unused.name;
                        }
                    ], function(actualObject) {
                        /** @type {(Array|number)} */
                        var object = actualObject;
                        var id = object[0];
                        var value = object[1];
                        if ("top.game-room-history" == unused.name) {
                            /** @type {number} */
                            id = parseInt(id);
                            /** @type {number} */
                            var expected = 20 * Math.floor(id / 20);
                            if (self && (self.room == value && (self.ticks && self.ticks[id]))) {
                                updateRange();
                                html.put("rooms.objects", name);
                                ws.reloadRoom(void 0, void 0, void 0, x);
                            } else {
                                if (!self || (self.base != expected || self.room != value)) {
                                    /** @type {number} */
                                    actual = expected;
                                    /** @type {string} */
                                    var storageKey = that.options.official
                                        ? "https://screeps.com/room-history/" + value + "/" + expected + ".json"
                                        : "http://" + that.options.host + ":" + that.options.port + "/room-history?room=" + value + "&time=" + expected;
                                    storage.get(storageKey).then(function(config) {
                                        if (200 != config.status) {
                                            return $.reject();
                                        }
                                        if (actual != expected) {
                                            return $.reject();
                                        }
                                        if (!config.data.room) {
                                            config.data.room = value;
                                        }
                                        var errors = {};
                                        _.forEach(config.data.ticks, function(other) {
                                            _.forEach(other, function(data) {
                                                if (data) {
                                                    if (data.user) {
                                                        if (!users[data.user]) {
                                                            /** @type {boolean} */
                                                            errors[data.user] = true;
                                                        }
                                                    }
                                                    if (data.reservation) {
                                                        if (data.reservation.user) {
                                                            if (!users[data.reservation.user]) {
                                                                /** @type {boolean} */
                                                                errors[data.reservation.user] = true;
                                                            }
                                                        }
                                                    }
                                                }
                                            });
                                        });
                                        /** @type {Array} */
                                        var tests = [];
                                        return errors = _.keys(errors),
                                        errors.length && errors.forEach(function(term) {
                                            tests.push(that.get("user/find", {id: term}).then(function(user) {
                                                users[user.user._id] = user.user;
                                            }));
                                        }),
                                        $.all(tests).then(function() {
                                            return actual != expected
                                                ? $.reject()
                                                : void ws.initReplay(config.data);
                                        });
                                    })["catch"](function(dataAndEvents) {
                                        ws.initReplay({});
                                    })["finally"](function() {
                                        if (actual == expected) {
                                            /** @type {boolean} */
                                            actual = false;
                                        }
                                    });
                                }
                            }
                        }
                    });
                }
            },
            ws.run = function() {
                /**
                     * @param {string} key
                     * @return {?}
                     */
                function fn(key) {
                    return $(function(is, dataAndEvents) {
                        /** @type {Worker} */
                        var w = new Worker(globalWorkersBlob);
                        /**
                             * @param {?} er
                             * @return {undefined}
                             */
                        w.onerror = function(er) {};
                        is(w);
                        setTimeout(function() {
                            return w.postMessage({type: "launch", name: key});
                        }, 10);
                    });
                }
                if (html.put("runTimestamp", (new Date).getTime()), self) {
                    return data && queue.cancel(data),
                    void(data = queue(function() {
                        if (!actual) {
                            exports.replace();
                            exports.search("t", parseInt(row.t) + 1);
                        }
                    }, camelKey));
                }
                /** @type {boolean} */
                var c = false;
                /** @type {null} */
                var tref = null;
                fn("main").then(function(tcp) {
                    worker = tcp;
                    /**
                         * @param {Event} event
                         * @return {undefined}
                         */
                    worker.onmessage = function(event) {
                        if ("localStorage" == event.data.type) {
                            html.handleMessage(event);
                        }
                        if ("roomsDone" == event.data.type) {
                            $rootScope.$applyAsync(function() {
                                ws.reloadRoom();
                            });
                            event.target.postMessage({transactionId: event.data.transactionId});
                            if (c) {
                                result.then(function(ws) {
                                    return ws.terminate();
                                });
                                /** @type {null} */
                                result = null;
                                /** @type {boolean} */
                                c = false;
                            }
                        }
                    };
                    worker.postMessage({type: "setTickPeriod", period: camelKey});
                });
                fn("runner").then(function(dataAndEvents) {
                    /**
                         * @return {undefined}
                         */
                    function done() {
                        if (!result) {
                            result = fn("runtime");
                            result.then(function(leap) {
                                /**
                                     * @param {MessageEvent} evt
                                     * @return {undefined}
                                     */
                                leap.onmessage = function(evt) {
                                    theWorker.postMessage({type: "worker", workerId: 0, message: evt.data});
                                };
                                if (tref) {
                                    clearTimeout(tref);
                                }
                                /** @type {number} */
                                tref = setTimeout(function() {
                                    /** @type {boolean} */
                                    c = true;
                                    /** @type {null} */
                                    tref = null;
                                }, 1E4);
                            });
                        }
                    }
                    theWorker = dataAndEvents;
                    /**
                         * @param {Event} event
                         * @return {undefined}
                         */
                    theWorker.onmessage = function(event) {
                        if ("localStorage" == event.data.type) {
                            html.handleMessage(event);
                        }
                        if ("worker" == event.data.type) {
                            if (event.data.startSrc) {
                                done();
                            }
                            if (event.data.message) {
                                done();
                                result.then(function(runner) {
                                    runner.postMessage(event.data.message);
                                });
                            }
                            if (event.data.terminate) {
                                if (result) {
                                    result.then(function(ws) {
                                        ws.terminate();
                                        /** @type {null} */
                                        result = null;
                                        done();
                                    });
                                }
                            }
                        }
                        if ("console" == event.data.type) {
                            $rootScope.$applyAsync(function() {
                                type.forEach(function(onError) {
                                    return onError(event.data);
                                });
                            });
                        }
                        if ("timeout" == event.data.type) {
                            req.setTimeout(event.data.transactionId, event.data.timeout, event.target);
                        }
                        if ("clearTimeout" == event.data.type) {
                            req.clearTimeout(event.data.timeoutTransactionId);
                            event.target.postMessage({transactionId: event.data.transactionId});
                            event.target.postMessage({transactionId: event.data.timeoutTransactionId, reject: true});
                        }
                    };
                });
                fn("processor").then(function(dataAndEvents) {
                    wrk = dataAndEvents;
                    /**
                         * @param {Event} event
                         * @return {undefined}
                         */
                    wrk.onmessage = function(event) {
                        if ("localStorage" == event.data.type && html.handleMessage(event), "bulk" == event.data.type) {
                            var list = html.get(event.data.storage);
                            event.data.removes.forEach(function(id) {
                                var pos = _.findIndex(list, {_id: id});
                                if (pos > -1) {
                                    list.splice(pos, 1);
                                }
                            });
                            var data = {};
                            /** @type {number} */
                            var i = 0;
                            for (; i < list.length; i++) {
                                /** @type {number} */
                                data[list[i]._id] = i;
                            }
                            event.data.updates.forEach(function(item) {
                                if (item._id in data) {
                                    _.merge(list[data[item._id]], item.data);
                                }
                            });
                            event.data.inserts.forEach(function(element) {
                                var id;
                                /** @type {number} */
                                var e = 0;
                                do {
                                    /** @type {string} */
                                    id = "";
                                    /** @type {number} */
                                    var f = 0;
                                    for (; 24 > f; f++) {
                                        id += charArray[Math.floor(Math.random() * charArray.length)];
                                    }
                                    e++;
                                } while (_.any(list, {_id: id}));
                                element._id = id;
                                list.push(element);
                            });
                            /** @type {null} */
                            data = null;
                            html.put(event.data.storage, list);
                            event.target.postMessage({transactionId: event.data.transactionId});
                        }
                    };
                });
                ws.reloadRoom();
            },
            ws.terminate = function() {
                return self
                    ? void(data && (queue.cancel(data), data = null))
                    : (worker && worker.terminate(), theWorker && theWorker.terminate(), wrk && wrk.terminate(), result && result.then(function(ws) {
                        ws.terminate();
                        /** @type {null} */
                        result = null;
                    }), void req.clearTimeout());
            },
            ws.getRoomTerrain = function() {
                return textInputID && "top.game-room-history" != unused.name
                    ? $(function(next) {
                        /**
                             * @return {undefined}
                             */
                        function after() {
                            var items = html.get("rooms.terrain");
                            if (items && items.length) {
                                next(FBTest.decodeTerrain(items[0].terrain, items[0].room));
                            } else {
                                setTimeout(after, 10);
                            }
                        }
                        after();
                    })
                    : appLoading.loading(that.get("game/room-terrain", {
                        room: row.room,
                        encoded: true
                    }).then(function(c) {
                        return c.terrain && c.terrain.length
                            ? FBTest.decodeTerrain(c.terrain[0].terrain, row.room)
                            : $.reject();
                    }));
            },
            ws.createFlag = function(x, y, key, value, item, userId) {
                if (textInputID) {
                    var q = html.get("rooms.flags");
                    var query = _.find(q, {user: userId});
                    if (!query) {
                        query = {
                            _id: userId,
                            user: userId,
                            data: ""
                        };
                        q.push(query);
                    }
                    var results = replace(query.data);
                    var result = _.find(results, function(x) {
                        return x[0] == key;
                    });
                    return result
                        ? (result[1] = value, result[2] = item, result[3] = x, result[4] = y)
                        : results.push([key, value, item, x, y]),
                    query.data = parse(results),
                    html.put("rooms.flags", q),
                    $.when();
                }
                return appLoading.loading(that.post("game/create-flag", {
                    x: x,
                    y: y,
                    name: key,
                    color: value,
                    secondaryColor: item,
                    room: row.room
                }));
            },
            ws.changeFlagColor = function(errorName, value, element, dbUser) {
                if (!textInputID) {
                    return appLoading.loading(that.post("game/change-flag-color", {
                        room: row.room,
                        name: errorName,
                        color: value,
                        secondaryColor: element
                    }));
                }
                var text = html.get("rooms.flags");
                var options = _.find(text, {user: dbUser});
                if (options) {
                    var results = replace(options.data);
                    var data = _.find(results, function(dataAndEvents) {
                        return dataAndEvents[0] == errorName;
                    });
                    if (data) {
                        /** @type {Blob} */
                        data[1] = value;
                        /** @type {Blob} */
                        data[2] = element;
                        options.data = parse(results);
                        html.put("rooms.flags", text);
                    }
                }
            },
            ws.removeFlag = function(errorName, dbUser) {
                if (!textInputID) {
                    return appLoading.loading(that.post("game/remove-flag", {
                        room: row.room,
                        name: errorName
                    }));
                }
                var text = html.get("rooms.flags");
                var options = _.find(text, {user: dbUser});
                if (options) {
                    var key = replace(options.data);
                    _.remove(key, function(dataAndEvents) {
                        return dataAndEvents[0] == errorName;
                    });
                    options.data = parse(key);
                    html.put("rooms.flags", text);
                }
            },
            ws.addObjectIntent = function(name, chain, key, opt_attributes) {
                var HTML5_DOMStringMap;
                var scrubbed;
                var _this;
                var assert;
                var ctx;
                if (textInputID) {
                    var id = html.get("rooms.intents") || [];
                    return id.length || id.push({room: "sim"}),
                    _.merge(_.find(id, {room: "sim"}), (ctx = {}, Object.defineProperty(ctx, "users", {
                        value: (assert = {}, Object.defineProperty(assert, chain, {
                            value: (_this = {}, Object.defineProperty(_this, "objects", {
                                value: (scrubbed = {}, Object.defineProperty(scrubbed, name, {
                                    value: (HTML5_DOMStringMap = {}, Object.defineProperty(HTML5_DOMStringMap, key, {
                                        value: opt_attributes,
                                        configurable: true,
                                        enumerable: true,
                                        writable: true
                                    }), HTML5_DOMStringMap),
                                    configurable: true,
                                    enumerable: true,
                                    writable: true
                                }), scrubbed),
                                configurable: true,
                                enumerable: true,
                                writable: true
                            }), _this),
                            configurable: true,
                            enumerable: true,
                            writable: true
                        }), assert),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    }), ctx)),
                    html.put("rooms.intents", id),
                    q.when();
                }
                return appLoading.loading(that.post("game/add-object-intent", {
                    room: row.room,
                    _id: name,
                    name: key,
                    intent: opt_attributes
                }));
            },
            ws.createConstruction = function(num, moveX, moveY, dbUser, deepDataAndEvents) {
                if (textInputID) {
                    var key = html.get("rooms.objects");
                    var rightBetween = html.get("rooms.terrain");
                    var line = $scope.CONSTRUCTION_COST[num];
                    if ("road" == num) {
                        if (_.any([
                            key, rightBetween
                        ], function(protoProps) {
                            return _.any(protoProps, {
                                x: moveX,
                                y: moveY,
                                type: "swamp"
                            });
                        })) {
                            line *= $scope.CONSTRUCTION_COST_ROAD_SWAMP_RATIO;
                        }
                    }
                    if ("tower" == num) {
                        if ("top.sim-tutorial" == unused.name) {
                            /** @type {number} */
                            line = 100;
                        }
                    }
                    var data = {
                        _id: ws.genUniqueId(),
                        type: "constructionSite",
                        structureType: num,
                        name: deepDataAndEvents,
                        x: moveX,
                        y: moveY,
                        user: dbUser,
                        progress: 0,
                        progressTotal: line,
                        room: "sim"
                    };
                    return key.push(data),
                    html.put("rooms.objects", key),
                    $.when(data._id);
                }
                return appLoading.loading(that.post("game/create-construction", {
                    room: row.room,
                    structureType: num,
                    x: moveX,
                    y: moveY,
                    name: deepDataAndEvents
                }).then(function(post2) {
                    return post2._id;
                }));
            },
            ws.placeSpawn = function(newX, y, n, dbUser) {
                if (!textInputID) {
                    return appLoading.loading(that.post("game/place-spawn", {
                        room: row.room,
                        x: newX,
                        y: y,
                        name: n
                    }).then(function(dataAndEvents) {
                        return opts.check(),
                        dataAndEvents;
                    }));
                }
                var chars = html.get("rooms.objects");
                chars.push({
                    _id: ws.genUniqueId(),
                    type: "spawn",
                    name: n,
                    x: newX,
                    y: y,
                    user: dbUser,
                    room: "sim",
                    energy: $scope.SPAWN_ENERGY_START,
                    energyCapacity: $scope.SPAWN_ENERGY_CAPACITY,
                    hits: $scope.SPAWN_HITS,
                    hitsMax: $scope.SPAWN_HITS,
                    spawning: null
                });
                html.put("rooms.objects", chars);
            },
            ws.genUniqueId = function() {
                var id;
                var reversed = html.get("rooms.objects");
                /** @type {number} */
                var e = 0;
                do {
                    /** @type {string} */
                    id = "";
                    /** @type {number} */
                    var f = 0;
                    for (; 24 > f; f++) {
                        id += charArray[Math.floor(Math.random() * charArray.length)];
                    }
                    e++;
                } while (_.any(reversed, {_id: id}));
                return id;
            },
            ws.getMemory = function(key) {
                var promise = $.when();
                return textInputID || (key != opts.Me._id || (promise = appLoading.loading(that.get("user/memory")).then(function(session) {
                    return done(key, session.memory);
                }))),
                promise.then(function() {
                    var option = html.get("users.memory");
                    var options = _.find(option, {_id: key});
                    return options
                        ? options.memory
                        : (done(key, {}), ws.getMemory(key));
                });
            },
            ws.setMemory = function(err, results) {
                var promise = $.when();
                return textInputID || (err != opts.Me._id || (promise = appLoading.loading(that.post("user/memory", {memory: results})))),
                promise.then(function() {
                    return done(err, results);
                });
            },
            ws.listenSocket = function(child) {
                var $div;
                /** @type {Array} */
                var camelKey = [];
                var params = {};
                child.$watch(function() {
                    return row.room;
                }, function() {
                    if ($div) {
                        $div.remove();
                        /** @type {Array} */
                        camelKey = [];
                        params = {};
                    }
                    $div = assert.bindEventToScope(child, "room:" + row.room, function(config, statement) {
                        if (statement.type == "room:" + row.room) {
                            ws.roomSubscribeError = void 0;
                            build(camelKey, config.objects);
                            _.extend(params, config.users);
                            ws.reloadRoom(camelKey, params, config.info, config.gameTime, config.flags);
                        }
                    }, function(listener, statement) {
                        if (statement.type == "room:" + row.room) {
                            /** @type {Function} */
                            ws.roomSubscribeError = listener;
                        }
                    });
                });
                assert.bindEventToScope(child, "user:" + opts.Me._id + "/console", function(e) {
                    if (e.messages) {
                        e.messages.log.forEach(function(fmt) {
                            return window.console.log(fmt);
                        });
                        e.messages.results.forEach(function(fmt) {
                            return window.console.log(fmt);
                        });
                    }
                    if (e.error) {
                        window.console.error(e.error);
                    }
                    type.forEach(function(onload) {
                        e.userId = opts.Me._id;
                        onload(e);
                    });
                });
            },
            ws.onMemoryUpdate = function(host, chunk, key, cb) {
                if (textInputID) {
                    return ws.onRoomUpdate(host, function() {
                        try {
                            var ret = callback(chunk, key);
                            cb("" + ret);
                        } catch (e) {
                            cb("Incorrect memory path");
                        }
                    });
                }
                var stream = assert.bindEventToScope(host, "user:" + chunk + "/memory/" + key, function(outErr) {
                    cb(outErr);
                });
                return stream.remove;
            },
            ws.getMemoryByPath = function(chunk, i) {
                if (!textInputID) {
                    return that.get("user/memory", {path: i}).then(function(event) {
                        return _.isString(event.data) && "gz:" == event.data.substring(0, 3)
                            ? JSON.parse(pako.ungzip(atob(event.data.substring(3)), {to: "string"}))
                            : event.data;
                    });
                }
                try {
                    var ret = callback(chunk, i);
                    return $.when(ret);
                } catch (d) {
                    return $.reject("Incorrect memory path");
                }
            },
            ws.setMemoryByPath = function(done, data, val) {
                if (!textInputID) {
                    return that.post("user/memory", {
                        path: data,
                        value: val
                    });
                }
                try {
                    return finish(done, data, val),
                    $.when();
                } catch (d) {
                    return $.reject("Incorrect memory path");
                }
            },
            ws.genUniqueNameForType = function(origin, id) {
                if ("creep" == origin) {
                    return $.when(update(id));
                }
                if (textInputID) {
                    var url;
                    var previous = html.get("rooms.objects");
                    /** @type {number} */
                    var link_id = 1;
                    do {
                        url = _.capitalize(origin) + link_id;
                        link_id++;
                    } while (_.any(previous, {
                        user: id,
                        type: origin,
                        name: url
                    }) || _.any(previous, {
                        user: id,
                        type: "constructionSite",
                        structureType: origin,
                        name: url
                    }));
                    return $.when(url);
                }
                return appLoading.loading(that.post("game/gen-unique-object-name", {type: origin}).then(function(unused) {
                    return unused.name;
                }));
            },
            ws.genUniqueFlagName = function(dbUser) {
                if (textInputID) {
                    var reversed = html.get("rooms.flags");
                    var result = _.find(reversed, {user: dbUser}) || {
                        data: ""
                    };
                    var path_portions = replace(result.data);
                    /** @type {number} */
                    var name = 0;
                    do {
                        name++;
                    } while (_.any(path_portions, function(dataAndEvents) {
                        return dataAndEvents[0] == "Flag" + name;
                    }));
                    return $.when("Flag" + name);
                }
                return appLoading.loading(that.post("game/gen-unique-flag-name").then(function(unused) {
                    return unused.name;
                }));
            },
            ws.checkUniqueNameForType = function(item, keepData, dataAndEvents) {
                if (textInputID) {
                    var previous = html.get("rooms.objects");
                    return _.any(previous, {
                        user: dataAndEvents,
                        type: keepData,
                        name: item
                    }) || _.any(previous, {
                        user: dataAndEvents,
                        type: "constructionSite",
                        structureType: keepData,
                        name: item
                    })
                        ? $.reject("name exists")
                        : $.when();
                }
                return appLoading.loading(that.post("game/check-unique-object-name", {
                    name: item,
                    type: keepData
                }));
            },
            ws.checkUniqueFlagName = function(errorName, dbUser) {
                if (textInputID) {
                    var reversed = html.get("rooms.flags");
                    var result = _.find(reversed, {user: dbUser}) || {
                        data: ""
                    };
                    var path_portions = replace(result.data);
                    return _.any(path_portions, function(dataAndEvents) {
                        return dataAndEvents[0] == errorName;
                    })
                        ? $.reject("name exists")
                        : $.when();
                }
                return appLoading.loading(that.post("game/check-unique-flag-name", {name: errorName}));
            },
            ws.finishGame = function() {
                if (!textInputID) {
                    return appLoading.loading(that.post("game/finish", {room: row.room}));
                }
                var value = html.get("gameinfo") || {};
                /** @type {string} */
                value.status = "finished";
                html.put("gameinfo", value);
            },
            ws.createInvader = function(moveX, moveY, type, size, dataAndEvents) {
                if (textInputID) {
                    var map = {
                        bigHealer: [
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "move"
                        ],
                        bigRanged: [
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "work",
                            "move"
                        ],
                        bigMelee: [
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "tough",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "move",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "work",
                            "work",
                            "work",
                            "work",
                            "attack",
                            "attack",
                            "move"
                        ],
                        smallHealer: [
                            "move",
                            "move",
                            "move",
                            "move",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "heal",
                            "move"
                        ],
                        smallRanged: [
                            "tough",
                            "tough",
                            "move",
                            "move",
                            "move",
                            "move",
                            "ranged_attack",
                            "ranged_attack",
                            "ranged_attack",
                            "move"
                        ],
                        smallMelee: [
                            "tough",
                            "tough",
                            "move",
                            "move",
                            "move",
                            "move",
                            "ranged_attack",
                            "work",
                            "attack",
                            "move"
                        ]
                    };
                    var i = html.get("rooms.objects");
                    var val = map[size + type];
                    var params = {
                        _id: ws.genUniqueId(),
                        type: "creep",
                        user: "2",
                        body: _.map(val, function(paramType) {
                            return {type: paramType, hits: 100};
                        }),
                        hits: 100 * val.length,
                        hitsMax: 100 * val.length,
                        ticksToLive: 1500,
                        x: moveX,
                        y: moveY,
                        room: "sim",
                        fatigue: 0,
                        energy: 0,
                        energyCapacity: 0,
                        name: "invader_" + Math.floor(1E3 * Math.random())
                    };
                    return dataAndEvents && params.body.forEach(function(filter) {
                        if ("heal" == filter.type) {
                            /** @type {string} */
                            filter.boost = "LO";
                        }
                        if ("ranged_attack" == filter.type) {
                            /** @type {string} */
                            filter.boost = "KO";
                        }
                        if ("work" == filter.type) {
                            /** @type {string} */
                            filter.boost = "ZH";
                        }
                        if ("attack" == filter.type) {
                            /** @type {string} */
                            filter.boost = "UH";
                        }
                    }),
                    i.push(params),
                    html.put("rooms.objects", i),
                    $.when();
                }
                return that.post("game/create-invader", {
                    room: row.room,
                    x: moveX,
                    y: moveY,
                    size: size,
                    type: type,
                    boosted: dataAndEvents
                });
            },
            ws;
        }
    ]), {};
}();
var $__app_95_utils_47_key_45_filter__ = function() {
    /**
     * @return {?}
     */
    function expectedNumberOfNonCommentArgs() {
        var func = compile(data);
        return function(variables, bool) {
            if (bool = _.isBoolean(bool)
                ? bool
                : true, !variables || (!_.isObject(variables) || (_.isArray(variables) || !bool))) {
                return variables;
            }
            /** @type {Array} */
            var bucket = [];
            var which = _.keys(variables);
            return _.each(which, function(name) {
                if ("$value" != name) {
                    var value = variables[name];
                    if (_.isObject(value)) {
                        /** @type {string} */
                        value.$name = name;
                    } else {
                        value = func(name, value);
                    }
                    bucket.push(value);
                }
            }),
            bucket;
        };
    }
    /**
     * @param {string} key
     * @param {?} value
     * @return {?}
     */
    function data(key, value) {
        return {$value: value, $name: key};
    }
    /**
     * @param {Function} fn
     * @return {?}
     */
    function compile(fn) {
        /**
         * @return {?}
         */
        var compile = function() {
            var cache = compile.cache;
            var type = arguments[0];
            var key = arguments[1];
            return cache[type] = cache[type] || {},
            _.isUndefined(cache[type][key])
                ? (cache[type][key] = fn.call(null, type, key),
                cache[type][key])
                : cache[type][key];
        };
        return compile.cache = {},
        compile;
    }
    return angular.module("app.key-filter", []).filter("keyFilter", expectedNumberOfNonCommentArgs), {};
}();
var $__app_95_utils_47_local_45_storage__ = function() {
    return angular.module("app.local-storage", []).provider("LocalStorage", function() {
        /** @type {Array} */
        this.$get = [
            "$rootScope",
            "$parse",
            "$timeout",
            function($scope, func, dataAndEvents, deepDataAndEvents) {
                var self = {
                    prefix: ""
                };
                var obj = {};
                /**
                 * @param {string} keepData
                 * @return {?}
                 */
                var callback = function(keepData) {
                    return self.prefix && (keepData = self.prefix + ":" + keepData, keepData = keepData.replace(new RegExp("^(" + self.prefix + ":)+"), self.prefix + ":")),
                    keepData;
                };
                /**
                 * @param {string} key
                 * @param {?} expectedHashCode
                 * @return {?}
                 */
                self.get = function(key, expectedHashCode) {
                    key = callback(key);
                    var val = localStorage.getItem(key);
                    if (null !== val) {
                        /** @type {*} */
                        var attrs = "undefined" == val
                            ? void 0
                            : JSON.parse(val);
                        return _.isArray(expectedHashCode) && !attrs
                            ? expectedHashCode
                            : angular.isObject(attrs) && (_ && _.defaults)
                                ? _.defaults(attrs, expectedHashCode)
                                : attrs;
                    }
                    return expectedHashCode;
                };
                /**
                 * @param {string} key
                 * @param {?} value
                 * @return {?}
                 */
                self.put = function(key, value) {
                    return key = callback(key),
                    localStorage.setItem(key, JSON.stringify(value)),
                    value;
                };
                /**
                 * @param {?} keepData
                 * @return {undefined}
                 */
                self.remove = function(keepData) {
                    keepData = callback(keepData);
                    localStorage.removeItem(keepData);
                };
                /**
                 * @return {undefined}
                 */
                self.removeAll = function() {
                    localStorage.clear();
                };
                /**
                 * @param {string} key
                 * @param {Function} model
                 * @param {Object} attributes
                 * @return {undefined}
                 */
                self.sync = function(key, model, attributes) {
                    key = callback(key);
                    var node = self.get(key, attributes);
                    angular.extend(model, node);
                    $scope.$watch(function() {
                        return model;
                    }, function(value) {
                        self.put(key, value);
                    }, true);
                };
                /**
                 * @param {string} key
                 * @param {Array} failures
                 * @return {undefined}
                 */
                self.syncArray = function(key, failures) {
                    key = callback(key);
                    var values = self.get(key, []);
                    failures.forEach(function(dataAndEvents, key) {
                        /** @type {null} */
                        failures[key] = null;
                        delete failures[key];
                    });
                    values.forEach(function(test) {
                        return failures.push(test);
                    });
                    $scope.$watchCollection(function() {
                        return failures;
                    }, function(value) {
                        self.put(key, value);
                    });
                };
                /**
                 * @param {Text} key
                 * @param {?} scope
                 * @param {?} name
                 * @param {Object} property
                 * @return {undefined}
                 */
                self.syncExp = function(key, scope, name, property) {
                    key = callback(key);
                    var val = self.get(key, property);
                    var fn = func(name);
                    fn.assign(scope, val);
                    scope.$watch(name, function(value) {
                        self.put(key, value);
                    }, true);
                };
                /**
                 * @param {string} events
                 * @param {?} opt_attributes
                 * @return {?}
                 */
                self.createSyncedObj = function(events, opt_attributes) {
                    events = callback(events);
                    var model = {};
                    return self.sync(events, model, opt_attributes),
                    model;
                };
                /**
                 * @param {Text} key
                 * @return {?}
                 */
                self.createSyncedArray = function(key) {
                    key = callback(key);
                    /** @type {Array} */
                    var bad = [];
                    return self.syncArray(key, bad),
                    bad;
                };
                /**
                 * @param {Event} event
                 * @return {undefined}
                 */
                self.handleMessage = function(event) {
                    if (event.data.get) {
                        event.data.get.key = callback(event.data.get.key);
                        event.target.postMessage({
                            type: "localStorage",
                            transactionId: event.data.transactionId,
                            get: {
                                value: self.get(event.data.get.key)
                            }
                        });
                    }
                    if (event.data.put) {
                        event.data.put.key = callback(event.data.put.key);
                        event.target.postMessage({
                            type: "localStorage",
                            transactionId: event.data.transactionId,
                            put: {
                                value: self.put(event.data.put.key, event.data.put.value)
                            }
                        });
                    }
                };
                /**
                 * @param {Object} scope
                 * @param {string} key
                 * @param {Function} value
                 * @return {?}
                 */
                self.onChange = function(scope, key, value) {
                    key = callback(key);
                    /**
                     * @return {?}
                     */
                    var unbind = function() {
                        return _.remove(obj[key], function(el) {
                            return el == value;
                        });
                    };
                    return obj[key] = obj[key] || [],
                    obj[key].push(value),
                    scope.$on("$destroy", unbind),
                    unbind;
                };
                /**
                 * @param {Event} event
                 * @return {undefined}
                 */
                var update = function(event) {
                    if (obj[event.key]) {
                        $scope.$apply(function() {
                            obj[event.key].forEach(function($sanitize) {
                                return $sanitize(JSON.parse(event.newValue));
                            });
                        });
                    }
                };
                return window.addEventListener("storage", update, false),
                self;
            }
        ];
    }), {};
}();
var $__app_95_utils_47_memory_45_storage__ = function() {
    var value = angular.module("app.memory-storage", []);
    return value.factory("MemoryStorage", [
        "$cacheFactory",
        "LocalStorage",
        function(Event, $http) {
            var self = Event("memoryStorage");
            return self.handleMessage = function(event) {
                if (event.data.get) {
                    var origValue = self.get(event.data.get.key);
                    event.target.postMessage({
                        type: "localStorage",
                        transactionId: event.data.transactionId,
                        get: {
                            value: origValue
                        }
                    });
                }
                if (event.data.put) {
                    event.target.postMessage({
                        type: "localStorage",
                        transactionId: event.data.transactionId,
                        put: {
                            value: self.put(event.data.put.key, event.data.put.value)
                        }
                    });
                }
            },
            self.put("users", $http.get("users")),
            self.put("users.code.activeSim", $http.get("users.code.activeSim")),
            self.put("users.code.activeWorld", $http.get("users.code.activeWorld")),
            self;
        }
    ]), {};
}();
var $__app_95_utils_47_nw_45_local_45_file_45_sync__ = function() {
    var $provide = angular.module("app.nw-local-file-sync", []);
    return $provide.factory("NwLocalFileSync", [
        "Dialogs",
        "$q",
        "$rootScope",
        "Auth",
        "CodeBranches",
        "Loader",
        "LocalStorage",
        "Api",
        function(dialog, list, $rootScope, opts, fn, appLoading, $templateCache, service) {
            /**
             * @param {?} name
             * @return {?}
             */
            function load(name) {
                return fs.readdir(path + id + name).then(function(failures) {
                    var ret = {};
                    /** @type {number} */
                    var latestMtime = 0;
                    return failures.forEach(function(class_name) {
                        var b = class_name.match(/^(.*)\.js$/);
                        if (b) {
                            var source = path + id + name + id + class_name;
                            ret[b[1]] = fs.stat(source).then(function(entry) {
                                return entry.mtime > latestMtime && (latestMtime = entry.mtime),
                                fs.readFile(source, {encoding: "utf8"});
                            });
                        }
                    }),
                    list.all(ret).then(function(modules) {
                        return {modules: modules, mtime: latestMtime};
                    });
                })["catch"](rejected);
            }
            /**
             * @param {number} a
             * @return {?}
             */
            function cb(a) {
                return fs.writeFile(path + "/.sync", a + "\n" + opts.Me._id)["catch"](rejected);
            }
            /**
             * @param {?} type
             * @param {?} target
             * @return {?}
             */
            function init(type, target) {
                var jQuery = util.watch(path + id + type + id + "*.js", {
                    ignoreInitial: true,
                    depth: 0
                });
                return jQuery.on("all", function(no, value) {
                    return $rootScope.$apply(function() {
                        if ("add" == no || ("change" == no || "unlink" == no)) {
                            if (!(r > Date.now() - t)) {
                                if (!_.contains(keys, value)) {
                                    /** @type {number} */
                                    s = Date.now();
                                    appLoading.loading(load(type).then(function(not) {
                                        /** @type {Object} */
                                        var obj = not;
                                        var op = obj.modules;
                                        obj.mtime;
                                        return target.branchChanged && target.branchChanged(type, op),
                                        cb(Date.now());
                                    }));
                                }
                            }
                        }
                    });
                }),
                jQuery;
            }
            /**
             * @param {?} error
             * @return {?}
             */
            function rejected(error) {
                return list.reject(error);
            }
            var helper;
            var util;
            var fs;
            var path;
            /** @type {string} */
            var id = "/";
            /** @type {number} */
            var r = 0;
            /** @type {number} */
            var s = 0;
            /** @type {number} */
            var t = 3E3;
            /** @type {Array} */
            var keys = [];
            var self = {};
            return self.init = function() {
                if (!window.nw) {
                    return list.when();
                }
                var name = service.options.official
                    ? "screeps.com"
                    : service.options.host.replace(/[^a-zA-Z0-9]/g, "_") + "___" + service.options.port;
                helper = require("graceful-fs");
                util = require("chokidar");
                fs = {};
                return [
                    "readFile",
                    "writeFile",
                    "stat",
                    "readdir",
                    "mkdir",
                    "unlink",
                    "rmdir"
                ].forEach(function(key) {
                    /**
                             * @return {?}
                             */
                    fs[key] = function() {
                        /** @type {Array.<?>} */
                        var args = (Math.floor(1E5 * Math.random()), Array.prototype.slice.apply(arguments));
                        return "writeFile" == key && keys.push(args[0]),
                        list(function(cb, proceed) {
                            args.push(function(element, outErr) {
                                if ("writeFile" == key) {
                                    if (self[args[0]]) {
                                        clearTimeout(self[args[0]]);
                                    }
                                    /** @type {number} */
                                    self[args[0]] = setTimeout(function() {
                                        _.pull(keys, args[0]);
                                    }, t);
                                }
                                if (element) {
                                    proceed(element);
                                } else {
                                    cb(outErr);
                                }
                            });
                            helper[key].apply(helper, args);
                        });
                    };
                }),
                /\\/.test(nw.App.dataPath) && (id = "\\"),
                path = nw.App.dataPath.replace(/[\/\\]User Data/, "").replace(/[\/\\]Default/, ""),
                path += id + "scripts",
                fs.stat(path)["catch"](function() {
                    return fs.mkdir(path);
                }).then(function() {
                    return path = path + id + name,
                    fs.stat(path)["catch"](function() {
                        return fs.mkdir(path);
                    });
                }).then(function() {
                    return _.extend(self, {
                        dataPath: path,
                        sep: id,
                        worldName: name
                    });
                });
            },
            self.startSync = function(scope, options) {
                if (window.nw) {
                    var modalInstance;
                    var cache = {};
                    fs.readdir(path).then(function(failures) {
                        failures.forEach(function(id) {
                            if (".sync" != id) {
                                cache[id] = init(id, options);
                            }
                        });
                        var watcher = util.watch(path, {
                            ignoreInitial: true,
                            depth: 0,
                            ignored: ".sync"
                        });
                        watcher.on("addDir", function(url) {
                            return scope.$apply(function() {
                                url = url.replace(path + id, "");
                                /** @type {number} */
                                s = Date.now();
                                appLoading.loading(load(url).then(function(computed) {
                                    /** @type {Object} */
                                    var result = computed;
                                    var data = result.modules;
                                    result.mtime;
                                    if (r < Date.now() - t) {
                                        if (options.branchCreated) {
                                            options.branchCreated(url, data);
                                        }
                                    }
                                    cache[url] = init(url, options);
                                }).then(function() {
                                    return cb(Date.now());
                                }));
                            });
                        });
                        watcher.on("unlinkDir", function(key) {
                            return scope.$apply(function() {
                                key = key.replace(path + id, "");
                                if (r < Date.now() - t) {
                                    if (options.branchRemoved) {
                                        options.branchRemoved(key);
                                    }
                                }
                                if (cache[key]) {
                                    cache[key].close();
                                    delete cache[key];
                                }
                                cb(Date.now());
                            });
                        });
                        scope.$on("$destroy", function() {
                            return watcher.close();
                        });
                    });
                    fn.registerCodeCallback(scope, function(data, dataAndEvents) {
                        if (!dataAndEvents) {
                            if (modalInstance && modalInstance.dismiss(), $templateCache.get("nw.alwaysReplaceLocalScripts", 0)) {
                                return void self.writeBranch(data.branch, data.modules, data.timestamp);
                            }
                            modalInstance = dialog.ask({message: "Your remote scripts have been changed. Do you want to replace scripts on your local file system with the remote scripts?", buttonLabel: "Replace", buttonOptionalLabel: "Always replace without asking"});
                            modalInstance.result["catch"](function(r) {
                                return "optional click" == r
                                    ? void $templateCache.put("nw.alwaysReplaceLocalScripts", 1)
                                    : list.reject(r);
                            }).then(function() {
                                return self.writeBranch(data.branch, data.modules, data.timestamp);
                            });
                        }
                    });
                }
            },
            self.writeBranch = function(resolvedPath, obj, err) {
                if (!window.nw) {
                    return list.when();
                }
                /** @type {number} */
                r = Date.now();
                var p = path + id + resolvedPath;
                return fs.stat(p)["catch"](function() {
                    return fs.mkdir(p);
                }).then(function() {
                    return fs.readdir(p);
                }).then(function(info) {
                    return list.all(_.map(info, function(f) {
                        var items = f.match(/^(.*)\.js$/);
                        return items && !obj[items[1]]
                            ? fs.unlink(p + id + f)
                            : list.when();
                    }));
                }).then(function() {
                    return list.all(_.map(obj, function(file_contents, i) {
                        if (null === file_contents) {
                            return list.when();
                        }
                        /** @type {string} */
                        var sourceMapPath = p + id + i + ".js";
                        return r = Date.now(),
                        fs.writeFile(sourceMapPath, file_contents);
                    }));
                }).then(function() {
                    return err
                        ? cb(err)
                        : void 0;
                })["catch"](rejected);
            },
            self.deleteBranch = function(name, results) {
                return window.nw
                    ? (r = Date.now(), fs.readdir(path + id + name).then(function(info) {
                        return list.all(_.map(info, function(filename) {
                            return fs.unlink(path + id + name + id + filename);
                        }));
                    }).then(function() {
                        return fs.rmdir(path + id + name);
                    }).then(function() {
                        return cb(results);
                    })["catch"](rejected))
                    : list.when();
            },
            self.cloneBranch = function(opt_attributes, resolvedPath, deepDataAndEvents) {
                return window.nw
                    ? load(opt_attributes).then(function(computed) {
                        /** @type {Object} */
                        var result = computed;
                        var data = result.modules;
                        result.mtime;
                        return self.writeBranch(resolvedPath, data, deepDataAndEvents);
                    })["catch"](rejected)
                    : list.when();
            },
            self.sync = function(callback, func) {
                if (!window.nw) {
                    return list.when();
                }
                /** @type {number} */
                var prefix = 0;
                /** @type {Date} */
                var mtime = new Date(0);
                /** @type {Date} */
                var b = new Date(0);
                var _id = opts.Me._id;
                return appLoading.loading(fs.stat(path + id + ".sync").then(function(prev) {
                    return mtime = prev.mtime,
                    fs.readFile(path + id + ".sync", {encoding: "utf8"});
                }).then(function(pair) {
                    if (pair) {
                        var $cookies = pair.split("\n");
                        var cDigit = $cookies[0];
                        var value = $cookies[1];
                        /** @type {number} */
                        prefix = parseInt(cDigit) || 0;
                        _id = value;
                    }
                })["catch"](function() {}).then(callback).then(function(optgroup) {
                    var ok = optgroup.length
                        ? _.max(optgroup, "timestamp").timestamp
                        : 0;
                    return fs.readdir(path).then(function(failures) {
                        var old = {};
                        return failures.forEach(function(name) {
                            if (".sync" != name) {
                                old[name] = fs.stat(path + id + name).then(function(stat) {
                                    return stat.isDirectory()
                                        ? load(name).then(function(computed) {
                                            /** @type {Object} */
                                            var result = computed;
                                            var data = result.modules;
                                            var a = result.mtime;
                                            return a > b && (b = a),
                                            data;
                                        })
                                        : list.when();
                                });
                            }
                        }),
                        list.all(old);
                    }).then(function(array) {
                        /**
                             * @return {?}
                             */
                        function map() {
                            return func(array).then(function(err) {
                                return cb(err);
                            });
                        }
                        /**
                             * @return {?}
                             */
                        function resolve() {
                            return list.all(_.map(optgroup, function(data) {
                                return self.writeBranch(data.branch, data.modules);
                            })).then(function() {
                                return cb(ok);
                            });
                        }
                        /** @type {boolean} */
                        var bnum = b.getTime() > mtime.getTime() + t;
                        /** @type {boolean} */
                        var anum = opts.Me._id != _id || ok > prefix + t;
                        return bnum && !anum
                            ? map()
                            : anum && !bnum
                                ? _.size(array) && opts.Me._id == _id
                                    ? $templateCache.get("nw.alwaysReplaceLocalScripts", 0)
                                        ? resolve()
                                        : dialog.ask({message: "Your remote scripts have been changed. Do you want to replace scripts on your local file system with the remote scripts?", buttonLabel: "Replace", buttonOptionalLabel: "Always replace without asking"}).result["catch"](function(r) {
                                            return "optional click" == r
                                                ? void $templateCache.put("nw.alwaysReplaceLocalScripts", 1)
                                                : list.reject(r);
                                        }).then(resolve)
                                    : resolve()
                                : anum && bnum
                                        ? dialog.ask({message: "Your remote scripts have been changed. Do you want to replace scripts on your local file system with the remote scripts? Your local changes will be LOST!", buttonLabel: "Replace"}).result.then(resolve)
                                        : mtime.getTime()
                                            ? void 0
                                            : resolve();
                    });
                })["catch"](rejected));
            },
            self;
        }
    ]), {};
}();
var $__app_95_utils_47_nw_45_manifest__ = function() {
    var mod = angular.module("app.nw-manifest", []);
    return mod.factory("NwManifest", [
        "$http",
        function($templateCache) {
            var deep = {};
            return $templateCache.get("package.json").then(function(evt) {
                _.extend(deep, evt.data);
            }),
            deep;
        }
    ]), {};
}();
var $__app_95_utils_47_socket__ = function() {
    /**
     * @param {number} apiKey
     * @param {Function} cb
     * @return {undefined}
     */
    function init(apiKey, cb) {
        /**
         * @param {string} total
         * @return {undefined}
         */
        function done(total) {
            fs.writeSync(result, "[" + (new Date).toUTCString() + "] " + total + "\n");
        }
        var path = require("path");
        var base = path.dirname(process.execPath);
        var https = require("https");
        var fs = require("graceful-fs");
        /** @type {string} */
        var post = /\\/.test(nw.App.dataPath)
            ? "\\"
            : "/";
        /** @type {string} */
        var currentLog = base + post + "package.nw.new";
        var result = fs.openSync(base + post + "update.log", "a");
        try {
            done("Package " + apiKey + " available");
            var socket = fs.createWriteStream(currentLog);
            socket.on("open", function() {
                done("File opened");
                https.get("https://screeps.com/packages/" + apiKey, function(res) {
                    done("Received response from the server: " + res.statusCode);
                    if (200 == res.statusCode) {
                        res.pipe(socket);
                        socket.on("finish", function() {
                            done("File write finished, " + socket.bytesWritten + " bytes written");
                            socket.close(function() {
                                done("File write closed");
                                fs.renameSync(currentLog, base + post + "package.nw");
                                done("File renamed");
                                fs.close(result);
                                cb(null, true);
                            });
                        });
                    } else {
                        fs.unlinkSync(currentLog);
                        fs.close(result);
                        cb(res.statusCode);
                    }
                }).on("error", function(e) {
                    done("HTTP transfer error: " + e);
                    fs.unlinkSync(currentLog);
                    fs.close(result);
                    cb(e.message);
                });
            }).on("error", function(e) {
                done("File write error: " + e);
                fs.unlinkSync(currentLog);
                fs.close(result);
                cb(e.message);
            });
        } catch (e) {
            done("Error: " + e);
            fs.close(result);
            cb(e);
        }
    }
    var util = angular.module("app.socket", []);
    return util.provider("Socket", function() {
        var options = this.options = {};
        /** @type {Array} */
        this.$get = [
            "$log",
            "$q",
            "$injector",
            "LocalStorage",
            "$rootScope",
            "Dialogs",
            "NwManifest",
            function(dataAndEvents, $q, $injector, Session, $rootScope, $window, operation) {
                /**
                 * @return {undefined}
                 */
                function init() {
                    sock = new SockJS(options.websocketUrl, null, {
                        protocols_whitelist: ["websocket", "xdr-streaming", "xhr-streaming", "iframe-eventsource", "iframe-htmlfile"]
                    });
                    /**
                     * @return {undefined}
                     */
                    sock.onopen = function() {
                        if ($injector.get("Auth").Me) {
                            sock.send("auth " + Session.get("auth"));
                        } else {
                            obj.send();
                            /** @type {boolean} */
                            self.connected = true;
                        }
                        if (options.gzip) {
                            sock.send("gzip on");
                        }
                    };
                    /**
                     * @param {MessageEvent} e
                     * @return {undefined}
                     */
                    sock.onmessage = function(e) {
                        var p;
                        if ("gz:" == e.data.substring(0, 3) && (e.data = pako.ungzip(atob(e.data.substring(3)), {to: "string"})), p = e.data.match(/^auth ok (.*)$/)) {
                            obj.send();
                            /** @type {boolean} */
                            self.connected = true;
                            $injector.get("Auth").set(p[1]);
                        } else {
                            if ("auth failed" == e.data) {
                                obj.send();
                                /** @type {boolean} */
                                self.connected = true;
                            } else {
                                if (p = e.data.match(/^time (\d+)$/)) {
                                    /** @type {number} */
                                    self.timeCorrection = p[1] - Date.now();
                                } else {
                                    if (p = e.data.match(/^protocol (\d+)$/)) {
                                        /** @type {number} */
                                        self.protocolVersion = parseInt(p[1]);
                                    } else {
                                        if ("server down" == e.data) {
                                            if (!Session.get("ignoreServerDown", 0)) {
                                                /** @type {boolean} */
                                                n = false;
                                                $window.alert("Under construction", window.nw
                                                    ? "The server is under maintenance. Please restart."
                                                    : "The server is under maintenance. Please reload the page.");
                                                sock.close();
                                            }
                                        } else {
                                            if (p = e.data.match(/^package (\d+)$/)) {
                                                /** @type {number} */
                                                self.packageVersion = parseInt(p[1]);
                                                if (window.nw) {
                                                    if (self.packageVersion > operation.packageVersion) {
                                                        init(self.packageVersion, function(dataAndEvents, deepDataAndEvents) {
                                                            return $rootScope.$apply(function() {
                                                                if (!dataAndEvents) {
                                                                    /** @type {boolean} */
                                                                    self.newPackageDownloaded = true;
                                                                }
                                                            });
                                                        });
                                                    }
                                                }
                                            } else {
                                                /** @type {*} */
                                                var r = JSON.parse(e.data);
                                                self.fireEvent(r[0], r[1]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                    /**
                     * @return {undefined}
                     */
                    sock.onclose = function() {
                        obj.reset();
                        /** @type {boolean} */
                        self.connected = false;
                        if (n) {
                            setTimeout(init, 1E3);
                        }
                    };
                }
                var sock;
                var button = ($q.defer(), $({}));
                var self = {
                    clientProtocolVersion: options.clientProtocolVersion,
                    clientPackageVersion: options.clientPackageVersion,
                    connected: false,
                    timeCorrection: 0,
                    options: options
                };
                /** @type {boolean} */
                var n = false;
                var obj = {
                    list: {},
                    /**
                     * @param {string} id
                     * @return {undefined}
                     */
                    add: function(id) {
                        /** @type {string} */
                        this.list[id] = "pending";
                        if (self.connected) {
                            sock.send("subscribe " + id);
                            /** @type {string} */
                            this.list[id] = "sent";
                        }
                    },
                    /**
                     * @param {?} keepData
                     * @return {undefined}
                     */
                    remove: function(keepData) {
                        if ("sent" == this.list[keepData]) {
                            if (self.connected) {
                                sock.send("unsubscribe " + keepData);
                            }
                        }
                        delete this.list[keepData];
                    },
                    /**
                     * @return {undefined}
                     */
                    send: function() {
                        var i;
                        for (i in this.list) {
                            if ("pending" == this.list[i]) {
                                sock.send("subscribe " + i);
                                /** @type {string} */
                                this.list[i] = "sent";
                            }
                        }
                    },
                    /**
                     * @return {undefined}
                     */
                    reset: function() {
                        var pp;
                        for (pp in this.list) {
                            /** @type {string} */
                            this.list[pp] = "pending";
                        }
                    }
                };
                return self.now = function() {
                    return Date.now() + self.timeCorrection;
                },
                self.subscribe = function(attr) {
                    obj.add(attr);
                },
                self.unsubscribe = function(type) {
                    obj.remove(type);
                },
                self.on = function(type, callback) {
                    self.subscribe(type);
                    button.bind(btoa(type), callback);
                },
                self.off = function(type, handler) {
                    self.unsubscribe(type);
                    button.unbind(btoa(type), handler);
                },
                self.fireEvent = function(data, args) {
                    var buffer = data.match(/^err@(.*)$/);
                    if (buffer) {
                        data = buffer[1];
                    }
                    var basePrototype = $.Event(btoa(data));
                    basePrototype.edata = args;
                    /** @type {boolean} */
                    basePrototype.error = !!buffer;
                    button.trigger(basePrototype);
                },
                self.bindEventToScope = function(scope, event, fn, callback) {
                    options = options || {};
                    var that = {};
                    return that.listener = function(data) {
                        scope.$applyAsync(function() {
                            try {
                                data.type = atob(data.type);
                            } catch (a) {}
                            if (data.error) {
                                if (callback) {
                                    callback(data.edata, data);
                                }
                            } else {
                                fn(data.edata, data);
                            }
                        });
                    },
                    that.remove = function() {
                        if (that.listener) {
                            self.off(event, that.listener);
                            /** @type {null} */
                            that.listener = null;
                        }
                    },
                    self.on(event, that.listener),
                    scope.$on("$destroy", function() {
                        that.remove();
                    }),
                    that;
                },
                self.bindConnect = function(scope) {
                    /** @type {boolean} */
                    n = true;
                    init();
                    scope.$on("$destroy", function() {
                        sock.close();
                        /** @type {boolean} */
                        n = false;
                    });
                },
                self.reconnect = function() {
                    if (n) {
                        sock.close();
                    }
                },
                self;
            }
        ];
    }), {};
}();
var $__app_95_utils_47_static_45_maps__ = function() {
    var module = angular.module("app.static-maps", []);
    /** @type {string} */
    var charArray = "0123456789abcdef";
    return module.factory("StaticMaps", [
        "Loader",
        "$http",
        "Constants",
        "$q",
        function(appLoading, $templateCache, dataAndEvents, $q) {
            var _ = {
                /**
                 * @param {string} key
                 * @return {?}
                 */
                get: function(key) {
                    var collection = this;
                    if ("custom" == key) {
                        /** @type {string} */
                        var optsData = "";
                        /** @type {number} */
                        var j = 0;
                        for (; 2500 > j; j++) {
                            optsData += 0 == j || (49 == j || (2450 == j || 2499 == j))
                                ? "1"
                                : "0";
                        }
                        /** @type {Array} */
                        var self = [];
                        /** @type {number} */
                        j = 0;
                        for (; 50 > j; j++) {
                            if (17 > j || j > 32) {
                                self.push({_id: _.getUniqueId(self), type: "wall", x: j, y: 0, room: "sim"});
                                self.push({_id: _.getUniqueId(self), type: "wall", x: j, y: 49, room: "sim"});
                                self.push({_id: _.getUniqueId(self), type: "wall", x: 0, y: j, room: "sim"});
                                self.push({_id: _.getUniqueId(self), type: "wall", x: 49, y: j, room: "sim"});
                            }
                        }
                        return self.push({
                            _id: _.getUniqueId(self),
                            type: "controller",
                            x: 25,
                            y: 25,
                            level: 1,
                            progress: 0,
                            room: "sim"
                        }),
                        $q.when({
                            terrain: [
                                {
                                    _id: "terrain",
                                    room: "sim",
                                    type: "terrain",
                                    terrain: optsData
                                }
                            ],
                            objects: self
                        });
                    }
                    return appLoading.loading($templateCache.get("vendor/map-" + key + ".json?4").then(function(item) {
                        return item.data.terrain
                            ? (item.data.terrain[0].room = "sim", item.data.objects.forEach(function(user) {
                                /** @type {string} */
                                user.room = "sim";
                                user._id = _.getUniqueId(item.data.objects);
                            }), item.data)
                            : {
                                terrain: [
                                    {
                                        _id: "terrain",
                                        type: "terrain",
                                        terrain: collection.encodeTerrain(item.data),
                                        room: "sim"
                                    }
                                ],
                                objects: _.filter(item.data, function(entity) {
                                    return entity.room = "sim",
                                    entity._id = _.getUniqueId(item.data),
                                    "wall" != entity.type && "swamp" != entity.type;
                                })
                            };
                    }));
                },
                /**
                 * @param {string} optgroup
                 * @return {?}
                 */
                encodeTerrain: function(optgroup) {
                    /** @type {string} */
                    var optsData = "";
                    /** @type {number} */
                    var moveY = 0;
                    for (; 50 > moveY; moveY++) {
                        /** @type {number} */
                        var moveX = 0;
                        for (; 50 > moveX; moveX++) {
                            var reversed = _.filter(optgroup, {
                                x: moveX,
                                y: moveY
                            });
                            /** @type {number} */
                            var buf = 0;
                            if (_.any(reversed, {type: "wall"})) {
                                buf |= dataAndEvents.TERRAIN_MASK_WALL;
                            }
                            if (_.any(reversed, {type: "swamp"})) {
                                buf |= dataAndEvents.TERRAIN_MASK_SWAMP;
                            }
                            optsData += buf;
                        }
                    }
                    return optsData;
                },
                /**
                 * @param {?} str
                 * @param {string} sim
                 * @return {?}
                 */
                decodeTerrain: function(str, sim) {
                    /** @type {Array} */
                    var res = [];
                    /** @type {number} */
                    var j = 0;
                    for (; 50 > j; j++) {
                        /** @type {number} */
                        var i = 0;
                        for (; 50 > i; i++) {
                            var TERRAIN_MASK_WALL = str.charAt(50 * j + i);
                            if (TERRAIN_MASK_WALL & dataAndEvents.TERRAIN_MASK_WALL) {
                                res.push({room: sim, x: i, y: j, type: "wall"});
                            }
                            if (TERRAIN_MASK_WALL & dataAndEvents.TERRAIN_MASK_SWAMP) {
                                res.push({room: sim, x: i, y: j, type: "swamp"});
                            }
                        }
                    }
                    return res;
                },
                /**
                 * @param {?} item
                 * @return {?}
                 */
                getUniqueId: function(item) {
                    var id;
                    /** @type {number} */
                    var d = 0;
                    do {
                        /** @type {string} */
                        id = "";
                        /** @type {number} */
                        var e = 0;
                        for (; 24 > e; e++) {
                            id += charArray[Math.floor(Math.random() * charArray.length)];
                        }
                        d++;
                    } while (_.any(item, {_id: id}));
                    return id;
                }
            };
            return _;
        }
    ]), {};
}();
